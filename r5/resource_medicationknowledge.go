// Code generated by gofhir. DO NOT EDIT.
// Source: FHIR StructureDefinitions (consolidated resource)
// Package: r5

package r5

import (
	"bytes"
	"encoding/json"
	"encoding/xml"
	"fmt"
)

// =============================================================================
// MedicationKnowledge Resource
// =============================================================================

// MedicationKnowledge represents FHIR MedicationKnowledge.
type MedicationKnowledge struct {
	// FHIR resource type
	ResourceType string `json:"resourceType"`
	// Logical id of this artifact
	Id *string `json:"id,omitempty"`
	// Metadata about the resource
	Meta *Meta `json:"meta,omitempty"`
	// A set of rules under which this content was created
	ImplicitRules *string `json:"implicitRules,omitempty"`
	// Extension for ImplicitRules
	ImplicitRulesExt *Element `json:"_implicitRules,omitempty"`
	// Language of the resource content
	Language *string `json:"language,omitempty"`
	// Extension for Language
	LanguageExt *Element `json:"_language,omitempty"`
	// Text summary of the resource, for human interpretation
	Text *Narrative `json:"text,omitempty"`
	// Contained, inline Resources
	Contained []Resource `json:"contained,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Business identifier for this medication
	Identifier []Identifier `json:"identifier,omitempty"`
	// Code that identifies this medication
	Code *CodeableConcept `json:"code,omitempty"`
	// active | entered-in-error | inactive
	Status *MedicationKnowledgeStatusCodes `json:"status,omitempty"`
	// Extension for Status
	StatusExt *Element `json:"_status,omitempty"`
	// Creator or owner of the knowledge or information about the medication
	Author *Reference `json:"author,omitempty"`
	// Codes that identify the different jurisdictions for which the information of this resource was created
	IntendedJurisdiction []CodeableConcept `json:"intendedJurisdiction,omitempty"`
	// A name associated with the medication being described
	Name []string `json:"name,omitempty"`
	// Extension for Name
	NameExt []Element `json:"_name,omitempty"`
	// Associated or related medication information
	RelatedMedicationKnowledge []MedicationKnowledgeRelatedMedicationKnowledge `json:"relatedMedicationKnowledge,omitempty"`
	// The set of medication resources that are associated with this medication
	AssociatedMedication []Reference `json:"associatedMedication,omitempty"`
	// Category of the medication or product
	ProductType []CodeableConcept `json:"productType,omitempty"`
	// Associated documentation about the medication
	Monograph []MedicationKnowledgeMonograph `json:"monograph,omitempty"`
	// The instructions for preparing the medication
	PreparationInstruction *string `json:"preparationInstruction,omitempty"`
	// Extension for PreparationInstruction
	PreparationInstructionExt *Element `json:"_preparationInstruction,omitempty"`
	// The pricing of the medication
	Cost []MedicationKnowledgeCost `json:"cost,omitempty"`
	// Program under which a medication is reviewed
	MonitoringProgram []MedicationKnowledgeMonitoringProgram `json:"monitoringProgram,omitempty"`
	// Guidelines or protocols for administration of the medication for an indication
	IndicationGuideline []MedicationKnowledgeIndicationGuideline `json:"indicationGuideline,omitempty"`
	// Categorization of the medication within a formulary or classification system
	MedicineClassification []MedicationKnowledgeMedicineClassification `json:"medicineClassification,omitempty"`
	// Details about packaged medications
	Packaging []MedicationKnowledgePackaging `json:"packaging,omitempty"`
	// Potential clinical issue with or between medication(s)
	ClinicalUseIssue []Reference `json:"clinicalUseIssue,omitempty"`
	// How the medication should be stored
	StorageGuideline []MedicationKnowledgeStorageGuideline `json:"storageGuideline,omitempty"`
	// Regulatory information about a medication
	Regulatory []MedicationKnowledgeRegulatory `json:"regulatory,omitempty"`
	// Minimal definition information about the medication
	Definitional *MedicationKnowledgeDefinitional `json:"definitional,omitempty"`
}

// GetResourceType returns the FHIR resource type.
func (r *MedicationKnowledge) GetResourceType() string {
	return "MedicationKnowledge"
}

// GetId returns the resource's logical ID.
func (r *MedicationKnowledge) GetId() *string {
	return r.Id
}

// SetId sets the resource's logical ID.
func (r *MedicationKnowledge) SetId(id string) {
	r.Id = &id
}

// GetMeta returns the resource's Meta element.
func (r *MedicationKnowledge) GetMeta() *Meta {
	return r.Meta
}

// SetMeta sets the resource's Meta element.
func (r *MedicationKnowledge) SetMeta(m *Meta) {
	r.Meta = m
}

// GetText returns the resource's narrative text.
func (r *MedicationKnowledge) GetText() *Narrative {
	return r.Text
}

// SetText sets the resource's narrative text.
func (r *MedicationKnowledge) SetText(t *Narrative) {
	r.Text = t
}

// GetContained returns the resource's contained resources.
func (r *MedicationKnowledge) GetContained() []Resource {
	return r.Contained
}

// GetExtension returns the resource's extensions.
func (r *MedicationKnowledge) GetExtension() []Extension {
	return r.Extension
}

// GetModifierExtension returns the resource's modifier extensions.
func (r *MedicationKnowledge) GetModifierExtension() []Extension {
	return r.ModifierExtension
}

// MarshalJSON ensures resourceType is always included in JSON output.
// HTML escaping is disabled to preserve FHIR narrative XHTML content.
//
// Note: Use the package-level Marshal function instead of json.Marshal
// to ensure HTML in narrative text.div fields is not escaped.
func (r MedicationKnowledge) MarshalJSON() ([]byte, error) {
	r.ResourceType = "MedicationKnowledge"
	type Alias MedicationKnowledge
	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	enc.SetEscapeHTML(false)
	if err := enc.Encode((Alias)(r)); err != nil {
		return nil, err
	}
	b := buf.Bytes()
	if len(b) > 0 && b[len(b)-1] == '\n' {
		b = b[:len(b)-1]
	}
	return b, nil
}

// UnmarshalJSON handles deserialization of polymorphic contained resources.
func (r *MedicationKnowledge) UnmarshalJSON(data []byte) error {
	// Use an alias to avoid infinite recursion
	type Alias MedicationKnowledge
	aux := &struct {
		Contained []json.RawMessage `json:"contained,omitempty"`
		*Alias
	}{
		Alias: (*Alias)(r),
	}

	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}

	// Unmarshal each contained resource using the dispatcher
	if len(aux.Contained) > 0 {
		r.Contained = make([]Resource, len(aux.Contained))
		for i, raw := range aux.Contained {
			resource, err := UnmarshalResource(raw)
			if err != nil {
				return fmt.Errorf("failed to unmarshal contained[%d]: %w", i, err)
			}
			r.Contained[i] = resource
		}
	}

	return nil
}

// MarshalXML serializes MedicationKnowledge to FHIR-conformant XML.
func (r MedicationKnowledge) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MedicationKnowledge"
		start.Name.Space = fhirNamespace
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	if err := xmlEncodePrimitiveString(e, "id", r.Id, nil); err != nil {
		return err
	}
	if r.Meta != nil {
		if err := r.Meta.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "meta"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "implicitRules", r.ImplicitRules, r.ImplicitRulesExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "language", r.Language, r.LanguageExt); err != nil {
		return err
	}
	if r.Text != nil {
		if err := r.Text.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "text"}}); err != nil {
			return err
		}
	}
	for _, c := range r.Contained {
		if c != nil {
			if err := xmlEncodeContainedResource(e, c); err != nil {
				return err
			}
		}
	}
	for _, item := range r.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range r.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Identifier {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "identifier"}}); err != nil {
			return err
		}
	}
	if r.Code != nil {
		if err := r.Code.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "code"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveCode(e, "status", r.Status, r.StatusExt); err != nil {
		return err
	}
	if r.Author != nil {
		if err := r.Author.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "author"}}); err != nil {
			return err
		}
	}
	for _, item := range r.IntendedJurisdiction {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "intendedJurisdiction"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveStringArray(e, "name", r.Name, r.NameExt); err != nil {
		return err
	}
	for _, item := range r.RelatedMedicationKnowledge {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "relatedMedicationKnowledge"}}); err != nil {
			return err
		}
	}
	for _, item := range r.AssociatedMedication {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "associatedMedication"}}); err != nil {
			return err
		}
	}
	for _, item := range r.ProductType {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "productType"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Monograph {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "monograph"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "preparationInstruction", r.PreparationInstruction, r.PreparationInstructionExt); err != nil {
		return err
	}
	for _, item := range r.Cost {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "cost"}}); err != nil {
			return err
		}
	}
	for _, item := range r.MonitoringProgram {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "monitoringProgram"}}); err != nil {
			return err
		}
	}
	for _, item := range r.IndicationGuideline {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "indicationGuideline"}}); err != nil {
			return err
		}
	}
	for _, item := range r.MedicineClassification {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "medicineClassification"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Packaging {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "packaging"}}); err != nil {
			return err
		}
	}
	for _, item := range r.ClinicalUseIssue {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "clinicalUseIssue"}}); err != nil {
			return err
		}
	}
	for _, item := range r.StorageGuideline {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "storageGuideline"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Regulatory {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "regulatory"}}); err != nil {
			return err
		}
	}
	if r.Definitional != nil {
		if err := r.Definitional.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "definitional"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MedicationKnowledge from FHIR-conformant XML.
func (r *MedicationKnowledge) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "id":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Id = v
			case "meta":
				var v Meta
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Meta = &v
			case "implicitRules":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ImplicitRules = v
				r.ImplicitRulesExt = ext
			case "language":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Language = v
				r.LanguageExt = ext
			case "text":
				var v Narrative
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Text = &v
			case "contained":
				res, err := xmlDecodeContainedResource(d, t)
				if err != nil {
					return err
				}
				if res != nil {
					r.Contained = append(r.Contained, res)
				}
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "identifier":
				var v Identifier
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Identifier = append(r.Identifier, v)
			case "code":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Code = &v
			case "status":
				v, ext, err := xmlDecodePrimitiveCode[MedicationKnowledgeStatusCodes](d, t)
				if err != nil {
					return err
				}
				r.Status = v
				r.StatusExt = ext
			case "author":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Author = &v
			case "intendedJurisdiction":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.IntendedJurisdiction = append(r.IntendedJurisdiction, v)
			case "name":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.Name = append(r.Name, *v)
				}
			case "relatedMedicationKnowledge":
				var v MedicationKnowledgeRelatedMedicationKnowledge
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.RelatedMedicationKnowledge = append(r.RelatedMedicationKnowledge, v)
			case "associatedMedication":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.AssociatedMedication = append(r.AssociatedMedication, v)
			case "productType":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ProductType = append(r.ProductType, v)
			case "monograph":
				var v MedicationKnowledgeMonograph
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Monograph = append(r.Monograph, v)
			case "preparationInstruction":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.PreparationInstruction = v
				r.PreparationInstructionExt = ext
			case "cost":
				var v MedicationKnowledgeCost
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Cost = append(r.Cost, v)
			case "monitoringProgram":
				var v MedicationKnowledgeMonitoringProgram
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.MonitoringProgram = append(r.MonitoringProgram, v)
			case "indicationGuideline":
				var v MedicationKnowledgeIndicationGuideline
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.IndicationGuideline = append(r.IndicationGuideline, v)
			case "medicineClassification":
				var v MedicationKnowledgeMedicineClassification
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.MedicineClassification = append(r.MedicineClassification, v)
			case "packaging":
				var v MedicationKnowledgePackaging
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Packaging = append(r.Packaging, v)
			case "clinicalUseIssue":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ClinicalUseIssue = append(r.ClinicalUseIssue, v)
			case "storageGuideline":
				var v MedicationKnowledgeStorageGuideline
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.StorageGuideline = append(r.StorageGuideline, v)
			case "regulatory":
				var v MedicationKnowledgeRegulatory
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Regulatory = append(r.Regulatory, v)
			case "definitional":
				var v MedicationKnowledgeDefinitional
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Definitional = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MedicationKnowledgeCost represents the MedicationKnowledge.cost backbone element.
// The pricing of the medication
type MedicationKnowledgeCost struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The date range for which the cost is effective
	EffectiveDate []Period `json:"effectiveDate,omitempty"`
	// The category of the cost information
	Type CodeableConcept `json:"type,omitempty"`
	// The source or owner for the price information
	Source *string `json:"source,omitempty"`
	// The price or category of the cost of the medication
	CostMoney *Money `json:"costMoney,omitempty"`
	// The price or category of the cost of the medication
	CostCodeableConcept *CodeableConcept `json:"costCodeableConcept,omitempty"`
}

// MarshalXML serializes MedicationKnowledgeCost to FHIR-conformant XML.
func (b MedicationKnowledgeCost) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MedicationKnowledge.cost"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.EffectiveDate {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "effectiveDate"}}); err != nil {
			return err
		}
	}
	if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "source", b.Source, nil); err != nil {
		return err
	}
	if b.CostMoney != nil {
		if err := b.CostMoney.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "costMoney"}}); err != nil {
			return err
		}
	}
	if b.CostCodeableConcept != nil {
		if err := b.CostCodeableConcept.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "costCodeableConcept"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MedicationKnowledgeCost from FHIR-conformant XML.
func (r *MedicationKnowledgeCost) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "effectiveDate":
				var v Period
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.EffectiveDate = append(r.EffectiveDate, v)
			case "type":
				if err := r.Type.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "source":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Source = v
			case "costMoney":
				var v Money
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.CostMoney = &v
			case "costCodeableConcept":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.CostCodeableConcept = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MedicationKnowledgeDefinitional represents the MedicationKnowledge.definitional backbone element.
// Minimal definition information about the medication
type MedicationKnowledgeDefinitional struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Definitional resources that provide more information about this medication
	Definition []Reference `json:"definition,omitempty"`
	// powder | tablets | capsule +
	DoseForm *CodeableConcept `json:"doseForm,omitempty"`
	// The intended or approved route of administration
	IntendedRoute []CodeableConcept `json:"intendedRoute,omitempty"`
	// Active or inactive ingredient
	Ingredient []MedicationKnowledgeDefinitionalIngredient `json:"ingredient,omitempty"`
	// Specifies descriptive properties of the medicine
	DrugCharacteristic []MedicationKnowledgeDefinitionalDrugCharacteristic `json:"drugCharacteristic,omitempty"`
}

// MarshalXML serializes MedicationKnowledgeDefinitional to FHIR-conformant XML.
func (b MedicationKnowledgeDefinitional) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MedicationKnowledge.definitional"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Definition {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "definition"}}); err != nil {
			return err
		}
	}
	if b.DoseForm != nil {
		if err := b.DoseForm.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "doseForm"}}); err != nil {
			return err
		}
	}
	for _, item := range b.IntendedRoute {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "intendedRoute"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Ingredient {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "ingredient"}}); err != nil {
			return err
		}
	}
	for _, item := range b.DrugCharacteristic {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "drugCharacteristic"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MedicationKnowledgeDefinitional from FHIR-conformant XML.
func (r *MedicationKnowledgeDefinitional) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "definition":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Definition = append(r.Definition, v)
			case "doseForm":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.DoseForm = &v
			case "intendedRoute":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.IntendedRoute = append(r.IntendedRoute, v)
			case "ingredient":
				var v MedicationKnowledgeDefinitionalIngredient
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Ingredient = append(r.Ingredient, v)
			case "drugCharacteristic":
				var v MedicationKnowledgeDefinitionalDrugCharacteristic
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.DrugCharacteristic = append(r.DrugCharacteristic, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MedicationKnowledgeDefinitionalDrugCharacteristic represents the MedicationKnowledge.definitional.drugCharacteristic backbone element.
// Specifies descriptive properties of the medicine
type MedicationKnowledgeDefinitionalDrugCharacteristic struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Code specifying the type of characteristic of medication
	Type *CodeableConcept `json:"type,omitempty"`
	// Description of the characteristic
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`
	// Description of the characteristic
	ValueString *string `json:"valueString,omitempty"`
	// Extension for ValueString
	ValueStringExt *Element `json:"_valueString,omitempty"`
	// Description of the characteristic
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`
	// Description of the characteristic
	ValueBase64Binary *string `json:"valueBase64Binary,omitempty"`
	// Extension for ValueBase64Binary
	ValueBase64BinaryExt *Element `json:"_valueBase64Binary,omitempty"`
	// Description of the characteristic
	ValueAttachment *Attachment `json:"valueAttachment,omitempty"`
}

// MarshalXML serializes MedicationKnowledgeDefinitionalDrugCharacteristic to FHIR-conformant XML.
func (b MedicationKnowledgeDefinitionalDrugCharacteristic) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MedicationKnowledge.definitional.drugCharacteristic"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.Type != nil {
		if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
			return err
		}
	}
	if b.ValueCodeableConcept != nil {
		if err := b.ValueCodeableConcept.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueCodeableConcept"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "valueString", b.ValueString, nil); err != nil {
		return err
	}
	if b.ValueQuantity != nil {
		if err := b.ValueQuantity.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueQuantity"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "valueBase64Binary", b.ValueBase64Binary, nil); err != nil {
		return err
	}
	if b.ValueAttachment != nil {
		if err := b.ValueAttachment.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueAttachment"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MedicationKnowledgeDefinitionalDrugCharacteristic from FHIR-conformant XML.
func (r *MedicationKnowledgeDefinitionalDrugCharacteristic) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "type":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Type = &v
			case "valueCodeableConcept":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueCodeableConcept = &v
			case "valueString":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ValueString = v
			case "valueQuantity":
				var v Quantity
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueQuantity = &v
			case "valueBase64Binary":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ValueBase64Binary = v
			case "valueAttachment":
				var v Attachment
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueAttachment = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MedicationKnowledgeDefinitionalIngredient represents the MedicationKnowledge.definitional.ingredient backbone element.
// Active or inactive ingredient
type MedicationKnowledgeDefinitionalIngredient struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Substances contained in the medication
	Item CodeableReference `json:"item,omitempty"`
	// A code that defines the type of ingredient, active, base, etc
	Type *CodeableConcept `json:"type,omitempty"`
	// Quantity of ingredient present
	StrengthRatio *Ratio `json:"strengthRatio,omitempty"`
	// Quantity of ingredient present
	StrengthCodeableConcept *CodeableConcept `json:"strengthCodeableConcept,omitempty"`
	// Quantity of ingredient present
	StrengthQuantity *Quantity `json:"strengthQuantity,omitempty"`
}

// MarshalXML serializes MedicationKnowledgeDefinitionalIngredient to FHIR-conformant XML.
func (b MedicationKnowledgeDefinitionalIngredient) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MedicationKnowledge.definitional.ingredient"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := b.Item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "item"}}); err != nil {
		return err
	}
	if b.Type != nil {
		if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
			return err
		}
	}
	if b.StrengthRatio != nil {
		if err := b.StrengthRatio.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "strengthRatio"}}); err != nil {
			return err
		}
	}
	if b.StrengthCodeableConcept != nil {
		if err := b.StrengthCodeableConcept.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "strengthCodeableConcept"}}); err != nil {
			return err
		}
	}
	if b.StrengthQuantity != nil {
		if err := b.StrengthQuantity.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "strengthQuantity"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MedicationKnowledgeDefinitionalIngredient from FHIR-conformant XML.
func (r *MedicationKnowledgeDefinitionalIngredient) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "item":
				if err := r.Item.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "type":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Type = &v
			case "strengthRatio":
				var v Ratio
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.StrengthRatio = &v
			case "strengthCodeableConcept":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.StrengthCodeableConcept = &v
			case "strengthQuantity":
				var v Quantity
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.StrengthQuantity = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MedicationKnowledgeIndicationGuideline represents the MedicationKnowledge.indicationGuideline backbone element.
// Guidelines or protocols for administration of the medication for an indication
type MedicationKnowledgeIndicationGuideline struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Indication for use that applies to the specific administration guideline
	Indication []CodeableReference `json:"indication,omitempty"`
	// Guidelines for dosage of the medication
	DosingGuideline []MedicationKnowledgeIndicationGuidelineDosingGuideline `json:"dosingGuideline,omitempty"`
}

// MarshalXML serializes MedicationKnowledgeIndicationGuideline to FHIR-conformant XML.
func (b MedicationKnowledgeIndicationGuideline) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MedicationKnowledge.indicationGuideline"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Indication {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "indication"}}); err != nil {
			return err
		}
	}
	for _, item := range b.DosingGuideline {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "dosingGuideline"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MedicationKnowledgeIndicationGuideline from FHIR-conformant XML.
func (r *MedicationKnowledgeIndicationGuideline) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "indication":
				var v CodeableReference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Indication = append(r.Indication, v)
			case "dosingGuideline":
				var v MedicationKnowledgeIndicationGuidelineDosingGuideline
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.DosingGuideline = append(r.DosingGuideline, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MedicationKnowledgeIndicationGuidelineDosingGuideline represents the MedicationKnowledge.indicationGuideline.dosingGuideline backbone element.
// Guidelines for dosage of the medication
type MedicationKnowledgeIndicationGuidelineDosingGuideline struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Intention of the treatment
	TreatmentIntent *CodeableConcept `json:"treatmentIntent,omitempty"`
	// Dosage for the medication for the specific guidelines
	Dosage []MedicationKnowledgeIndicationGuidelineDosingGuidelineDosage `json:"dosage,omitempty"`
	// Type of treatment the guideline applies to
	AdministrationTreatment *CodeableConcept `json:"administrationTreatment,omitempty"`
	// Characteristics of the patient that are relevant to the administration guidelines
	PatientCharacteristic []MedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic `json:"patientCharacteristic,omitempty"`
}

// MarshalXML serializes MedicationKnowledgeIndicationGuidelineDosingGuideline to FHIR-conformant XML.
func (b MedicationKnowledgeIndicationGuidelineDosingGuideline) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MedicationKnowledge.indicationGuideline.dosingGuideline"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.TreatmentIntent != nil {
		if err := b.TreatmentIntent.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "treatmentIntent"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Dosage {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "dosage"}}); err != nil {
			return err
		}
	}
	if b.AdministrationTreatment != nil {
		if err := b.AdministrationTreatment.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "administrationTreatment"}}); err != nil {
			return err
		}
	}
	for _, item := range b.PatientCharacteristic {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "patientCharacteristic"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MedicationKnowledgeIndicationGuidelineDosingGuideline from FHIR-conformant XML.
func (r *MedicationKnowledgeIndicationGuidelineDosingGuideline) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "treatmentIntent":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.TreatmentIntent = &v
			case "dosage":
				var v MedicationKnowledgeIndicationGuidelineDosingGuidelineDosage
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Dosage = append(r.Dosage, v)
			case "administrationTreatment":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.AdministrationTreatment = &v
			case "patientCharacteristic":
				var v MedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.PatientCharacteristic = append(r.PatientCharacteristic, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MedicationKnowledgeIndicationGuidelineDosingGuidelineDosage represents the MedicationKnowledge.indicationGuideline.dosingGuideline.dosage backbone element.
// Dosage for the medication for the specific guidelines
type MedicationKnowledgeIndicationGuidelineDosingGuidelineDosage struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Category of dosage for a medication
	Type CodeableConcept `json:"type,omitempty"`
	// Dosage for the medication for the specific guidelines
	Dosage []Dosage `json:"dosage,omitempty"`
}

// MarshalXML serializes MedicationKnowledgeIndicationGuidelineDosingGuidelineDosage to FHIR-conformant XML.
func (b MedicationKnowledgeIndicationGuidelineDosingGuidelineDosage) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MedicationKnowledge.indicationGuideline.dosingGuideline.dosage"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
		return err
	}
	for _, item := range b.Dosage {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "dosage"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MedicationKnowledgeIndicationGuidelineDosingGuidelineDosage from FHIR-conformant XML.
func (r *MedicationKnowledgeIndicationGuidelineDosingGuidelineDosage) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "type":
				if err := r.Type.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "dosage":
				var v Dosage
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Dosage = append(r.Dosage, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic represents the MedicationKnowledge.indicationGuideline.dosingGuideline.patientCharacteristic backbone element.
// Characteristics of the patient that are relevant to the administration guidelines
type MedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Categorization of specific characteristic that is relevant to the administration guideline
	Type CodeableConcept `json:"type,omitempty"`
	// The specific characteristic
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`
	// The specific characteristic
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`
	// The specific characteristic
	ValueRange *Range `json:"valueRange,omitempty"`
}

// MarshalXML serializes MedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic to FHIR-conformant XML.
func (b MedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MedicationKnowledge.indicationGuideline.dosingGuideline.patientCharacteristic"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
		return err
	}
	if b.ValueCodeableConcept != nil {
		if err := b.ValueCodeableConcept.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueCodeableConcept"}}); err != nil {
			return err
		}
	}
	if b.ValueQuantity != nil {
		if err := b.ValueQuantity.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueQuantity"}}); err != nil {
			return err
		}
	}
	if b.ValueRange != nil {
		if err := b.ValueRange.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueRange"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic from FHIR-conformant XML.
func (r *MedicationKnowledgeIndicationGuidelineDosingGuidelinePatientCharacteristic) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "type":
				if err := r.Type.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "valueCodeableConcept":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueCodeableConcept = &v
			case "valueQuantity":
				var v Quantity
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueQuantity = &v
			case "valueRange":
				var v Range
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueRange = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MedicationKnowledgeMedicineClassification represents the MedicationKnowledge.medicineClassification backbone element.
// Categorization of the medication within a formulary or classification system
type MedicationKnowledgeMedicineClassification struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The type of category for the medication (for example, therapeutic classification, therapeutic sub-classification)
	Type CodeableConcept `json:"type,omitempty"`
	// The source of the classification
	SourceString *string `json:"sourceString,omitempty"`
	// Extension for SourceString
	SourceStringExt *Element `json:"_sourceString,omitempty"`
	// The source of the classification
	SourceUri *string `json:"sourceUri,omitempty"`
	// Extension for SourceUri
	SourceUriExt *Element `json:"_sourceUri,omitempty"`
	// Specific category assigned to the medication
	Classification []CodeableConcept `json:"classification,omitempty"`
}

// MarshalXML serializes MedicationKnowledgeMedicineClassification to FHIR-conformant XML.
func (b MedicationKnowledgeMedicineClassification) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MedicationKnowledge.medicineClassification"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "sourceString", b.SourceString, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "sourceUri", b.SourceUri, nil); err != nil {
		return err
	}
	for _, item := range b.Classification {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "classification"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MedicationKnowledgeMedicineClassification from FHIR-conformant XML.
func (r *MedicationKnowledgeMedicineClassification) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "type":
				if err := r.Type.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "sourceString":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.SourceString = v
			case "sourceUri":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.SourceUri = v
			case "classification":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Classification = append(r.Classification, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MedicationKnowledgeMonitoringProgram represents the MedicationKnowledge.monitoringProgram backbone element.
// Program under which a medication is reviewed
type MedicationKnowledgeMonitoringProgram struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Type of program under which the medication is monitored
	Type *CodeableConcept `json:"type,omitempty"`
	// Name of the reviewing program
	Name *string `json:"name,omitempty"`
}

// MarshalXML serializes MedicationKnowledgeMonitoringProgram to FHIR-conformant XML.
func (b MedicationKnowledgeMonitoringProgram) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MedicationKnowledge.monitoringProgram"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.Type != nil {
		if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "name", b.Name, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MedicationKnowledgeMonitoringProgram from FHIR-conformant XML.
func (r *MedicationKnowledgeMonitoringProgram) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "type":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Type = &v
			case "name":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Name = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MedicationKnowledgeMonograph represents the MedicationKnowledge.monograph backbone element.
// Associated documentation about the medication
type MedicationKnowledgeMonograph struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The category of medication document
	Type *CodeableConcept `json:"type,omitempty"`
	// Associated documentation about the medication
	Source *Reference `json:"source,omitempty"`
}

// MarshalXML serializes MedicationKnowledgeMonograph to FHIR-conformant XML.
func (b MedicationKnowledgeMonograph) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MedicationKnowledge.monograph"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.Type != nil {
		if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
			return err
		}
	}
	if b.Source != nil {
		if err := b.Source.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "source"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MedicationKnowledgeMonograph from FHIR-conformant XML.
func (r *MedicationKnowledgeMonograph) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "type":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Type = &v
			case "source":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Source = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MedicationKnowledgePackaging represents the MedicationKnowledge.packaging backbone element.
// Details about packaged medications
type MedicationKnowledgePackaging struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Cost of the packaged medication
	Cost []MedicationKnowledgeCost `json:"cost,omitempty"`
	// The packaged medication that is being priced
	PackagedProduct *Reference `json:"packagedProduct,omitempty"`
}

// MarshalXML serializes MedicationKnowledgePackaging to FHIR-conformant XML.
func (b MedicationKnowledgePackaging) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MedicationKnowledge.packaging"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Cost {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "cost"}}); err != nil {
			return err
		}
	}
	if b.PackagedProduct != nil {
		if err := b.PackagedProduct.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "packagedProduct"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MedicationKnowledgePackaging from FHIR-conformant XML.
func (r *MedicationKnowledgePackaging) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "cost":
				var v MedicationKnowledgeCost
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Cost = append(r.Cost, v)
			case "packagedProduct":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.PackagedProduct = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MedicationKnowledgeRegulatory represents the MedicationKnowledge.regulatory backbone element.
// Regulatory information about a medication
type MedicationKnowledgeRegulatory struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Specifies the authority of the regulation
	RegulatoryAuthority Reference `json:"regulatoryAuthority,omitempty"`
	// Specifies if changes are allowed when dispensing a medication from a regulatory perspective
	Substitution []MedicationKnowledgeRegulatorySubstitution `json:"substitution,omitempty"`
	// Specifies the schedule of a medication in jurisdiction
	Schedule []CodeableConcept `json:"schedule,omitempty"`
	// The maximum number of units of the medication that can be dispensed in a period
	MaxDispense *MedicationKnowledgeRegulatoryMaxDispense `json:"maxDispense,omitempty"`
}

// MarshalXML serializes MedicationKnowledgeRegulatory to FHIR-conformant XML.
func (b MedicationKnowledgeRegulatory) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MedicationKnowledge.regulatory"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := b.RegulatoryAuthority.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "regulatoryAuthority"}}); err != nil {
		return err
	}
	for _, item := range b.Substitution {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "substitution"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Schedule {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "schedule"}}); err != nil {
			return err
		}
	}
	if b.MaxDispense != nil {
		if err := b.MaxDispense.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "maxDispense"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MedicationKnowledgeRegulatory from FHIR-conformant XML.
func (r *MedicationKnowledgeRegulatory) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "regulatoryAuthority":
				if err := r.RegulatoryAuthority.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "substitution":
				var v MedicationKnowledgeRegulatorySubstitution
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Substitution = append(r.Substitution, v)
			case "schedule":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Schedule = append(r.Schedule, v)
			case "maxDispense":
				var v MedicationKnowledgeRegulatoryMaxDispense
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.MaxDispense = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MedicationKnowledgeRegulatoryMaxDispense represents the MedicationKnowledge.regulatory.maxDispense backbone element.
// The maximum number of units of the medication that can be dispensed in a period
type MedicationKnowledgeRegulatoryMaxDispense struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The maximum number of units of the medication that can be dispensed
	Quantity Quantity `json:"quantity,omitempty"`
	// The period that applies to the maximum number of units
	Period *Duration `json:"period,omitempty"`
}

// MarshalXML serializes MedicationKnowledgeRegulatoryMaxDispense to FHIR-conformant XML.
func (b MedicationKnowledgeRegulatoryMaxDispense) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MedicationKnowledge.regulatory.maxDispense"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := b.Quantity.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "quantity"}}); err != nil {
		return err
	}
	if b.Period != nil {
		if err := b.Period.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "period"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MedicationKnowledgeRegulatoryMaxDispense from FHIR-conformant XML.
func (r *MedicationKnowledgeRegulatoryMaxDispense) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "quantity":
				if err := r.Quantity.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "period":
				var v Duration
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Period = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MedicationKnowledgeRegulatorySubstitution represents the MedicationKnowledge.regulatory.substitution backbone element.
// Specifies if changes are allowed when dispensing a medication from a regulatory perspective
type MedicationKnowledgeRegulatorySubstitution struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Specifies the type of substitution allowed
	Type CodeableConcept `json:"type,omitempty"`
	// Specifies if regulation allows for changes in the medication when dispensing
	Allowed *bool `json:"allowed,omitempty"`
}

// MarshalXML serializes MedicationKnowledgeRegulatorySubstitution to FHIR-conformant XML.
func (b MedicationKnowledgeRegulatorySubstitution) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MedicationKnowledge.regulatory.substitution"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveBool(e, "allowed", b.Allowed, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MedicationKnowledgeRegulatorySubstitution from FHIR-conformant XML.
func (r *MedicationKnowledgeRegulatorySubstitution) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "type":
				if err := r.Type.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "allowed":
				v, _, err := xmlDecodePrimitiveBool(d, t)
				if err != nil {
					return err
				}
				r.Allowed = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MedicationKnowledgeRelatedMedicationKnowledge represents the MedicationKnowledge.relatedMedicationKnowledge backbone element.
// Associated or related medication information
type MedicationKnowledgeRelatedMedicationKnowledge struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Category of medicationKnowledge
	Type CodeableConcept `json:"type,omitempty"`
	// Associated documentation about the associated medication knowledge
	Reference []Reference `json:"reference,omitempty"`
}

// MarshalXML serializes MedicationKnowledgeRelatedMedicationKnowledge to FHIR-conformant XML.
func (b MedicationKnowledgeRelatedMedicationKnowledge) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MedicationKnowledge.relatedMedicationKnowledge"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
		return err
	}
	for _, item := range b.Reference {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "reference"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MedicationKnowledgeRelatedMedicationKnowledge from FHIR-conformant XML.
func (r *MedicationKnowledgeRelatedMedicationKnowledge) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "type":
				if err := r.Type.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "reference":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Reference = append(r.Reference, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MedicationKnowledgeStorageGuideline represents the MedicationKnowledge.storageGuideline backbone element.
// How the medication should be stored
type MedicationKnowledgeStorageGuideline struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Reference to additional information
	Reference *string `json:"reference,omitempty"`
	// Additional storage notes
	Note []Annotation `json:"note,omitempty"`
	// Duration remains stable
	StabilityDuration *Duration `json:"stabilityDuration,omitempty"`
	// Setting or value of environment for adequate storage
	EnvironmentalSetting []MedicationKnowledgeStorageGuidelineEnvironmentalSetting `json:"environmentalSetting,omitempty"`
}

// MarshalXML serializes MedicationKnowledgeStorageGuideline to FHIR-conformant XML.
func (b MedicationKnowledgeStorageGuideline) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MedicationKnowledge.storageGuideline"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "reference", b.Reference, nil); err != nil {
		return err
	}
	for _, item := range b.Note {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "note"}}); err != nil {
			return err
		}
	}
	if b.StabilityDuration != nil {
		if err := b.StabilityDuration.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "stabilityDuration"}}); err != nil {
			return err
		}
	}
	for _, item := range b.EnvironmentalSetting {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "environmentalSetting"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MedicationKnowledgeStorageGuideline from FHIR-conformant XML.
func (r *MedicationKnowledgeStorageGuideline) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "reference":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Reference = v
			case "note":
				var v Annotation
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Note = append(r.Note, v)
			case "stabilityDuration":
				var v Duration
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.StabilityDuration = &v
			case "environmentalSetting":
				var v MedicationKnowledgeStorageGuidelineEnvironmentalSetting
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.EnvironmentalSetting = append(r.EnvironmentalSetting, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MedicationKnowledgeStorageGuidelineEnvironmentalSetting represents the MedicationKnowledge.storageGuideline.environmentalSetting backbone element.
// Setting or value of environment for adequate storage
type MedicationKnowledgeStorageGuidelineEnvironmentalSetting struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Categorization of the setting
	Type CodeableConcept `json:"type,omitempty"`
	// Value of the setting
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`
	// Value of the setting
	ValueRange *Range `json:"valueRange,omitempty"`
	// Value of the setting
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`
}

// MarshalXML serializes MedicationKnowledgeStorageGuidelineEnvironmentalSetting to FHIR-conformant XML.
func (b MedicationKnowledgeStorageGuidelineEnvironmentalSetting) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MedicationKnowledge.storageGuideline.environmentalSetting"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
		return err
	}
	if b.ValueQuantity != nil {
		if err := b.ValueQuantity.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueQuantity"}}); err != nil {
			return err
		}
	}
	if b.ValueRange != nil {
		if err := b.ValueRange.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueRange"}}); err != nil {
			return err
		}
	}
	if b.ValueCodeableConcept != nil {
		if err := b.ValueCodeableConcept.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueCodeableConcept"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MedicationKnowledgeStorageGuidelineEnvironmentalSetting from FHIR-conformant XML.
func (r *MedicationKnowledgeStorageGuidelineEnvironmentalSetting) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "type":
				if err := r.Type.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "valueQuantity":
				var v Quantity
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueQuantity = &v
			case "valueRange":
				var v Range
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueRange = &v
			case "valueCodeableConcept":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueCodeableConcept = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// =============================================================================
// MedicationKnowledge - Fluent Builder
// =============================================================================

// MedicationKnowledgeBuilder provides a fluent API for constructing MedicationKnowledge resources.
type MedicationKnowledgeBuilder struct {
	medicationKnowledge *MedicationKnowledge
}

// NewMedicationKnowledgeBuilder creates a new MedicationKnowledgeBuilder.
func NewMedicationKnowledgeBuilder() *MedicationKnowledgeBuilder {
	return &MedicationKnowledgeBuilder{
		medicationKnowledge: &MedicationKnowledge{},
	}
}

// Build returns the constructed MedicationKnowledge resource.
func (b *MedicationKnowledgeBuilder) Build() *MedicationKnowledge {
	return b.medicationKnowledge
}

// SetId sets the Id field.
func (b *MedicationKnowledgeBuilder) SetId(v string) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.Id = &v
	return b
}

// SetMeta sets the Meta field.
func (b *MedicationKnowledgeBuilder) SetMeta(v Meta) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.Meta = &v
	return b
}

// SetImplicitRules sets the ImplicitRules field.
func (b *MedicationKnowledgeBuilder) SetImplicitRules(v string) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.ImplicitRules = &v
	return b
}

// SetLanguage sets the Language field.
func (b *MedicationKnowledgeBuilder) SetLanguage(v string) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.Language = &v
	return b
}

// SetText sets the Text field.
func (b *MedicationKnowledgeBuilder) SetText(v Narrative) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.Text = &v
	return b
}

// AddContained adds a Contained element.
func (b *MedicationKnowledgeBuilder) AddContained(v Resource) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.Contained = append(b.medicationKnowledge.Contained, v)
	return b
}

// AddExtension adds a Extension element.
func (b *MedicationKnowledgeBuilder) AddExtension(v Extension) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.Extension = append(b.medicationKnowledge.Extension, v)
	return b
}

// AddModifierExtension adds a ModifierExtension element.
func (b *MedicationKnowledgeBuilder) AddModifierExtension(v Extension) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.ModifierExtension = append(b.medicationKnowledge.ModifierExtension, v)
	return b
}

// AddIdentifier adds a Identifier element.
func (b *MedicationKnowledgeBuilder) AddIdentifier(v Identifier) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.Identifier = append(b.medicationKnowledge.Identifier, v)
	return b
}

// SetCode sets the Code field.
func (b *MedicationKnowledgeBuilder) SetCode(v CodeableConcept) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.Code = &v
	return b
}

// SetStatus sets the Status field.
func (b *MedicationKnowledgeBuilder) SetStatus(v MedicationKnowledgeStatusCodes) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.Status = &v
	return b
}

// SetAuthor sets the Author field.
func (b *MedicationKnowledgeBuilder) SetAuthor(v Reference) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.Author = &v
	return b
}

// AddIntendedJurisdiction adds a IntendedJurisdiction element.
func (b *MedicationKnowledgeBuilder) AddIntendedJurisdiction(v CodeableConcept) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.IntendedJurisdiction = append(b.medicationKnowledge.IntendedJurisdiction, v)
	return b
}

// AddName adds a Name element.
func (b *MedicationKnowledgeBuilder) AddName(v string) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.Name = append(b.medicationKnowledge.Name, v)
	return b
}

// AddRelatedMedicationKnowledge adds a RelatedMedicationKnowledge element.
func (b *MedicationKnowledgeBuilder) AddRelatedMedicationKnowledge(v MedicationKnowledgeRelatedMedicationKnowledge) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.RelatedMedicationKnowledge = append(b.medicationKnowledge.RelatedMedicationKnowledge, v)
	return b
}

// AddAssociatedMedication adds a AssociatedMedication element.
func (b *MedicationKnowledgeBuilder) AddAssociatedMedication(v Reference) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.AssociatedMedication = append(b.medicationKnowledge.AssociatedMedication, v)
	return b
}

// AddProductType adds a ProductType element.
func (b *MedicationKnowledgeBuilder) AddProductType(v CodeableConcept) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.ProductType = append(b.medicationKnowledge.ProductType, v)
	return b
}

// AddMonograph adds a Monograph element.
func (b *MedicationKnowledgeBuilder) AddMonograph(v MedicationKnowledgeMonograph) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.Monograph = append(b.medicationKnowledge.Monograph, v)
	return b
}

// SetPreparationInstruction sets the PreparationInstruction field.
func (b *MedicationKnowledgeBuilder) SetPreparationInstruction(v string) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.PreparationInstruction = &v
	return b
}

// AddCost adds a Cost element.
func (b *MedicationKnowledgeBuilder) AddCost(v MedicationKnowledgeCost) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.Cost = append(b.medicationKnowledge.Cost, v)
	return b
}

// AddMonitoringProgram adds a MonitoringProgram element.
func (b *MedicationKnowledgeBuilder) AddMonitoringProgram(v MedicationKnowledgeMonitoringProgram) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.MonitoringProgram = append(b.medicationKnowledge.MonitoringProgram, v)
	return b
}

// AddIndicationGuideline adds a IndicationGuideline element.
func (b *MedicationKnowledgeBuilder) AddIndicationGuideline(v MedicationKnowledgeIndicationGuideline) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.IndicationGuideline = append(b.medicationKnowledge.IndicationGuideline, v)
	return b
}

// AddMedicineClassification adds a MedicineClassification element.
func (b *MedicationKnowledgeBuilder) AddMedicineClassification(v MedicationKnowledgeMedicineClassification) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.MedicineClassification = append(b.medicationKnowledge.MedicineClassification, v)
	return b
}

// AddPackaging adds a Packaging element.
func (b *MedicationKnowledgeBuilder) AddPackaging(v MedicationKnowledgePackaging) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.Packaging = append(b.medicationKnowledge.Packaging, v)
	return b
}

// AddClinicalUseIssue adds a ClinicalUseIssue element.
func (b *MedicationKnowledgeBuilder) AddClinicalUseIssue(v Reference) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.ClinicalUseIssue = append(b.medicationKnowledge.ClinicalUseIssue, v)
	return b
}

// AddStorageGuideline adds a StorageGuideline element.
func (b *MedicationKnowledgeBuilder) AddStorageGuideline(v MedicationKnowledgeStorageGuideline) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.StorageGuideline = append(b.medicationKnowledge.StorageGuideline, v)
	return b
}

// AddRegulatory adds a Regulatory element.
func (b *MedicationKnowledgeBuilder) AddRegulatory(v MedicationKnowledgeRegulatory) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.Regulatory = append(b.medicationKnowledge.Regulatory, v)
	return b
}

// SetDefinitional sets the Definitional field.
func (b *MedicationKnowledgeBuilder) SetDefinitional(v MedicationKnowledgeDefinitional) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.Definitional = &v
	return b
}

// =============================================================================
// MedicationKnowledge - Functional Options
// =============================================================================

// MedicationKnowledgeOption is a functional option for configuring a MedicationKnowledge.
type MedicationKnowledgeOption func(*MedicationKnowledge)

// NewMedicationKnowledge creates a new MedicationKnowledge with the given options.
func NewMedicationKnowledge(opts ...MedicationKnowledgeOption) *MedicationKnowledge {
	r := &MedicationKnowledge{}
	for _, opt := range opts {
		opt(r)
	}
	return r
}

// WithMedicationKnowledgeId sets the Id field.
func WithMedicationKnowledgeId(v string) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.Id = &v
	}
}

// WithMedicationKnowledgeMeta sets the Meta field.
func WithMedicationKnowledgeMeta(v Meta) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.Meta = &v
	}
}

// WithMedicationKnowledgeImplicitRules sets the ImplicitRules field.
func WithMedicationKnowledgeImplicitRules(v string) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.ImplicitRules = &v
	}
}

// WithMedicationKnowledgeLanguage sets the Language field.
func WithMedicationKnowledgeLanguage(v string) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.Language = &v
	}
}

// WithMedicationKnowledgeText sets the Text field.
func WithMedicationKnowledgeText(v Narrative) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.Text = &v
	}
}

// WithMedicationKnowledgeContained adds a Contained to the MedicationKnowledge.
func WithMedicationKnowledgeContained(v Resource) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.Contained = append(r.Contained, v)
	}
}

// WithMedicationKnowledgeExtension adds a Extension to the MedicationKnowledge.
func WithMedicationKnowledgeExtension(v Extension) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.Extension = append(r.Extension, v)
	}
}

// WithMedicationKnowledgeModifierExtension adds a ModifierExtension to the MedicationKnowledge.
func WithMedicationKnowledgeModifierExtension(v Extension) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.ModifierExtension = append(r.ModifierExtension, v)
	}
}

// WithMedicationKnowledgeIdentifier adds a Identifier to the MedicationKnowledge.
func WithMedicationKnowledgeIdentifier(v Identifier) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.Identifier = append(r.Identifier, v)
	}
}

// WithMedicationKnowledgeCode sets the Code field.
func WithMedicationKnowledgeCode(v CodeableConcept) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.Code = &v
	}
}

// WithMedicationKnowledgeStatus sets the Status field.
func WithMedicationKnowledgeStatus(v MedicationKnowledgeStatusCodes) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.Status = &v
	}
}

// WithMedicationKnowledgeAuthor sets the Author field.
func WithMedicationKnowledgeAuthor(v Reference) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.Author = &v
	}
}

// WithMedicationKnowledgeIntendedJurisdiction adds a IntendedJurisdiction to the MedicationKnowledge.
func WithMedicationKnowledgeIntendedJurisdiction(v CodeableConcept) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.IntendedJurisdiction = append(r.IntendedJurisdiction, v)
	}
}

// WithMedicationKnowledgeName adds a Name to the MedicationKnowledge.
func WithMedicationKnowledgeName(v string) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.Name = append(r.Name, v)
	}
}

// WithMedicationKnowledgeRelatedMedicationKnowledge adds a RelatedMedicationKnowledge to the MedicationKnowledge.
func WithMedicationKnowledgeRelatedMedicationKnowledge(v MedicationKnowledgeRelatedMedicationKnowledge) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.RelatedMedicationKnowledge = append(r.RelatedMedicationKnowledge, v)
	}
}

// WithMedicationKnowledgeAssociatedMedication adds a AssociatedMedication to the MedicationKnowledge.
func WithMedicationKnowledgeAssociatedMedication(v Reference) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.AssociatedMedication = append(r.AssociatedMedication, v)
	}
}

// WithMedicationKnowledgeProductType adds a ProductType to the MedicationKnowledge.
func WithMedicationKnowledgeProductType(v CodeableConcept) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.ProductType = append(r.ProductType, v)
	}
}

// WithMedicationKnowledgeMonograph adds a Monograph to the MedicationKnowledge.
func WithMedicationKnowledgeMonograph(v MedicationKnowledgeMonograph) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.Monograph = append(r.Monograph, v)
	}
}

// WithMedicationKnowledgePreparationInstruction sets the PreparationInstruction field.
func WithMedicationKnowledgePreparationInstruction(v string) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.PreparationInstruction = &v
	}
}

// WithMedicationKnowledgeCost adds a Cost to the MedicationKnowledge.
func WithMedicationKnowledgeCost(v MedicationKnowledgeCost) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.Cost = append(r.Cost, v)
	}
}

// WithMedicationKnowledgeMonitoringProgram adds a MonitoringProgram to the MedicationKnowledge.
func WithMedicationKnowledgeMonitoringProgram(v MedicationKnowledgeMonitoringProgram) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.MonitoringProgram = append(r.MonitoringProgram, v)
	}
}

// WithMedicationKnowledgeIndicationGuideline adds a IndicationGuideline to the MedicationKnowledge.
func WithMedicationKnowledgeIndicationGuideline(v MedicationKnowledgeIndicationGuideline) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.IndicationGuideline = append(r.IndicationGuideline, v)
	}
}

// WithMedicationKnowledgeMedicineClassification adds a MedicineClassification to the MedicationKnowledge.
func WithMedicationKnowledgeMedicineClassification(v MedicationKnowledgeMedicineClassification) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.MedicineClassification = append(r.MedicineClassification, v)
	}
}

// WithMedicationKnowledgePackaging adds a Packaging to the MedicationKnowledge.
func WithMedicationKnowledgePackaging(v MedicationKnowledgePackaging) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.Packaging = append(r.Packaging, v)
	}
}

// WithMedicationKnowledgeClinicalUseIssue adds a ClinicalUseIssue to the MedicationKnowledge.
func WithMedicationKnowledgeClinicalUseIssue(v Reference) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.ClinicalUseIssue = append(r.ClinicalUseIssue, v)
	}
}

// WithMedicationKnowledgeStorageGuideline adds a StorageGuideline to the MedicationKnowledge.
func WithMedicationKnowledgeStorageGuideline(v MedicationKnowledgeStorageGuideline) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.StorageGuideline = append(r.StorageGuideline, v)
	}
}

// WithMedicationKnowledgeRegulatory adds a Regulatory to the MedicationKnowledge.
func WithMedicationKnowledgeRegulatory(v MedicationKnowledgeRegulatory) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.Regulatory = append(r.Regulatory, v)
	}
}

// WithMedicationKnowledgeDefinitional sets the Definitional field.
func WithMedicationKnowledgeDefinitional(v MedicationKnowledgeDefinitional) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.Definitional = &v
	}
}
