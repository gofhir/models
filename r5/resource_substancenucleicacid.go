// Code generated by gofhir. DO NOT EDIT.
// Source: FHIR StructureDefinitions (consolidated resource)
// Package: r5

package r5

import (
	"bytes"
	"encoding/json"
	"encoding/xml"
	"fmt"
)

// =============================================================================
// SubstanceNucleicAcid Resource
// =============================================================================

// SubstanceNucleicAcid represents FHIR SubstanceNucleicAcid.
type SubstanceNucleicAcid struct {
	// FHIR resource type
	ResourceType string `json:"resourceType"`
	// Logical id of this artifact
	Id *string `json:"id,omitempty"`
	// Metadata about the resource
	Meta *Meta `json:"meta,omitempty"`
	// A set of rules under which this content was created
	ImplicitRules *string `json:"implicitRules,omitempty"`
	// Extension for ImplicitRules
	ImplicitRulesExt *Element `json:"_implicitRules,omitempty"`
	// Language of the resource content
	Language *string `json:"language,omitempty"`
	// Extension for Language
	LanguageExt *Element `json:"_language,omitempty"`
	// Text summary of the resource, for human interpretation
	Text *Narrative `json:"text,omitempty"`
	// Contained, inline Resources
	Contained []Resource `json:"contained,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The type of the sequence shall be specified based on a controlled vocabulary
	SequenceType *CodeableConcept `json:"sequenceType,omitempty"`
	// The number of linear sequences of nucleotides linked through phosphodiester bonds shall be described. Subunits would be strands of nucleic acids that are tightly associated typically through Watson-Crick base pairing. NOTE: If not specified in the reference source, the assumption is that there is 1 subunit
	NumberOfSubunits *int `json:"numberOfSubunits,omitempty"`
	// Extension for NumberOfSubunits
	NumberOfSubunitsExt *Element `json:"_numberOfSubunits,omitempty"`
	// The area of hybridisation shall be described if applicable for double stranded RNA or DNA. The number associated with the subunit followed by the number associated to the residue shall be specified in increasing order. The underscore “” shall be used as separator as follows: “Subunitnumber Residue”
	AreaOfHybridisation *string `json:"areaOfHybridisation,omitempty"`
	// Extension for AreaOfHybridisation
	AreaOfHybridisationExt *Element `json:"_areaOfHybridisation,omitempty"`
	// (TBC)
	OligoNucleotideType *CodeableConcept `json:"oligoNucleotideType,omitempty"`
	// Subunits are listed in order of decreasing length; sequences of the same length will be ordered by molecular weight; subunits that have identical sequences will be repeated multiple times
	Subunit []SubstanceNucleicAcidSubunit `json:"subunit,omitempty"`
}

// GetResourceType returns the FHIR resource type.
func (r *SubstanceNucleicAcid) GetResourceType() string {
	return "SubstanceNucleicAcid"
}

// GetId returns the resource's logical ID.
func (r *SubstanceNucleicAcid) GetId() *string {
	return r.Id
}

// SetId sets the resource's logical ID.
func (r *SubstanceNucleicAcid) SetId(id string) {
	r.Id = &id
}

// GetMeta returns the resource's Meta element.
func (r *SubstanceNucleicAcid) GetMeta() *Meta {
	return r.Meta
}

// SetMeta sets the resource's Meta element.
func (r *SubstanceNucleicAcid) SetMeta(m *Meta) {
	r.Meta = m
}

// GetText returns the resource's narrative text.
func (r *SubstanceNucleicAcid) GetText() *Narrative {
	return r.Text
}

// SetText sets the resource's narrative text.
func (r *SubstanceNucleicAcid) SetText(t *Narrative) {
	r.Text = t
}

// GetContained returns the resource's contained resources.
func (r *SubstanceNucleicAcid) GetContained() []Resource {
	return r.Contained
}

// GetExtension returns the resource's extensions.
func (r *SubstanceNucleicAcid) GetExtension() []Extension {
	return r.Extension
}

// GetModifierExtension returns the resource's modifier extensions.
func (r *SubstanceNucleicAcid) GetModifierExtension() []Extension {
	return r.ModifierExtension
}

// MarshalJSON ensures resourceType is always included in JSON output.
// HTML escaping is disabled to preserve FHIR narrative XHTML content.
//
// Note: Use the package-level Marshal function instead of json.Marshal
// to ensure HTML in narrative text.div fields is not escaped.
func (r SubstanceNucleicAcid) MarshalJSON() ([]byte, error) {
	r.ResourceType = "SubstanceNucleicAcid"
	type Alias SubstanceNucleicAcid
	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	enc.SetEscapeHTML(false)
	if err := enc.Encode((Alias)(r)); err != nil {
		return nil, err
	}
	b := buf.Bytes()
	if len(b) > 0 && b[len(b)-1] == '\n' {
		b = b[:len(b)-1]
	}
	return b, nil
}

// UnmarshalJSON handles deserialization of polymorphic contained resources.
func (r *SubstanceNucleicAcid) UnmarshalJSON(data []byte) error {
	// Use an alias to avoid infinite recursion
	type Alias SubstanceNucleicAcid
	aux := &struct {
		Contained []json.RawMessage `json:"contained,omitempty"`
		*Alias
	}{
		Alias: (*Alias)(r),
	}

	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}

	// Unmarshal each contained resource using the dispatcher
	if len(aux.Contained) > 0 {
		r.Contained = make([]Resource, len(aux.Contained))
		for i, raw := range aux.Contained {
			resource, err := UnmarshalResource(raw)
			if err != nil {
				return fmt.Errorf("failed to unmarshal contained[%d]: %w", i, err)
			}
			r.Contained[i] = resource
		}
	}

	return nil
}

// MarshalXML serializes SubstanceNucleicAcid to FHIR-conformant XML.
func (r SubstanceNucleicAcid) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "SubstanceNucleicAcid"
		start.Name.Space = fhirNamespace
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	if err := xmlEncodePrimitiveString(e, "id", r.Id, nil); err != nil {
		return err
	}
	if r.Meta != nil {
		if err := r.Meta.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "meta"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "implicitRules", r.ImplicitRules, r.ImplicitRulesExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "language", r.Language, r.LanguageExt); err != nil {
		return err
	}
	if r.Text != nil {
		if err := r.Text.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "text"}}); err != nil {
			return err
		}
	}
	for _, c := range r.Contained {
		if c != nil {
			if err := xmlEncodeContainedResource(e, c); err != nil {
				return err
			}
		}
	}
	for _, item := range r.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range r.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if r.SequenceType != nil {
		if err := r.SequenceType.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "sequenceType"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveInt(e, "numberOfSubunits", r.NumberOfSubunits, r.NumberOfSubunitsExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "areaOfHybridisation", r.AreaOfHybridisation, r.AreaOfHybridisationExt); err != nil {
		return err
	}
	if r.OligoNucleotideType != nil {
		if err := r.OligoNucleotideType.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "oligoNucleotideType"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Subunit {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "subunit"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes SubstanceNucleicAcid from FHIR-conformant XML.
func (r *SubstanceNucleicAcid) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "id":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Id = v
			case "meta":
				var v Meta
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Meta = &v
			case "implicitRules":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ImplicitRules = v
				r.ImplicitRulesExt = ext
			case "language":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Language = v
				r.LanguageExt = ext
			case "text":
				var v Narrative
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Text = &v
			case "contained":
				res, err := xmlDecodeContainedResource(d, t)
				if err != nil {
					return err
				}
				if res != nil {
					r.Contained = append(r.Contained, res)
				}
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "sequenceType":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.SequenceType = &v
			case "numberOfSubunits":
				v, ext, err := xmlDecodePrimitiveInt(d, t)
				if err != nil {
					return err
				}
				r.NumberOfSubunits = v
				r.NumberOfSubunitsExt = ext
			case "areaOfHybridisation":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.AreaOfHybridisation = v
				r.AreaOfHybridisationExt = ext
			case "oligoNucleotideType":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.OligoNucleotideType = &v
			case "subunit":
				var v SubstanceNucleicAcidSubunit
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Subunit = append(r.Subunit, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// SubstanceNucleicAcidSubunit represents the SubstanceNucleicAcid.subunit backbone element.
// Subunits are listed in order of decreasing length; sequences of the same length will be ordered by molecular weight; subunits that have identical sequences will be repeated multiple times
type SubstanceNucleicAcidSubunit struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Index of linear sequences of nucleic acids in order of decreasing length. Sequences of the same length will be ordered by molecular weight. Subunits that have identical sequences will be repeated and have sequential subscripts
	Subunit *int `json:"subunit,omitempty"`
	// Actual nucleotide sequence notation from 5' to 3' end using standard single letter codes. In addition to the base sequence, sugar and type of phosphate or non-phosphate linkage should also be captured
	Sequence *string `json:"sequence,omitempty"`
	// The length of the sequence shall be captured
	Length *int `json:"length,omitempty"`
	// (TBC)
	SequenceAttachment *Attachment `json:"sequenceAttachment,omitempty"`
	// The nucleotide present at the 5’ terminal shall be specified based on a controlled vocabulary. Since the sequence is represented from the 5' to the 3' end, the 5’ prime nucleotide is the letter at the first position in the sequence. A separate representation would be redundant
	FivePrime *CodeableConcept `json:"fivePrime,omitempty"`
	// The nucleotide present at the 3’ terminal shall be specified based on a controlled vocabulary. Since the sequence is represented from the 5' to the 3' end, the 5’ prime nucleotide is the letter at the last position in the sequence. A separate representation would be redundant
	ThreePrime *CodeableConcept `json:"threePrime,omitempty"`
	// The linkages between sugar residues will also be captured
	Linkage []SubstanceNucleicAcidSubunitLinkage `json:"linkage,omitempty"`
	// 5.3.6.8.1 Sugar ID (Mandatory)
	Sugar []SubstanceNucleicAcidSubunitSugar `json:"sugar,omitempty"`
}

// MarshalXML serializes SubstanceNucleicAcidSubunit to FHIR-conformant XML.
func (b SubstanceNucleicAcidSubunit) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "SubstanceNucleicAcid.subunit"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveInt(e, "subunit", b.Subunit, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "sequence", b.Sequence, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveInt(e, "length", b.Length, nil); err != nil {
		return err
	}
	if b.SequenceAttachment != nil {
		if err := b.SequenceAttachment.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "sequenceAttachment"}}); err != nil {
			return err
		}
	}
	if b.FivePrime != nil {
		if err := b.FivePrime.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "fivePrime"}}); err != nil {
			return err
		}
	}
	if b.ThreePrime != nil {
		if err := b.ThreePrime.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "threePrime"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Linkage {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "linkage"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Sugar {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "sugar"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes SubstanceNucleicAcidSubunit from FHIR-conformant XML.
func (r *SubstanceNucleicAcidSubunit) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "subunit":
				v, _, err := xmlDecodePrimitiveInt(d, t)
				if err != nil {
					return err
				}
				r.Subunit = v
			case "sequence":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Sequence = v
			case "length":
				v, _, err := xmlDecodePrimitiveInt(d, t)
				if err != nil {
					return err
				}
				r.Length = v
			case "sequenceAttachment":
				var v Attachment
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.SequenceAttachment = &v
			case "fivePrime":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.FivePrime = &v
			case "threePrime":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ThreePrime = &v
			case "linkage":
				var v SubstanceNucleicAcidSubunitLinkage
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Linkage = append(r.Linkage, v)
			case "sugar":
				var v SubstanceNucleicAcidSubunitSugar
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Sugar = append(r.Sugar, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// SubstanceNucleicAcidSubunitLinkage represents the SubstanceNucleicAcid.subunit.linkage backbone element.
// The linkages between sugar residues will also be captured
type SubstanceNucleicAcidSubunitLinkage struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The entity that links the sugar residues together should also be captured for nearly all naturally occurring nucleic acid the linkage is a phosphate group. For many synthetic oligonucleotides phosphorothioate linkages are often seen. Linkage connectivity is assumed to be 3’-5’. If the linkage is either 3’-3’ or 5’-5’ this should be specified
	Connectivity *string `json:"connectivity,omitempty"`
	// Each linkage will be registered as a fragment and have an ID
	Identifier *Identifier `json:"identifier,omitempty"`
	// Each linkage will be registered as a fragment and have at least one name. A single name shall be assigned to each linkage
	Name *string `json:"name,omitempty"`
	// Residues shall be captured as described in 5.3.6.8.3
	ResidueSite *string `json:"residueSite,omitempty"`
}

// MarshalXML serializes SubstanceNucleicAcidSubunitLinkage to FHIR-conformant XML.
func (b SubstanceNucleicAcidSubunitLinkage) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "SubstanceNucleicAcid.subunit.linkage"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "connectivity", b.Connectivity, nil); err != nil {
		return err
	}
	if b.Identifier != nil {
		if err := b.Identifier.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "identifier"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "name", b.Name, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "residueSite", b.ResidueSite, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes SubstanceNucleicAcidSubunitLinkage from FHIR-conformant XML.
func (r *SubstanceNucleicAcidSubunitLinkage) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "connectivity":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Connectivity = v
			case "identifier":
				var v Identifier
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Identifier = &v
			case "name":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Name = v
			case "residueSite":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ResidueSite = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// SubstanceNucleicAcidSubunitSugar represents the SubstanceNucleicAcid.subunit.sugar backbone element.
// 5.3.6.8.1 Sugar ID (Mandatory)
type SubstanceNucleicAcidSubunitSugar struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The Substance ID of the sugar or sugar-like component that make up the nucleotide
	Identifier *Identifier `json:"identifier,omitempty"`
	// The name of the sugar or sugar-like component that make up the nucleotide
	Name *string `json:"name,omitempty"`
	// The residues that contain a given sugar will be captured. The order of given residues will be captured in the 5‘-3‘direction consistent with the base sequences listed above
	ResidueSite *string `json:"residueSite,omitempty"`
}

// MarshalXML serializes SubstanceNucleicAcidSubunitSugar to FHIR-conformant XML.
func (b SubstanceNucleicAcidSubunitSugar) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "SubstanceNucleicAcid.subunit.sugar"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.Identifier != nil {
		if err := b.Identifier.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "identifier"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "name", b.Name, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "residueSite", b.ResidueSite, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes SubstanceNucleicAcidSubunitSugar from FHIR-conformant XML.
func (r *SubstanceNucleicAcidSubunitSugar) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "identifier":
				var v Identifier
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Identifier = &v
			case "name":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Name = v
			case "residueSite":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ResidueSite = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// =============================================================================
// SubstanceNucleicAcid - Fluent Builder
// =============================================================================

// SubstanceNucleicAcidBuilder provides a fluent API for constructing SubstanceNucleicAcid resources.
type SubstanceNucleicAcidBuilder struct {
	substanceNucleicAcid *SubstanceNucleicAcid
}

// NewSubstanceNucleicAcidBuilder creates a new SubstanceNucleicAcidBuilder.
func NewSubstanceNucleicAcidBuilder() *SubstanceNucleicAcidBuilder {
	return &SubstanceNucleicAcidBuilder{
		substanceNucleicAcid: &SubstanceNucleicAcid{},
	}
}

// Build returns the constructed SubstanceNucleicAcid resource.
func (b *SubstanceNucleicAcidBuilder) Build() *SubstanceNucleicAcid {
	return b.substanceNucleicAcid
}

// SetId sets the Id field.
func (b *SubstanceNucleicAcidBuilder) SetId(v string) *SubstanceNucleicAcidBuilder {
	b.substanceNucleicAcid.Id = &v
	return b
}

// SetMeta sets the Meta field.
func (b *SubstanceNucleicAcidBuilder) SetMeta(v Meta) *SubstanceNucleicAcidBuilder {
	b.substanceNucleicAcid.Meta = &v
	return b
}

// SetImplicitRules sets the ImplicitRules field.
func (b *SubstanceNucleicAcidBuilder) SetImplicitRules(v string) *SubstanceNucleicAcidBuilder {
	b.substanceNucleicAcid.ImplicitRules = &v
	return b
}

// SetLanguage sets the Language field.
func (b *SubstanceNucleicAcidBuilder) SetLanguage(v string) *SubstanceNucleicAcidBuilder {
	b.substanceNucleicAcid.Language = &v
	return b
}

// SetText sets the Text field.
func (b *SubstanceNucleicAcidBuilder) SetText(v Narrative) *SubstanceNucleicAcidBuilder {
	b.substanceNucleicAcid.Text = &v
	return b
}

// AddContained adds a Contained element.
func (b *SubstanceNucleicAcidBuilder) AddContained(v Resource) *SubstanceNucleicAcidBuilder {
	b.substanceNucleicAcid.Contained = append(b.substanceNucleicAcid.Contained, v)
	return b
}

// AddExtension adds a Extension element.
func (b *SubstanceNucleicAcidBuilder) AddExtension(v Extension) *SubstanceNucleicAcidBuilder {
	b.substanceNucleicAcid.Extension = append(b.substanceNucleicAcid.Extension, v)
	return b
}

// AddModifierExtension adds a ModifierExtension element.
func (b *SubstanceNucleicAcidBuilder) AddModifierExtension(v Extension) *SubstanceNucleicAcidBuilder {
	b.substanceNucleicAcid.ModifierExtension = append(b.substanceNucleicAcid.ModifierExtension, v)
	return b
}

// SetSequenceType sets the SequenceType field.
func (b *SubstanceNucleicAcidBuilder) SetSequenceType(v CodeableConcept) *SubstanceNucleicAcidBuilder {
	b.substanceNucleicAcid.SequenceType = &v
	return b
}

// SetNumberOfSubunits sets the NumberOfSubunits field.
func (b *SubstanceNucleicAcidBuilder) SetNumberOfSubunits(v int) *SubstanceNucleicAcidBuilder {
	b.substanceNucleicAcid.NumberOfSubunits = &v
	return b
}

// SetAreaOfHybridisation sets the AreaOfHybridisation field.
func (b *SubstanceNucleicAcidBuilder) SetAreaOfHybridisation(v string) *SubstanceNucleicAcidBuilder {
	b.substanceNucleicAcid.AreaOfHybridisation = &v
	return b
}

// SetOligoNucleotideType sets the OligoNucleotideType field.
func (b *SubstanceNucleicAcidBuilder) SetOligoNucleotideType(v CodeableConcept) *SubstanceNucleicAcidBuilder {
	b.substanceNucleicAcid.OligoNucleotideType = &v
	return b
}

// AddSubunit adds a Subunit element.
func (b *SubstanceNucleicAcidBuilder) AddSubunit(v SubstanceNucleicAcidSubunit) *SubstanceNucleicAcidBuilder {
	b.substanceNucleicAcid.Subunit = append(b.substanceNucleicAcid.Subunit, v)
	return b
}

// =============================================================================
// SubstanceNucleicAcid - Functional Options
// =============================================================================

// SubstanceNucleicAcidOption is a functional option for configuring a SubstanceNucleicAcid.
type SubstanceNucleicAcidOption func(*SubstanceNucleicAcid)

// NewSubstanceNucleicAcid creates a new SubstanceNucleicAcid with the given options.
func NewSubstanceNucleicAcid(opts ...SubstanceNucleicAcidOption) *SubstanceNucleicAcid {
	r := &SubstanceNucleicAcid{}
	for _, opt := range opts {
		opt(r)
	}
	return r
}

// WithSubstanceNucleicAcidId sets the Id field.
func WithSubstanceNucleicAcidId(v string) SubstanceNucleicAcidOption {
	return func(r *SubstanceNucleicAcid) {
		r.Id = &v
	}
}

// WithSubstanceNucleicAcidMeta sets the Meta field.
func WithSubstanceNucleicAcidMeta(v Meta) SubstanceNucleicAcidOption {
	return func(r *SubstanceNucleicAcid) {
		r.Meta = &v
	}
}

// WithSubstanceNucleicAcidImplicitRules sets the ImplicitRules field.
func WithSubstanceNucleicAcidImplicitRules(v string) SubstanceNucleicAcidOption {
	return func(r *SubstanceNucleicAcid) {
		r.ImplicitRules = &v
	}
}

// WithSubstanceNucleicAcidLanguage sets the Language field.
func WithSubstanceNucleicAcidLanguage(v string) SubstanceNucleicAcidOption {
	return func(r *SubstanceNucleicAcid) {
		r.Language = &v
	}
}

// WithSubstanceNucleicAcidText sets the Text field.
func WithSubstanceNucleicAcidText(v Narrative) SubstanceNucleicAcidOption {
	return func(r *SubstanceNucleicAcid) {
		r.Text = &v
	}
}

// WithSubstanceNucleicAcidContained adds a Contained to the SubstanceNucleicAcid.
func WithSubstanceNucleicAcidContained(v Resource) SubstanceNucleicAcidOption {
	return func(r *SubstanceNucleicAcid) {
		r.Contained = append(r.Contained, v)
	}
}

// WithSubstanceNucleicAcidExtension adds a Extension to the SubstanceNucleicAcid.
func WithSubstanceNucleicAcidExtension(v Extension) SubstanceNucleicAcidOption {
	return func(r *SubstanceNucleicAcid) {
		r.Extension = append(r.Extension, v)
	}
}

// WithSubstanceNucleicAcidModifierExtension adds a ModifierExtension to the SubstanceNucleicAcid.
func WithSubstanceNucleicAcidModifierExtension(v Extension) SubstanceNucleicAcidOption {
	return func(r *SubstanceNucleicAcid) {
		r.ModifierExtension = append(r.ModifierExtension, v)
	}
}

// WithSubstanceNucleicAcidSequenceType sets the SequenceType field.
func WithSubstanceNucleicAcidSequenceType(v CodeableConcept) SubstanceNucleicAcidOption {
	return func(r *SubstanceNucleicAcid) {
		r.SequenceType = &v
	}
}

// WithSubstanceNucleicAcidNumberOfSubunits sets the NumberOfSubunits field.
func WithSubstanceNucleicAcidNumberOfSubunits(v int) SubstanceNucleicAcidOption {
	return func(r *SubstanceNucleicAcid) {
		r.NumberOfSubunits = &v
	}
}

// WithSubstanceNucleicAcidAreaOfHybridisation sets the AreaOfHybridisation field.
func WithSubstanceNucleicAcidAreaOfHybridisation(v string) SubstanceNucleicAcidOption {
	return func(r *SubstanceNucleicAcid) {
		r.AreaOfHybridisation = &v
	}
}

// WithSubstanceNucleicAcidOligoNucleotideType sets the OligoNucleotideType field.
func WithSubstanceNucleicAcidOligoNucleotideType(v CodeableConcept) SubstanceNucleicAcidOption {
	return func(r *SubstanceNucleicAcid) {
		r.OligoNucleotideType = &v
	}
}

// WithSubstanceNucleicAcidSubunit adds a Subunit to the SubstanceNucleicAcid.
func WithSubstanceNucleicAcidSubunit(v SubstanceNucleicAcidSubunit) SubstanceNucleicAcidOption {
	return func(r *SubstanceNucleicAcid) {
		r.Subunit = append(r.Subunit, v)
	}
}
