// Code generated by gofhir. DO NOT EDIT.
// Source: FHIR StructureDefinitions (consolidated resource)
// Package: r5

package r5

import (
	"bytes"
	"encoding/json"
	"encoding/xml"
	"fmt"
)

// =============================================================================
// SubstanceDefinition Resource
// =============================================================================

// SubstanceDefinition represents FHIR SubstanceDefinition.
type SubstanceDefinition struct {
	// FHIR resource type
	ResourceType string `json:"resourceType"`
	// Logical id of this artifact
	Id *string `json:"id,omitempty"`
	// Metadata about the resource
	Meta *Meta `json:"meta,omitempty"`
	// A set of rules under which this content was created
	ImplicitRules *string `json:"implicitRules,omitempty"`
	// Extension for ImplicitRules
	ImplicitRulesExt *Element `json:"_implicitRules,omitempty"`
	// Language of the resource content
	Language *string `json:"language,omitempty"`
	// Extension for Language
	LanguageExt *Element `json:"_language,omitempty"`
	// Text summary of the resource, for human interpretation
	Text *Narrative `json:"text,omitempty"`
	// Contained, inline Resources
	Contained []Resource `json:"contained,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Identifier by which this substance is known
	Identifier []Identifier `json:"identifier,omitempty"`
	// A business level version identifier of the substance
	Version *string `json:"version,omitempty"`
	// Extension for Version
	VersionExt *Element `json:"_version,omitempty"`
	// Status of substance within the catalogue e.g. active, retired
	Status *CodeableConcept `json:"status,omitempty"`
	// A categorization, high level e.g. polymer or nucleic acid, or food, chemical, biological, or lower e.g. polymer linear or branch chain, or type of impurity
	Classification []CodeableConcept `json:"classification,omitempty"`
	// If the substance applies to human or veterinary use
	Domain *CodeableConcept `json:"domain,omitempty"`
	// The quality standard, established benchmark, to which substance complies (e.g. USP/NF, BP)
	Grade []CodeableConcept `json:"grade,omitempty"`
	// Textual description of the substance
	Description *string `json:"description,omitempty"`
	// Extension for Description
	DescriptionExt *Element `json:"_description,omitempty"`
	// Supporting literature
	InformationSource []Reference `json:"informationSource,omitempty"`
	// Textual comment about the substance's catalogue or registry record
	Note []Annotation `json:"note,omitempty"`
	// The entity that creates, makes, produces or fabricates the substance
	Manufacturer []Reference `json:"manufacturer,omitempty"`
	// An entity that is the source for the substance. It may be different from the manufacturer
	Supplier []Reference `json:"supplier,omitempty"`
	// Moiety, for structural modifications
	Moiety []SubstanceDefinitionMoiety `json:"moiety,omitempty"`
	// General specifications for this substance
	Characterization []SubstanceDefinitionCharacterization `json:"characterization,omitempty"`
	// General specifications for this substance
	Property []SubstanceDefinitionProperty `json:"property,omitempty"`
	// General information detailing this substance
	ReferenceInformation *Reference `json:"referenceInformation,omitempty"`
	// The average mass of a molecule of a compound
	MolecularWeight []SubstanceDefinitionMolecularWeight `json:"molecularWeight,omitempty"`
	// Structural information
	Structure *SubstanceDefinitionStructure `json:"structure,omitempty"`
	// Codes associated with the substance
	Code []SubstanceDefinitionCode `json:"code,omitempty"`
	// Names applicable to this substance
	Name []SubstanceDefinitionName `json:"name,omitempty"`
	// A link between this substance and another
	Relationship []SubstanceDefinitionRelationship `json:"relationship,omitempty"`
	// Data items specific to nucleic acids
	NucleicAcid *Reference `json:"nucleicAcid,omitempty"`
	// Data items specific to polymers
	Polymer *Reference `json:"polymer,omitempty"`
	// Data items specific to proteins
	Protein *Reference `json:"protein,omitempty"`
	// Material or taxonomic/anatomical source
	SourceMaterial *SubstanceDefinitionSourceMaterial `json:"sourceMaterial,omitempty"`
}

// GetResourceType returns the FHIR resource type.
func (r *SubstanceDefinition) GetResourceType() string {
	return "SubstanceDefinition"
}

// GetId returns the resource's logical ID.
func (r *SubstanceDefinition) GetId() *string {
	return r.Id
}

// SetId sets the resource's logical ID.
func (r *SubstanceDefinition) SetId(id string) {
	r.Id = &id
}

// GetMeta returns the resource's Meta element.
func (r *SubstanceDefinition) GetMeta() *Meta {
	return r.Meta
}

// SetMeta sets the resource's Meta element.
func (r *SubstanceDefinition) SetMeta(m *Meta) {
	r.Meta = m
}

// GetText returns the resource's narrative text.
func (r *SubstanceDefinition) GetText() *Narrative {
	return r.Text
}

// SetText sets the resource's narrative text.
func (r *SubstanceDefinition) SetText(t *Narrative) {
	r.Text = t
}

// GetContained returns the resource's contained resources.
func (r *SubstanceDefinition) GetContained() []Resource {
	return r.Contained
}

// GetExtension returns the resource's extensions.
func (r *SubstanceDefinition) GetExtension() []Extension {
	return r.Extension
}

// GetModifierExtension returns the resource's modifier extensions.
func (r *SubstanceDefinition) GetModifierExtension() []Extension {
	return r.ModifierExtension
}

// MarshalJSON ensures resourceType is always included in JSON output.
// HTML escaping is disabled to preserve FHIR narrative XHTML content.
//
// Note: Use the package-level Marshal function instead of json.Marshal
// to ensure HTML in narrative text.div fields is not escaped.
func (r SubstanceDefinition) MarshalJSON() ([]byte, error) {
	r.ResourceType = "SubstanceDefinition"
	type Alias SubstanceDefinition
	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	enc.SetEscapeHTML(false)
	if err := enc.Encode((Alias)(r)); err != nil {
		return nil, err
	}
	b := buf.Bytes()
	if len(b) > 0 && b[len(b)-1] == '\n' {
		b = b[:len(b)-1]
	}
	return b, nil
}

// UnmarshalJSON handles deserialization of polymorphic contained resources.
func (r *SubstanceDefinition) UnmarshalJSON(data []byte) error {
	// Use an alias to avoid infinite recursion
	type Alias SubstanceDefinition
	aux := &struct {
		Contained []json.RawMessage `json:"contained,omitempty"`
		*Alias
	}{
		Alias: (*Alias)(r),
	}

	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}

	// Unmarshal each contained resource using the dispatcher
	if len(aux.Contained) > 0 {
		r.Contained = make([]Resource, len(aux.Contained))
		for i, raw := range aux.Contained {
			resource, err := UnmarshalResource(raw)
			if err != nil {
				return fmt.Errorf("failed to unmarshal contained[%d]: %w", i, err)
			}
			r.Contained[i] = resource
		}
	}

	return nil
}

// MarshalXML serializes SubstanceDefinition to FHIR-conformant XML.
func (r SubstanceDefinition) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "SubstanceDefinition"
		start.Name.Space = fhirNamespace
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	if err := xmlEncodePrimitiveString(e, "id", r.Id, nil); err != nil {
		return err
	}
	if r.Meta != nil {
		if err := r.Meta.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "meta"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "implicitRules", r.ImplicitRules, r.ImplicitRulesExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "language", r.Language, r.LanguageExt); err != nil {
		return err
	}
	if r.Text != nil {
		if err := r.Text.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "text"}}); err != nil {
			return err
		}
	}
	for _, c := range r.Contained {
		if c != nil {
			if err := xmlEncodeContainedResource(e, c); err != nil {
				return err
			}
		}
	}
	for _, item := range r.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range r.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Identifier {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "identifier"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "version", r.Version, r.VersionExt); err != nil {
		return err
	}
	if r.Status != nil {
		if err := r.Status.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "status"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Classification {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "classification"}}); err != nil {
			return err
		}
	}
	if r.Domain != nil {
		if err := r.Domain.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "domain"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Grade {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "grade"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "description", r.Description, r.DescriptionExt); err != nil {
		return err
	}
	for _, item := range r.InformationSource {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "informationSource"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Note {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "note"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Manufacturer {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "manufacturer"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Supplier {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "supplier"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Moiety {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "moiety"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Characterization {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "characterization"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Property {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "property"}}); err != nil {
			return err
		}
	}
	if r.ReferenceInformation != nil {
		if err := r.ReferenceInformation.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "referenceInformation"}}); err != nil {
			return err
		}
	}
	for _, item := range r.MolecularWeight {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "molecularWeight"}}); err != nil {
			return err
		}
	}
	if r.Structure != nil {
		if err := r.Structure.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "structure"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Code {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "code"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Name {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "name"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Relationship {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "relationship"}}); err != nil {
			return err
		}
	}
	if r.NucleicAcid != nil {
		if err := r.NucleicAcid.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "nucleicAcid"}}); err != nil {
			return err
		}
	}
	if r.Polymer != nil {
		if err := r.Polymer.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "polymer"}}); err != nil {
			return err
		}
	}
	if r.Protein != nil {
		if err := r.Protein.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "protein"}}); err != nil {
			return err
		}
	}
	if r.SourceMaterial != nil {
		if err := r.SourceMaterial.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "sourceMaterial"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes SubstanceDefinition from FHIR-conformant XML.
func (r *SubstanceDefinition) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "id":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Id = v
			case "meta":
				var v Meta
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Meta = &v
			case "implicitRules":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ImplicitRules = v
				r.ImplicitRulesExt = ext
			case "language":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Language = v
				r.LanguageExt = ext
			case "text":
				var v Narrative
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Text = &v
			case "contained":
				res, err := xmlDecodeContainedResource(d, t)
				if err != nil {
					return err
				}
				if res != nil {
					r.Contained = append(r.Contained, res)
				}
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "identifier":
				var v Identifier
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Identifier = append(r.Identifier, v)
			case "version":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Version = v
				r.VersionExt = ext
			case "status":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Status = &v
			case "classification":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Classification = append(r.Classification, v)
			case "domain":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Domain = &v
			case "grade":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Grade = append(r.Grade, v)
			case "description":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Description = v
				r.DescriptionExt = ext
			case "informationSource":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.InformationSource = append(r.InformationSource, v)
			case "note":
				var v Annotation
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Note = append(r.Note, v)
			case "manufacturer":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Manufacturer = append(r.Manufacturer, v)
			case "supplier":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Supplier = append(r.Supplier, v)
			case "moiety":
				var v SubstanceDefinitionMoiety
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Moiety = append(r.Moiety, v)
			case "characterization":
				var v SubstanceDefinitionCharacterization
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Characterization = append(r.Characterization, v)
			case "property":
				var v SubstanceDefinitionProperty
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Property = append(r.Property, v)
			case "referenceInformation":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ReferenceInformation = &v
			case "molecularWeight":
				var v SubstanceDefinitionMolecularWeight
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.MolecularWeight = append(r.MolecularWeight, v)
			case "structure":
				var v SubstanceDefinitionStructure
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Structure = &v
			case "code":
				var v SubstanceDefinitionCode
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Code = append(r.Code, v)
			case "name":
				var v SubstanceDefinitionName
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Name = append(r.Name, v)
			case "relationship":
				var v SubstanceDefinitionRelationship
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Relationship = append(r.Relationship, v)
			case "nucleicAcid":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.NucleicAcid = &v
			case "polymer":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Polymer = &v
			case "protein":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Protein = &v
			case "sourceMaterial":
				var v SubstanceDefinitionSourceMaterial
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.SourceMaterial = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// SubstanceDefinitionCharacterization represents the SubstanceDefinition.characterization backbone element.
// General specifications for this substance
type SubstanceDefinitionCharacterization struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The method used to find the characterization e.g. HPLC
	Technique *CodeableConcept `json:"technique,omitempty"`
	// Describes the nature of the chemical entity and explains, for instance, whether this is a base or a salt form
	Form *CodeableConcept `json:"form,omitempty"`
	// The description or justification in support of the interpretation of the data file
	Description *string `json:"description,omitempty"`
	// The data produced by the analytical instrument or a pictorial representation of that data. Examples: a JCAMP, JDX, or ADX file, or a chromatogram or spectrum analysis
	File []Attachment `json:"file,omitempty"`
}

// MarshalXML serializes SubstanceDefinitionCharacterization to FHIR-conformant XML.
func (b SubstanceDefinitionCharacterization) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "SubstanceDefinition.characterization"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.Technique != nil {
		if err := b.Technique.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "technique"}}); err != nil {
			return err
		}
	}
	if b.Form != nil {
		if err := b.Form.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "form"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "description", b.Description, nil); err != nil {
		return err
	}
	for _, item := range b.File {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "file"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes SubstanceDefinitionCharacterization from FHIR-conformant XML.
func (r *SubstanceDefinitionCharacterization) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "technique":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Technique = &v
			case "form":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Form = &v
			case "description":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Description = v
			case "file":
				var v Attachment
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.File = append(r.File, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// SubstanceDefinitionCode represents the SubstanceDefinition.code backbone element.
// Codes associated with the substance
type SubstanceDefinitionCode struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The specific code
	Code *CodeableConcept `json:"code,omitempty"`
	// Status of the code assignment, for example 'provisional', 'approved'
	Status *CodeableConcept `json:"status,omitempty"`
	// The date at which the code status was changed
	StatusDate *string `json:"statusDate,omitempty"`
	// Any comment can be provided in this field
	Note []Annotation `json:"note,omitempty"`
	// Supporting literature
	Source []Reference `json:"source,omitempty"`
}

// MarshalXML serializes SubstanceDefinitionCode to FHIR-conformant XML.
func (b SubstanceDefinitionCode) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "SubstanceDefinition.code"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.Code != nil {
		if err := b.Code.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "code"}}); err != nil {
			return err
		}
	}
	if b.Status != nil {
		if err := b.Status.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "status"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "statusDate", b.StatusDate, nil); err != nil {
		return err
	}
	for _, item := range b.Note {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "note"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Source {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "source"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes SubstanceDefinitionCode from FHIR-conformant XML.
func (r *SubstanceDefinitionCode) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "code":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Code = &v
			case "status":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Status = &v
			case "statusDate":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.StatusDate = v
			case "note":
				var v Annotation
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Note = append(r.Note, v)
			case "source":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Source = append(r.Source, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// SubstanceDefinitionMoiety represents the SubstanceDefinition.moiety backbone element.
// Moiety, for structural modifications
type SubstanceDefinitionMoiety struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Role that the moiety is playing
	Role *CodeableConcept `json:"role,omitempty"`
	// Identifier by which this moiety substance is known
	Identifier *Identifier `json:"identifier,omitempty"`
	// Textual name for this moiety substance
	Name *string `json:"name,omitempty"`
	// Stereochemistry type
	Stereochemistry *CodeableConcept `json:"stereochemistry,omitempty"`
	// Optical activity type
	OpticalActivity *CodeableConcept `json:"opticalActivity,omitempty"`
	// Molecular formula for this moiety (e.g. with the Hill system)
	MolecularFormula *string `json:"molecularFormula,omitempty"`
	// Quantitative value for this moiety
	AmountQuantity *Quantity `json:"amountQuantity,omitempty"`
	// Quantitative value for this moiety
	AmountString *string `json:"amountString,omitempty"`
	// Extension for AmountString
	AmountStringExt *Element `json:"_amountString,omitempty"`
	// The measurement type of the quantitative value
	MeasurementType *CodeableConcept `json:"measurementType,omitempty"`
}

// MarshalXML serializes SubstanceDefinitionMoiety to FHIR-conformant XML.
func (b SubstanceDefinitionMoiety) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "SubstanceDefinition.moiety"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.Role != nil {
		if err := b.Role.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "role"}}); err != nil {
			return err
		}
	}
	if b.Identifier != nil {
		if err := b.Identifier.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "identifier"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "name", b.Name, nil); err != nil {
		return err
	}
	if b.Stereochemistry != nil {
		if err := b.Stereochemistry.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "stereochemistry"}}); err != nil {
			return err
		}
	}
	if b.OpticalActivity != nil {
		if err := b.OpticalActivity.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "opticalActivity"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "molecularFormula", b.MolecularFormula, nil); err != nil {
		return err
	}
	if b.AmountQuantity != nil {
		if err := b.AmountQuantity.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "amountQuantity"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "amountString", b.AmountString, nil); err != nil {
		return err
	}
	if b.MeasurementType != nil {
		if err := b.MeasurementType.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "measurementType"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes SubstanceDefinitionMoiety from FHIR-conformant XML.
func (r *SubstanceDefinitionMoiety) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "role":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Role = &v
			case "identifier":
				var v Identifier
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Identifier = &v
			case "name":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Name = v
			case "stereochemistry":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Stereochemistry = &v
			case "opticalActivity":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.OpticalActivity = &v
			case "molecularFormula":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.MolecularFormula = v
			case "amountQuantity":
				var v Quantity
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.AmountQuantity = &v
			case "amountString":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.AmountString = v
			case "measurementType":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.MeasurementType = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// SubstanceDefinitionMolecularWeight represents the SubstanceDefinition.molecularWeight backbone element.
// The average mass of a molecule of a compound
type SubstanceDefinitionMolecularWeight struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The method by which the weight was determined
	Method *CodeableConcept `json:"method,omitempty"`
	// Type of molecular weight e.g. exact, average, weight average
	Type *CodeableConcept `json:"type,omitempty"`
	// Used to capture quantitative values for a variety of elements
	Amount Quantity `json:"amount,omitempty"`
}

// MarshalXML serializes SubstanceDefinitionMolecularWeight to FHIR-conformant XML.
func (b SubstanceDefinitionMolecularWeight) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "SubstanceDefinition.molecularWeight"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.Method != nil {
		if err := b.Method.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "method"}}); err != nil {
			return err
		}
	}
	if b.Type != nil {
		if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
			return err
		}
	}
	if err := b.Amount.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "amount"}}); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes SubstanceDefinitionMolecularWeight from FHIR-conformant XML.
func (r *SubstanceDefinitionMolecularWeight) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "method":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Method = &v
			case "type":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Type = &v
			case "amount":
				if err := r.Amount.UnmarshalXML(d, t); err != nil {
					return err
				}
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// SubstanceDefinitionName represents the SubstanceDefinition.name backbone element.
// Names applicable to this substance
type SubstanceDefinitionName struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The actual name
	Name *string `json:"name,omitempty"`
	// Name type e.g. 'systematic',  'scientific, 'brand'
	Type *CodeableConcept `json:"type,omitempty"`
	// The status of the name e.g. 'current', 'proposed'
	Status *CodeableConcept `json:"status,omitempty"`
	// If this is the preferred name for this substance
	Preferred *bool `json:"preferred,omitempty"`
	// Human language that the name is written in
	Language []CodeableConcept `json:"language,omitempty"`
	// The use context of this name e.g. as an active ingredient or as a food colour additive
	Domain []CodeableConcept `json:"domain,omitempty"`
	// The jurisdiction where this name applies
	Jurisdiction []CodeableConcept `json:"jurisdiction,omitempty"`
	// A synonym of this particular name, by which the substance is also known
	Synonym []SubstanceDefinitionName `json:"synonym,omitempty"`
	// A translation for this name into another human language
	Translation []SubstanceDefinitionName `json:"translation,omitempty"`
	// Details of the official nature of this name
	Official []SubstanceDefinitionNameOfficial `json:"official,omitempty"`
	// Supporting literature
	Source []Reference `json:"source,omitempty"`
}

// MarshalXML serializes SubstanceDefinitionName to FHIR-conformant XML.
func (b SubstanceDefinitionName) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "SubstanceDefinition.name"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "name", b.Name, nil); err != nil {
		return err
	}
	if b.Type != nil {
		if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
			return err
		}
	}
	if b.Status != nil {
		if err := b.Status.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "status"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveBool(e, "preferred", b.Preferred, nil); err != nil {
		return err
	}
	for _, item := range b.Language {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "language"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Domain {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "domain"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Jurisdiction {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "jurisdiction"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Synonym {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "synonym"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Translation {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "translation"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Official {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "official"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Source {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "source"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes SubstanceDefinitionName from FHIR-conformant XML.
func (r *SubstanceDefinitionName) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "name":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Name = v
			case "type":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Type = &v
			case "status":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Status = &v
			case "preferred":
				v, _, err := xmlDecodePrimitiveBool(d, t)
				if err != nil {
					return err
				}
				r.Preferred = v
			case "language":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Language = append(r.Language, v)
			case "domain":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Domain = append(r.Domain, v)
			case "jurisdiction":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Jurisdiction = append(r.Jurisdiction, v)
			case "synonym":
				var v SubstanceDefinitionName
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Synonym = append(r.Synonym, v)
			case "translation":
				var v SubstanceDefinitionName
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Translation = append(r.Translation, v)
			case "official":
				var v SubstanceDefinitionNameOfficial
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Official = append(r.Official, v)
			case "source":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Source = append(r.Source, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// SubstanceDefinitionNameOfficial represents the SubstanceDefinition.name.official backbone element.
// Details of the official nature of this name
type SubstanceDefinitionNameOfficial struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Which authority uses this official name
	Authority *CodeableConcept `json:"authority,omitempty"`
	// The status of the official name, for example 'draft', 'active'
	Status *CodeableConcept `json:"status,omitempty"`
	// Date of official name change
	Date *string `json:"date,omitempty"`
}

// MarshalXML serializes SubstanceDefinitionNameOfficial to FHIR-conformant XML.
func (b SubstanceDefinitionNameOfficial) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "SubstanceDefinition.name.official"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.Authority != nil {
		if err := b.Authority.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "authority"}}); err != nil {
			return err
		}
	}
	if b.Status != nil {
		if err := b.Status.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "status"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "date", b.Date, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes SubstanceDefinitionNameOfficial from FHIR-conformant XML.
func (r *SubstanceDefinitionNameOfficial) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "authority":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Authority = &v
			case "status":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Status = &v
			case "date":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Date = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// SubstanceDefinitionProperty represents the SubstanceDefinition.property backbone element.
// General specifications for this substance
type SubstanceDefinitionProperty struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// A code expressing the type of property
	Type CodeableConcept `json:"type,omitempty"`
	// A value for the property
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`
	// A value for the property
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`
	// A value for the property
	ValueDate *string `json:"valueDate,omitempty"`
	// Extension for ValueDate
	ValueDateExt *Element `json:"_valueDate,omitempty"`
	// A value for the property
	ValueBoolean *bool `json:"valueBoolean,omitempty"`
	// Extension for ValueBoolean
	ValueBooleanExt *Element `json:"_valueBoolean,omitempty"`
	// A value for the property
	ValueAttachment *Attachment `json:"valueAttachment,omitempty"`
}

// MarshalXML serializes SubstanceDefinitionProperty to FHIR-conformant XML.
func (b SubstanceDefinitionProperty) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "SubstanceDefinition.property"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
		return err
	}
	if b.ValueCodeableConcept != nil {
		if err := b.ValueCodeableConcept.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueCodeableConcept"}}); err != nil {
			return err
		}
	}
	if b.ValueQuantity != nil {
		if err := b.ValueQuantity.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueQuantity"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "valueDate", b.ValueDate, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveBool(e, "valueBoolean", b.ValueBoolean, nil); err != nil {
		return err
	}
	if b.ValueAttachment != nil {
		if err := b.ValueAttachment.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueAttachment"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes SubstanceDefinitionProperty from FHIR-conformant XML.
func (r *SubstanceDefinitionProperty) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "type":
				if err := r.Type.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "valueCodeableConcept":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueCodeableConcept = &v
			case "valueQuantity":
				var v Quantity
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueQuantity = &v
			case "valueDate":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ValueDate = v
			case "valueBoolean":
				v, _, err := xmlDecodePrimitiveBool(d, t)
				if err != nil {
					return err
				}
				r.ValueBoolean = v
			case "valueAttachment":
				var v Attachment
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueAttachment = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// SubstanceDefinitionRelationship represents the SubstanceDefinition.relationship backbone element.
// A link between this substance and another
type SubstanceDefinitionRelationship struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// A pointer to another substance, as a resource or a representational code
	SubstanceDefinitionReference *Reference `json:"substanceDefinitionReference,omitempty"`
	// A pointer to another substance, as a resource or a representational code
	SubstanceDefinitionCodeableConcept *CodeableConcept `json:"substanceDefinitionCodeableConcept,omitempty"`
	// For example "salt to parent", "active moiety"
	Type CodeableConcept `json:"type,omitempty"`
	// For example where an enzyme strongly bonds with a particular substance, this is a defining relationship for that enzyme, out of several possible relationships
	IsDefining *bool `json:"isDefining,omitempty"`
	// A numeric factor for the relationship, e.g. that a substance salt has some percentage of active substance in relation to some other
	AmountQuantity *Quantity `json:"amountQuantity,omitempty"`
	// A numeric factor for the relationship, e.g. that a substance salt has some percentage of active substance in relation to some other
	AmountRatio *Ratio `json:"amountRatio,omitempty"`
	// A numeric factor for the relationship, e.g. that a substance salt has some percentage of active substance in relation to some other
	AmountString *string `json:"amountString,omitempty"`
	// Extension for AmountString
	AmountStringExt *Element `json:"_amountString,omitempty"`
	// For use when the numeric has an uncertain range
	RatioHighLimitAmount *Ratio `json:"ratioHighLimitAmount,omitempty"`
	// An operator for the amount, for example "average", "approximately", "less than"
	Comparator *CodeableConcept `json:"comparator,omitempty"`
	// Supporting literature
	Source []Reference `json:"source,omitempty"`
}

// MarshalXML serializes SubstanceDefinitionRelationship to FHIR-conformant XML.
func (b SubstanceDefinitionRelationship) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "SubstanceDefinition.relationship"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.SubstanceDefinitionReference != nil {
		if err := b.SubstanceDefinitionReference.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "substanceDefinitionReference"}}); err != nil {
			return err
		}
	}
	if b.SubstanceDefinitionCodeableConcept != nil {
		if err := b.SubstanceDefinitionCodeableConcept.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "substanceDefinitionCodeableConcept"}}); err != nil {
			return err
		}
	}
	if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveBool(e, "isDefining", b.IsDefining, nil); err != nil {
		return err
	}
	if b.AmountQuantity != nil {
		if err := b.AmountQuantity.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "amountQuantity"}}); err != nil {
			return err
		}
	}
	if b.AmountRatio != nil {
		if err := b.AmountRatio.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "amountRatio"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "amountString", b.AmountString, nil); err != nil {
		return err
	}
	if b.RatioHighLimitAmount != nil {
		if err := b.RatioHighLimitAmount.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "ratioHighLimitAmount"}}); err != nil {
			return err
		}
	}
	if b.Comparator != nil {
		if err := b.Comparator.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "comparator"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Source {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "source"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes SubstanceDefinitionRelationship from FHIR-conformant XML.
func (r *SubstanceDefinitionRelationship) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "substanceDefinitionReference":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.SubstanceDefinitionReference = &v
			case "substanceDefinitionCodeableConcept":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.SubstanceDefinitionCodeableConcept = &v
			case "type":
				if err := r.Type.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "isDefining":
				v, _, err := xmlDecodePrimitiveBool(d, t)
				if err != nil {
					return err
				}
				r.IsDefining = v
			case "amountQuantity":
				var v Quantity
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.AmountQuantity = &v
			case "amountRatio":
				var v Ratio
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.AmountRatio = &v
			case "amountString":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.AmountString = v
			case "ratioHighLimitAmount":
				var v Ratio
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.RatioHighLimitAmount = &v
			case "comparator":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Comparator = &v
			case "source":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Source = append(r.Source, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// SubstanceDefinitionSourceMaterial represents the SubstanceDefinition.sourceMaterial backbone element.
// Material or taxonomic/anatomical source
type SubstanceDefinitionSourceMaterial struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Classification of the origin of the raw material. e.g. cat hair is an Animal source type
	Type *CodeableConcept `json:"type,omitempty"`
	// The genus of an organism e.g. the Latin epithet of the plant/animal scientific name
	Genus *CodeableConcept `json:"genus,omitempty"`
	// The species of an organism e.g. the Latin epithet of the species of the plant/animal
	Species *CodeableConcept `json:"species,omitempty"`
	// An anatomical origin of the source material within an organism
	Part *CodeableConcept `json:"part,omitempty"`
	// The country or countries where the material is harvested
	CountryOfOrigin []CodeableConcept `json:"countryOfOrigin,omitempty"`
}

// MarshalXML serializes SubstanceDefinitionSourceMaterial to FHIR-conformant XML.
func (b SubstanceDefinitionSourceMaterial) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "SubstanceDefinition.sourceMaterial"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.Type != nil {
		if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
			return err
		}
	}
	if b.Genus != nil {
		if err := b.Genus.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "genus"}}); err != nil {
			return err
		}
	}
	if b.Species != nil {
		if err := b.Species.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "species"}}); err != nil {
			return err
		}
	}
	if b.Part != nil {
		if err := b.Part.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "part"}}); err != nil {
			return err
		}
	}
	for _, item := range b.CountryOfOrigin {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "countryOfOrigin"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes SubstanceDefinitionSourceMaterial from FHIR-conformant XML.
func (r *SubstanceDefinitionSourceMaterial) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "type":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Type = &v
			case "genus":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Genus = &v
			case "species":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Species = &v
			case "part":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Part = &v
			case "countryOfOrigin":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.CountryOfOrigin = append(r.CountryOfOrigin, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// SubstanceDefinitionStructure represents the SubstanceDefinition.structure backbone element.
// Structural information
type SubstanceDefinitionStructure struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Stereochemistry type
	Stereochemistry *CodeableConcept `json:"stereochemistry,omitempty"`
	// Optical activity type
	OpticalActivity *CodeableConcept `json:"opticalActivity,omitempty"`
	// An expression which states the number and type of atoms present in a molecule of a substance
	MolecularFormula *string `json:"molecularFormula,omitempty"`
	// Specified per moiety according to the Hill system
	MolecularFormulaByMoiety *string `json:"molecularFormulaByMoiety,omitempty"`
	// The molecular weight or weight range
	MolecularWeight *SubstanceDefinitionMolecularWeight `json:"molecularWeight,omitempty"`
	// The method used to find the structure e.g. X-ray, NMR
	Technique []CodeableConcept `json:"technique,omitempty"`
	// Source of information for the structure
	SourceDocument []Reference `json:"sourceDocument,omitempty"`
	// A depiction of the structure of the substance
	Representation []SubstanceDefinitionStructureRepresentation `json:"representation,omitempty"`
}

// MarshalXML serializes SubstanceDefinitionStructure to FHIR-conformant XML.
func (b SubstanceDefinitionStructure) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "SubstanceDefinition.structure"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.Stereochemistry != nil {
		if err := b.Stereochemistry.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "stereochemistry"}}); err != nil {
			return err
		}
	}
	if b.OpticalActivity != nil {
		if err := b.OpticalActivity.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "opticalActivity"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "molecularFormula", b.MolecularFormula, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "molecularFormulaByMoiety", b.MolecularFormulaByMoiety, nil); err != nil {
		return err
	}
	if b.MolecularWeight != nil {
		if err := b.MolecularWeight.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "molecularWeight"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Technique {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "technique"}}); err != nil {
			return err
		}
	}
	for _, item := range b.SourceDocument {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "sourceDocument"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Representation {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "representation"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes SubstanceDefinitionStructure from FHIR-conformant XML.
func (r *SubstanceDefinitionStructure) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "stereochemistry":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Stereochemistry = &v
			case "opticalActivity":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.OpticalActivity = &v
			case "molecularFormula":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.MolecularFormula = v
			case "molecularFormulaByMoiety":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.MolecularFormulaByMoiety = v
			case "molecularWeight":
				var v SubstanceDefinitionMolecularWeight
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.MolecularWeight = &v
			case "technique":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Technique = append(r.Technique, v)
			case "sourceDocument":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.SourceDocument = append(r.SourceDocument, v)
			case "representation":
				var v SubstanceDefinitionStructureRepresentation
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Representation = append(r.Representation, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// SubstanceDefinitionStructureRepresentation represents the SubstanceDefinition.structure.representation backbone element.
// A depiction of the structure of the substance
type SubstanceDefinitionStructureRepresentation struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The kind of structural representation (e.g. full, partial)
	Type *CodeableConcept `json:"type,omitempty"`
	// The structural representation as a text string in a standard format
	Representation *string `json:"representation,omitempty"`
	// The format of the representation e.g. InChI, SMILES, MOLFILE (note: not the physical file format)
	Format *CodeableConcept `json:"format,omitempty"`
	// An attachment with the structural representation e.g. a structure graphic or AnIML file
	Document *Reference `json:"document,omitempty"`
}

// MarshalXML serializes SubstanceDefinitionStructureRepresentation to FHIR-conformant XML.
func (b SubstanceDefinitionStructureRepresentation) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "SubstanceDefinition.structure.representation"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.Type != nil {
		if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "representation", b.Representation, nil); err != nil {
		return err
	}
	if b.Format != nil {
		if err := b.Format.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "format"}}); err != nil {
			return err
		}
	}
	if b.Document != nil {
		if err := b.Document.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "document"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes SubstanceDefinitionStructureRepresentation from FHIR-conformant XML.
func (r *SubstanceDefinitionStructureRepresentation) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "type":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Type = &v
			case "representation":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Representation = v
			case "format":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Format = &v
			case "document":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Document = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// =============================================================================
// SubstanceDefinition - Fluent Builder
// =============================================================================

// SubstanceDefinitionBuilder provides a fluent API for constructing SubstanceDefinition resources.
type SubstanceDefinitionBuilder struct {
	substanceDefinition *SubstanceDefinition
}

// NewSubstanceDefinitionBuilder creates a new SubstanceDefinitionBuilder.
func NewSubstanceDefinitionBuilder() *SubstanceDefinitionBuilder {
	return &SubstanceDefinitionBuilder{
		substanceDefinition: &SubstanceDefinition{},
	}
}

// Build returns the constructed SubstanceDefinition resource.
func (b *SubstanceDefinitionBuilder) Build() *SubstanceDefinition {
	return b.substanceDefinition
}

// SetId sets the Id field.
func (b *SubstanceDefinitionBuilder) SetId(v string) *SubstanceDefinitionBuilder {
	b.substanceDefinition.Id = &v
	return b
}

// SetMeta sets the Meta field.
func (b *SubstanceDefinitionBuilder) SetMeta(v Meta) *SubstanceDefinitionBuilder {
	b.substanceDefinition.Meta = &v
	return b
}

// SetImplicitRules sets the ImplicitRules field.
func (b *SubstanceDefinitionBuilder) SetImplicitRules(v string) *SubstanceDefinitionBuilder {
	b.substanceDefinition.ImplicitRules = &v
	return b
}

// SetLanguage sets the Language field.
func (b *SubstanceDefinitionBuilder) SetLanguage(v string) *SubstanceDefinitionBuilder {
	b.substanceDefinition.Language = &v
	return b
}

// SetText sets the Text field.
func (b *SubstanceDefinitionBuilder) SetText(v Narrative) *SubstanceDefinitionBuilder {
	b.substanceDefinition.Text = &v
	return b
}

// AddContained adds a Contained element.
func (b *SubstanceDefinitionBuilder) AddContained(v Resource) *SubstanceDefinitionBuilder {
	b.substanceDefinition.Contained = append(b.substanceDefinition.Contained, v)
	return b
}

// AddExtension adds a Extension element.
func (b *SubstanceDefinitionBuilder) AddExtension(v Extension) *SubstanceDefinitionBuilder {
	b.substanceDefinition.Extension = append(b.substanceDefinition.Extension, v)
	return b
}

// AddModifierExtension adds a ModifierExtension element.
func (b *SubstanceDefinitionBuilder) AddModifierExtension(v Extension) *SubstanceDefinitionBuilder {
	b.substanceDefinition.ModifierExtension = append(b.substanceDefinition.ModifierExtension, v)
	return b
}

// AddIdentifier adds a Identifier element.
func (b *SubstanceDefinitionBuilder) AddIdentifier(v Identifier) *SubstanceDefinitionBuilder {
	b.substanceDefinition.Identifier = append(b.substanceDefinition.Identifier, v)
	return b
}

// SetVersion sets the Version field.
func (b *SubstanceDefinitionBuilder) SetVersion(v string) *SubstanceDefinitionBuilder {
	b.substanceDefinition.Version = &v
	return b
}

// SetStatus sets the Status field.
func (b *SubstanceDefinitionBuilder) SetStatus(v CodeableConcept) *SubstanceDefinitionBuilder {
	b.substanceDefinition.Status = &v
	return b
}

// AddClassification adds a Classification element.
func (b *SubstanceDefinitionBuilder) AddClassification(v CodeableConcept) *SubstanceDefinitionBuilder {
	b.substanceDefinition.Classification = append(b.substanceDefinition.Classification, v)
	return b
}

// SetDomain sets the Domain field.
func (b *SubstanceDefinitionBuilder) SetDomain(v CodeableConcept) *SubstanceDefinitionBuilder {
	b.substanceDefinition.Domain = &v
	return b
}

// AddGrade adds a Grade element.
func (b *SubstanceDefinitionBuilder) AddGrade(v CodeableConcept) *SubstanceDefinitionBuilder {
	b.substanceDefinition.Grade = append(b.substanceDefinition.Grade, v)
	return b
}

// SetDescription sets the Description field.
func (b *SubstanceDefinitionBuilder) SetDescription(v string) *SubstanceDefinitionBuilder {
	b.substanceDefinition.Description = &v
	return b
}

// AddInformationSource adds a InformationSource element.
func (b *SubstanceDefinitionBuilder) AddInformationSource(v Reference) *SubstanceDefinitionBuilder {
	b.substanceDefinition.InformationSource = append(b.substanceDefinition.InformationSource, v)
	return b
}

// AddNote adds a Note element.
func (b *SubstanceDefinitionBuilder) AddNote(v Annotation) *SubstanceDefinitionBuilder {
	b.substanceDefinition.Note = append(b.substanceDefinition.Note, v)
	return b
}

// AddManufacturer adds a Manufacturer element.
func (b *SubstanceDefinitionBuilder) AddManufacturer(v Reference) *SubstanceDefinitionBuilder {
	b.substanceDefinition.Manufacturer = append(b.substanceDefinition.Manufacturer, v)
	return b
}

// AddSupplier adds a Supplier element.
func (b *SubstanceDefinitionBuilder) AddSupplier(v Reference) *SubstanceDefinitionBuilder {
	b.substanceDefinition.Supplier = append(b.substanceDefinition.Supplier, v)
	return b
}

// AddMoiety adds a Moiety element.
func (b *SubstanceDefinitionBuilder) AddMoiety(v SubstanceDefinitionMoiety) *SubstanceDefinitionBuilder {
	b.substanceDefinition.Moiety = append(b.substanceDefinition.Moiety, v)
	return b
}

// AddCharacterization adds a Characterization element.
func (b *SubstanceDefinitionBuilder) AddCharacterization(v SubstanceDefinitionCharacterization) *SubstanceDefinitionBuilder {
	b.substanceDefinition.Characterization = append(b.substanceDefinition.Characterization, v)
	return b
}

// AddProperty adds a Property element.
func (b *SubstanceDefinitionBuilder) AddProperty(v SubstanceDefinitionProperty) *SubstanceDefinitionBuilder {
	b.substanceDefinition.Property = append(b.substanceDefinition.Property, v)
	return b
}

// SetReferenceInformation sets the ReferenceInformation field.
func (b *SubstanceDefinitionBuilder) SetReferenceInformation(v Reference) *SubstanceDefinitionBuilder {
	b.substanceDefinition.ReferenceInformation = &v
	return b
}

// AddMolecularWeight adds a MolecularWeight element.
func (b *SubstanceDefinitionBuilder) AddMolecularWeight(v SubstanceDefinitionMolecularWeight) *SubstanceDefinitionBuilder {
	b.substanceDefinition.MolecularWeight = append(b.substanceDefinition.MolecularWeight, v)
	return b
}

// SetStructure sets the Structure field.
func (b *SubstanceDefinitionBuilder) SetStructure(v SubstanceDefinitionStructure) *SubstanceDefinitionBuilder {
	b.substanceDefinition.Structure = &v
	return b
}

// AddCode adds a Code element.
func (b *SubstanceDefinitionBuilder) AddCode(v SubstanceDefinitionCode) *SubstanceDefinitionBuilder {
	b.substanceDefinition.Code = append(b.substanceDefinition.Code, v)
	return b
}

// AddName adds a Name element.
func (b *SubstanceDefinitionBuilder) AddName(v SubstanceDefinitionName) *SubstanceDefinitionBuilder {
	b.substanceDefinition.Name = append(b.substanceDefinition.Name, v)
	return b
}

// AddRelationship adds a Relationship element.
func (b *SubstanceDefinitionBuilder) AddRelationship(v SubstanceDefinitionRelationship) *SubstanceDefinitionBuilder {
	b.substanceDefinition.Relationship = append(b.substanceDefinition.Relationship, v)
	return b
}

// SetNucleicAcid sets the NucleicAcid field.
func (b *SubstanceDefinitionBuilder) SetNucleicAcid(v Reference) *SubstanceDefinitionBuilder {
	b.substanceDefinition.NucleicAcid = &v
	return b
}

// SetPolymer sets the Polymer field.
func (b *SubstanceDefinitionBuilder) SetPolymer(v Reference) *SubstanceDefinitionBuilder {
	b.substanceDefinition.Polymer = &v
	return b
}

// SetProtein sets the Protein field.
func (b *SubstanceDefinitionBuilder) SetProtein(v Reference) *SubstanceDefinitionBuilder {
	b.substanceDefinition.Protein = &v
	return b
}

// SetSourceMaterial sets the SourceMaterial field.
func (b *SubstanceDefinitionBuilder) SetSourceMaterial(v SubstanceDefinitionSourceMaterial) *SubstanceDefinitionBuilder {
	b.substanceDefinition.SourceMaterial = &v
	return b
}

// =============================================================================
// SubstanceDefinition - Functional Options
// =============================================================================

// SubstanceDefinitionOption is a functional option for configuring a SubstanceDefinition.
type SubstanceDefinitionOption func(*SubstanceDefinition)

// NewSubstanceDefinition creates a new SubstanceDefinition with the given options.
func NewSubstanceDefinition(opts ...SubstanceDefinitionOption) *SubstanceDefinition {
	r := &SubstanceDefinition{}
	for _, opt := range opts {
		opt(r)
	}
	return r
}

// WithSubstanceDefinitionId sets the Id field.
func WithSubstanceDefinitionId(v string) SubstanceDefinitionOption {
	return func(r *SubstanceDefinition) {
		r.Id = &v
	}
}

// WithSubstanceDefinitionMeta sets the Meta field.
func WithSubstanceDefinitionMeta(v Meta) SubstanceDefinitionOption {
	return func(r *SubstanceDefinition) {
		r.Meta = &v
	}
}

// WithSubstanceDefinitionImplicitRules sets the ImplicitRules field.
func WithSubstanceDefinitionImplicitRules(v string) SubstanceDefinitionOption {
	return func(r *SubstanceDefinition) {
		r.ImplicitRules = &v
	}
}

// WithSubstanceDefinitionLanguage sets the Language field.
func WithSubstanceDefinitionLanguage(v string) SubstanceDefinitionOption {
	return func(r *SubstanceDefinition) {
		r.Language = &v
	}
}

// WithSubstanceDefinitionText sets the Text field.
func WithSubstanceDefinitionText(v Narrative) SubstanceDefinitionOption {
	return func(r *SubstanceDefinition) {
		r.Text = &v
	}
}

// WithSubstanceDefinitionContained adds a Contained to the SubstanceDefinition.
func WithSubstanceDefinitionContained(v Resource) SubstanceDefinitionOption {
	return func(r *SubstanceDefinition) {
		r.Contained = append(r.Contained, v)
	}
}

// WithSubstanceDefinitionExtension adds a Extension to the SubstanceDefinition.
func WithSubstanceDefinitionExtension(v Extension) SubstanceDefinitionOption {
	return func(r *SubstanceDefinition) {
		r.Extension = append(r.Extension, v)
	}
}

// WithSubstanceDefinitionModifierExtension adds a ModifierExtension to the SubstanceDefinition.
func WithSubstanceDefinitionModifierExtension(v Extension) SubstanceDefinitionOption {
	return func(r *SubstanceDefinition) {
		r.ModifierExtension = append(r.ModifierExtension, v)
	}
}

// WithSubstanceDefinitionIdentifier adds a Identifier to the SubstanceDefinition.
func WithSubstanceDefinitionIdentifier(v Identifier) SubstanceDefinitionOption {
	return func(r *SubstanceDefinition) {
		r.Identifier = append(r.Identifier, v)
	}
}

// WithSubstanceDefinitionVersion sets the Version field.
func WithSubstanceDefinitionVersion(v string) SubstanceDefinitionOption {
	return func(r *SubstanceDefinition) {
		r.Version = &v
	}
}

// WithSubstanceDefinitionStatus sets the Status field.
func WithSubstanceDefinitionStatus(v CodeableConcept) SubstanceDefinitionOption {
	return func(r *SubstanceDefinition) {
		r.Status = &v
	}
}

// WithSubstanceDefinitionClassification adds a Classification to the SubstanceDefinition.
func WithSubstanceDefinitionClassification(v CodeableConcept) SubstanceDefinitionOption {
	return func(r *SubstanceDefinition) {
		r.Classification = append(r.Classification, v)
	}
}

// WithSubstanceDefinitionDomain sets the Domain field.
func WithSubstanceDefinitionDomain(v CodeableConcept) SubstanceDefinitionOption {
	return func(r *SubstanceDefinition) {
		r.Domain = &v
	}
}

// WithSubstanceDefinitionGrade adds a Grade to the SubstanceDefinition.
func WithSubstanceDefinitionGrade(v CodeableConcept) SubstanceDefinitionOption {
	return func(r *SubstanceDefinition) {
		r.Grade = append(r.Grade, v)
	}
}

// WithSubstanceDefinitionDescription sets the Description field.
func WithSubstanceDefinitionDescription(v string) SubstanceDefinitionOption {
	return func(r *SubstanceDefinition) {
		r.Description = &v
	}
}

// WithSubstanceDefinitionInformationSource adds a InformationSource to the SubstanceDefinition.
func WithSubstanceDefinitionInformationSource(v Reference) SubstanceDefinitionOption {
	return func(r *SubstanceDefinition) {
		r.InformationSource = append(r.InformationSource, v)
	}
}

// WithSubstanceDefinitionNote adds a Note to the SubstanceDefinition.
func WithSubstanceDefinitionNote(v Annotation) SubstanceDefinitionOption {
	return func(r *SubstanceDefinition) {
		r.Note = append(r.Note, v)
	}
}

// WithSubstanceDefinitionManufacturer adds a Manufacturer to the SubstanceDefinition.
func WithSubstanceDefinitionManufacturer(v Reference) SubstanceDefinitionOption {
	return func(r *SubstanceDefinition) {
		r.Manufacturer = append(r.Manufacturer, v)
	}
}

// WithSubstanceDefinitionSupplier adds a Supplier to the SubstanceDefinition.
func WithSubstanceDefinitionSupplier(v Reference) SubstanceDefinitionOption {
	return func(r *SubstanceDefinition) {
		r.Supplier = append(r.Supplier, v)
	}
}

// WithSubstanceDefinitionMoiety adds a Moiety to the SubstanceDefinition.
func WithSubstanceDefinitionMoiety(v SubstanceDefinitionMoiety) SubstanceDefinitionOption {
	return func(r *SubstanceDefinition) {
		r.Moiety = append(r.Moiety, v)
	}
}

// WithSubstanceDefinitionCharacterization adds a Characterization to the SubstanceDefinition.
func WithSubstanceDefinitionCharacterization(v SubstanceDefinitionCharacterization) SubstanceDefinitionOption {
	return func(r *SubstanceDefinition) {
		r.Characterization = append(r.Characterization, v)
	}
}

// WithSubstanceDefinitionProperty adds a Property to the SubstanceDefinition.
func WithSubstanceDefinitionProperty(v SubstanceDefinitionProperty) SubstanceDefinitionOption {
	return func(r *SubstanceDefinition) {
		r.Property = append(r.Property, v)
	}
}

// WithSubstanceDefinitionReferenceInformation sets the ReferenceInformation field.
func WithSubstanceDefinitionReferenceInformation(v Reference) SubstanceDefinitionOption {
	return func(r *SubstanceDefinition) {
		r.ReferenceInformation = &v
	}
}

// WithSubstanceDefinitionMolecularWeight adds a MolecularWeight to the SubstanceDefinition.
func WithSubstanceDefinitionMolecularWeight(v SubstanceDefinitionMolecularWeight) SubstanceDefinitionOption {
	return func(r *SubstanceDefinition) {
		r.MolecularWeight = append(r.MolecularWeight, v)
	}
}

// WithSubstanceDefinitionStructure sets the Structure field.
func WithSubstanceDefinitionStructure(v SubstanceDefinitionStructure) SubstanceDefinitionOption {
	return func(r *SubstanceDefinition) {
		r.Structure = &v
	}
}

// WithSubstanceDefinitionCode adds a Code to the SubstanceDefinition.
func WithSubstanceDefinitionCode(v SubstanceDefinitionCode) SubstanceDefinitionOption {
	return func(r *SubstanceDefinition) {
		r.Code = append(r.Code, v)
	}
}

// WithSubstanceDefinitionName adds a Name to the SubstanceDefinition.
func WithSubstanceDefinitionName(v SubstanceDefinitionName) SubstanceDefinitionOption {
	return func(r *SubstanceDefinition) {
		r.Name = append(r.Name, v)
	}
}

// WithSubstanceDefinitionRelationship adds a Relationship to the SubstanceDefinition.
func WithSubstanceDefinitionRelationship(v SubstanceDefinitionRelationship) SubstanceDefinitionOption {
	return func(r *SubstanceDefinition) {
		r.Relationship = append(r.Relationship, v)
	}
}

// WithSubstanceDefinitionNucleicAcid sets the NucleicAcid field.
func WithSubstanceDefinitionNucleicAcid(v Reference) SubstanceDefinitionOption {
	return func(r *SubstanceDefinition) {
		r.NucleicAcid = &v
	}
}

// WithSubstanceDefinitionPolymer sets the Polymer field.
func WithSubstanceDefinitionPolymer(v Reference) SubstanceDefinitionOption {
	return func(r *SubstanceDefinition) {
		r.Polymer = &v
	}
}

// WithSubstanceDefinitionProtein sets the Protein field.
func WithSubstanceDefinitionProtein(v Reference) SubstanceDefinitionOption {
	return func(r *SubstanceDefinition) {
		r.Protein = &v
	}
}

// WithSubstanceDefinitionSourceMaterial sets the SourceMaterial field.
func WithSubstanceDefinitionSourceMaterial(v SubstanceDefinitionSourceMaterial) SubstanceDefinitionOption {
	return func(r *SubstanceDefinition) {
		r.SourceMaterial = &v
	}
}
