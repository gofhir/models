// Code generated by gofhir. DO NOT EDIT.
// Source: FHIR StructureDefinitions (consolidated resource)
// Package: r5

package r5

import (
	"bytes"
	"encoding/json"
	"encoding/xml"
	"fmt"
)

// =============================================================================
// MolecularSequence Resource
// =============================================================================

// MolecularSequence represents FHIR MolecularSequence.
type MolecularSequence struct {
	// FHIR resource type
	ResourceType string `json:"resourceType"`
	// Logical id of this artifact
	Id *string `json:"id,omitempty"`
	// Metadata about the resource
	Meta *Meta `json:"meta,omitempty"`
	// A set of rules under which this content was created
	ImplicitRules *string `json:"implicitRules,omitempty"`
	// Extension for ImplicitRules
	ImplicitRulesExt *Element `json:"_implicitRules,omitempty"`
	// Language of the resource content
	Language *string `json:"language,omitempty"`
	// Extension for Language
	LanguageExt *Element `json:"_language,omitempty"`
	// Text summary of the resource, for human interpretation
	Text *Narrative `json:"text,omitempty"`
	// Contained, inline Resources
	Contained []Resource `json:"contained,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Unique ID for this particular sequence
	Identifier []Identifier `json:"identifier,omitempty"`
	// aa | dna | rna
	Type *SequenceType `json:"type,omitempty"`
	// Extension for Type
	TypeExt *Element `json:"_type,omitempty"`
	// Subject this sequence is associated too
	Subject *Reference `json:"subject,omitempty"`
	// What the molecular sequence is about, when it is not about the subject of record
	Focus []Reference `json:"focus,omitempty"`
	// Specimen used for sequencing
	Specimen *Reference `json:"specimen,omitempty"`
	// The method for sequencing
	Device *Reference `json:"device,omitempty"`
	// Who should be responsible for test result
	Performer *Reference `json:"performer,omitempty"`
	// Sequence that was observed
	Literal *string `json:"literal,omitempty"`
	// Extension for Literal
	LiteralExt *Element `json:"_literal,omitempty"`
	// Embedded file or a link (URL) which contains content to represent the sequence
	Formatted []Attachment `json:"formatted,omitempty"`
	// A sequence defined relative to another sequence
	Relative []MolecularSequenceRelative `json:"relative,omitempty"`
}

// GetResourceType returns the FHIR resource type.
func (r *MolecularSequence) GetResourceType() string {
	return "MolecularSequence"
}

// GetId returns the resource's logical ID.
func (r *MolecularSequence) GetId() *string {
	return r.Id
}

// SetId sets the resource's logical ID.
func (r *MolecularSequence) SetId(id string) {
	r.Id = &id
}

// GetMeta returns the resource's Meta element.
func (r *MolecularSequence) GetMeta() *Meta {
	return r.Meta
}

// SetMeta sets the resource's Meta element.
func (r *MolecularSequence) SetMeta(m *Meta) {
	r.Meta = m
}

// GetText returns the resource's narrative text.
func (r *MolecularSequence) GetText() *Narrative {
	return r.Text
}

// SetText sets the resource's narrative text.
func (r *MolecularSequence) SetText(t *Narrative) {
	r.Text = t
}

// GetContained returns the resource's contained resources.
func (r *MolecularSequence) GetContained() []Resource {
	return r.Contained
}

// GetExtension returns the resource's extensions.
func (r *MolecularSequence) GetExtension() []Extension {
	return r.Extension
}

// GetModifierExtension returns the resource's modifier extensions.
func (r *MolecularSequence) GetModifierExtension() []Extension {
	return r.ModifierExtension
}

// MarshalJSON ensures resourceType is always included in JSON output.
// HTML escaping is disabled to preserve FHIR narrative XHTML content.
//
// Note: Use the package-level Marshal function instead of json.Marshal
// to ensure HTML in narrative text.div fields is not escaped.
func (r MolecularSequence) MarshalJSON() ([]byte, error) {
	r.ResourceType = "MolecularSequence"
	type Alias MolecularSequence
	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	enc.SetEscapeHTML(false)
	if err := enc.Encode((Alias)(r)); err != nil {
		return nil, err
	}
	b := buf.Bytes()
	if len(b) > 0 && b[len(b)-1] == '\n' {
		b = b[:len(b)-1]
	}
	return b, nil
}

// UnmarshalJSON handles deserialization of polymorphic contained resources.
func (r *MolecularSequence) UnmarshalJSON(data []byte) error {
	// Use an alias to avoid infinite recursion
	type Alias MolecularSequence
	aux := &struct {
		Contained []json.RawMessage `json:"contained,omitempty"`
		*Alias
	}{
		Alias: (*Alias)(r),
	}

	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}

	// Unmarshal each contained resource using the dispatcher
	if len(aux.Contained) > 0 {
		r.Contained = make([]Resource, len(aux.Contained))
		for i, raw := range aux.Contained {
			resource, err := UnmarshalResource(raw)
			if err != nil {
				return fmt.Errorf("failed to unmarshal contained[%d]: %w", i, err)
			}
			r.Contained[i] = resource
		}
	}

	return nil
}

// MarshalXML serializes MolecularSequence to FHIR-conformant XML.
func (r MolecularSequence) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MolecularSequence"
		start.Name.Space = fhirNamespace
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	if err := xmlEncodePrimitiveString(e, "id", r.Id, nil); err != nil {
		return err
	}
	if r.Meta != nil {
		if err := r.Meta.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "meta"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "implicitRules", r.ImplicitRules, r.ImplicitRulesExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "language", r.Language, r.LanguageExt); err != nil {
		return err
	}
	if r.Text != nil {
		if err := r.Text.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "text"}}); err != nil {
			return err
		}
	}
	for _, c := range r.Contained {
		if c != nil {
			if err := xmlEncodeContainedResource(e, c); err != nil {
				return err
			}
		}
	}
	for _, item := range r.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range r.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Identifier {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "identifier"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveCode(e, "type", r.Type, r.TypeExt); err != nil {
		return err
	}
	if r.Subject != nil {
		if err := r.Subject.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "subject"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Focus {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "focus"}}); err != nil {
			return err
		}
	}
	if r.Specimen != nil {
		if err := r.Specimen.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "specimen"}}); err != nil {
			return err
		}
	}
	if r.Device != nil {
		if err := r.Device.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "device"}}); err != nil {
			return err
		}
	}
	if r.Performer != nil {
		if err := r.Performer.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "performer"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "literal", r.Literal, r.LiteralExt); err != nil {
		return err
	}
	for _, item := range r.Formatted {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "formatted"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Relative {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "relative"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MolecularSequence from FHIR-conformant XML.
func (r *MolecularSequence) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "id":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Id = v
			case "meta":
				var v Meta
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Meta = &v
			case "implicitRules":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ImplicitRules = v
				r.ImplicitRulesExt = ext
			case "language":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Language = v
				r.LanguageExt = ext
			case "text":
				var v Narrative
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Text = &v
			case "contained":
				res, err := xmlDecodeContainedResource(d, t)
				if err != nil {
					return err
				}
				if res != nil {
					r.Contained = append(r.Contained, res)
				}
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "identifier":
				var v Identifier
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Identifier = append(r.Identifier, v)
			case "type":
				v, ext, err := xmlDecodePrimitiveCode[SequenceType](d, t)
				if err != nil {
					return err
				}
				r.Type = v
				r.TypeExt = ext
			case "subject":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Subject = &v
			case "focus":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Focus = append(r.Focus, v)
			case "specimen":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Specimen = &v
			case "device":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Device = &v
			case "performer":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Performer = &v
			case "literal":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Literal = v
				r.LiteralExt = ext
			case "formatted":
				var v Attachment
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Formatted = append(r.Formatted, v)
			case "relative":
				var v MolecularSequenceRelative
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Relative = append(r.Relative, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MolecularSequenceRelative represents the MolecularSequence.relative backbone element.
// A sequence defined relative to another sequence
type MolecularSequenceRelative struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Ways of identifying nucleotides or amino acids within a sequence
	CoordinateSystem CodeableConcept `json:"coordinateSystem,omitempty"`
	// Indicates the order in which the sequence should be considered when putting multiple 'relative' elements together
	OrdinalPosition *int `json:"ordinalPosition,omitempty"`
	// Indicates the nucleotide range in the composed sequence when multiple 'relative' elements are used together
	SequenceRange *Range `json:"sequenceRange,omitempty"`
	// A sequence used as starting sequence
	StartingSequence *MolecularSequenceRelativeStartingSequence `json:"startingSequence,omitempty"`
	// Changes in sequence from the starting sequence
	Edit []MolecularSequenceRelativeEdit `json:"edit,omitempty"`
}

// MarshalXML serializes MolecularSequenceRelative to FHIR-conformant XML.
func (b MolecularSequenceRelative) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MolecularSequence.relative"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := b.CoordinateSystem.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "coordinateSystem"}}); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveInt(e, "ordinalPosition", b.OrdinalPosition, nil); err != nil {
		return err
	}
	if b.SequenceRange != nil {
		if err := b.SequenceRange.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "sequenceRange"}}); err != nil {
			return err
		}
	}
	if b.StartingSequence != nil {
		if err := b.StartingSequence.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "startingSequence"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Edit {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "edit"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MolecularSequenceRelative from FHIR-conformant XML.
func (r *MolecularSequenceRelative) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "coordinateSystem":
				if err := r.CoordinateSystem.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "ordinalPosition":
				v, _, err := xmlDecodePrimitiveInt(d, t)
				if err != nil {
					return err
				}
				r.OrdinalPosition = v
			case "sequenceRange":
				var v Range
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.SequenceRange = &v
			case "startingSequence":
				var v MolecularSequenceRelativeStartingSequence
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.StartingSequence = &v
			case "edit":
				var v MolecularSequenceRelativeEdit
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Edit = append(r.Edit, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MolecularSequenceRelativeEdit represents the MolecularSequence.relative.edit backbone element.
// Changes in sequence from the starting sequence
type MolecularSequenceRelativeEdit struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Start position of the edit on the starting sequence
	Start *int `json:"start,omitempty"`
	// End position of the edit on the starting sequence
	End *int `json:"end,omitempty"`
	// Allele that was observed
	ReplacementSequence *string `json:"replacementSequence,omitempty"`
	// Allele in the starting sequence
	ReplacedSequence *string `json:"replacedSequence,omitempty"`
}

// MarshalXML serializes MolecularSequenceRelativeEdit to FHIR-conformant XML.
func (b MolecularSequenceRelativeEdit) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MolecularSequence.relative.edit"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveInt(e, "start", b.Start, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveInt(e, "end", b.End, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "replacementSequence", b.ReplacementSequence, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "replacedSequence", b.ReplacedSequence, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MolecularSequenceRelativeEdit from FHIR-conformant XML.
func (r *MolecularSequenceRelativeEdit) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "start":
				v, _, err := xmlDecodePrimitiveInt(d, t)
				if err != nil {
					return err
				}
				r.Start = v
			case "end":
				v, _, err := xmlDecodePrimitiveInt(d, t)
				if err != nil {
					return err
				}
				r.End = v
			case "replacementSequence":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ReplacementSequence = v
			case "replacedSequence":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ReplacedSequence = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MolecularSequenceRelativeStartingSequence represents the MolecularSequence.relative.startingSequence backbone element.
// A sequence used as starting sequence
type MolecularSequenceRelativeStartingSequence struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The genome assembly used for starting sequence, e.g. GRCh38
	GenomeAssembly *CodeableConcept `json:"genomeAssembly,omitempty"`
	// Chromosome Identifier
	Chromosome *CodeableConcept `json:"chromosome,omitempty"`
	// The reference sequence that represents the starting sequence
	SequenceCodeableConcept *CodeableConcept `json:"sequenceCodeableConcept,omitempty"`
	// The reference sequence that represents the starting sequence
	SequenceString *string `json:"sequenceString,omitempty"`
	// Extension for SequenceString
	SequenceStringExt *Element `json:"_sequenceString,omitempty"`
	// The reference sequence that represents the starting sequence
	SequenceReference *Reference `json:"sequenceReference,omitempty"`
	// Start position of the window on the starting sequence
	WindowStart *int `json:"windowStart,omitempty"`
	// End position of the window on the starting sequence
	WindowEnd *int `json:"windowEnd,omitempty"`
	// sense | antisense
	Orientation *OrientationType `json:"orientation,omitempty"`
	// watson | crick
	Strand *StrandType `json:"strand,omitempty"`
}

// MarshalXML serializes MolecularSequenceRelativeStartingSequence to FHIR-conformant XML.
func (b MolecularSequenceRelativeStartingSequence) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MolecularSequence.relative.startingSequence"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.GenomeAssembly != nil {
		if err := b.GenomeAssembly.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "genomeAssembly"}}); err != nil {
			return err
		}
	}
	if b.Chromosome != nil {
		if err := b.Chromosome.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "chromosome"}}); err != nil {
			return err
		}
	}
	if b.SequenceCodeableConcept != nil {
		if err := b.SequenceCodeableConcept.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "sequenceCodeableConcept"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "sequenceString", b.SequenceString, nil); err != nil {
		return err
	}
	if b.SequenceReference != nil {
		if err := b.SequenceReference.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "sequenceReference"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveInt(e, "windowStart", b.WindowStart, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveInt(e, "windowEnd", b.WindowEnd, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveCode(e, "orientation", b.Orientation, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveCode(e, "strand", b.Strand, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MolecularSequenceRelativeStartingSequence from FHIR-conformant XML.
func (r *MolecularSequenceRelativeStartingSequence) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "genomeAssembly":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.GenomeAssembly = &v
			case "chromosome":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Chromosome = &v
			case "sequenceCodeableConcept":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.SequenceCodeableConcept = &v
			case "sequenceString":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.SequenceString = v
			case "sequenceReference":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.SequenceReference = &v
			case "windowStart":
				v, _, err := xmlDecodePrimitiveInt(d, t)
				if err != nil {
					return err
				}
				r.WindowStart = v
			case "windowEnd":
				v, _, err := xmlDecodePrimitiveInt(d, t)
				if err != nil {
					return err
				}
				r.WindowEnd = v
			case "orientation":
				v, _, err := xmlDecodePrimitiveCode[OrientationType](d, t)
				if err != nil {
					return err
				}
				r.Orientation = v
			case "strand":
				v, _, err := xmlDecodePrimitiveCode[StrandType](d, t)
				if err != nil {
					return err
				}
				r.Strand = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// =============================================================================
// MolecularSequence - Fluent Builder
// =============================================================================

// MolecularSequenceBuilder provides a fluent API for constructing MolecularSequence resources.
type MolecularSequenceBuilder struct {
	molecularSequence *MolecularSequence
}

// NewMolecularSequenceBuilder creates a new MolecularSequenceBuilder.
func NewMolecularSequenceBuilder() *MolecularSequenceBuilder {
	return &MolecularSequenceBuilder{
		molecularSequence: &MolecularSequence{},
	}
}

// Build returns the constructed MolecularSequence resource.
func (b *MolecularSequenceBuilder) Build() *MolecularSequence {
	return b.molecularSequence
}

// SetId sets the Id field.
func (b *MolecularSequenceBuilder) SetId(v string) *MolecularSequenceBuilder {
	b.molecularSequence.Id = &v
	return b
}

// SetMeta sets the Meta field.
func (b *MolecularSequenceBuilder) SetMeta(v Meta) *MolecularSequenceBuilder {
	b.molecularSequence.Meta = &v
	return b
}

// SetImplicitRules sets the ImplicitRules field.
func (b *MolecularSequenceBuilder) SetImplicitRules(v string) *MolecularSequenceBuilder {
	b.molecularSequence.ImplicitRules = &v
	return b
}

// SetLanguage sets the Language field.
func (b *MolecularSequenceBuilder) SetLanguage(v string) *MolecularSequenceBuilder {
	b.molecularSequence.Language = &v
	return b
}

// SetText sets the Text field.
func (b *MolecularSequenceBuilder) SetText(v Narrative) *MolecularSequenceBuilder {
	b.molecularSequence.Text = &v
	return b
}

// AddContained adds a Contained element.
func (b *MolecularSequenceBuilder) AddContained(v Resource) *MolecularSequenceBuilder {
	b.molecularSequence.Contained = append(b.molecularSequence.Contained, v)
	return b
}

// AddExtension adds a Extension element.
func (b *MolecularSequenceBuilder) AddExtension(v Extension) *MolecularSequenceBuilder {
	b.molecularSequence.Extension = append(b.molecularSequence.Extension, v)
	return b
}

// AddModifierExtension adds a ModifierExtension element.
func (b *MolecularSequenceBuilder) AddModifierExtension(v Extension) *MolecularSequenceBuilder {
	b.molecularSequence.ModifierExtension = append(b.molecularSequence.ModifierExtension, v)
	return b
}

// AddIdentifier adds a Identifier element.
func (b *MolecularSequenceBuilder) AddIdentifier(v Identifier) *MolecularSequenceBuilder {
	b.molecularSequence.Identifier = append(b.molecularSequence.Identifier, v)
	return b
}

// SetType sets the Type field.
func (b *MolecularSequenceBuilder) SetType(v SequenceType) *MolecularSequenceBuilder {
	b.molecularSequence.Type = &v
	return b
}

// SetSubject sets the Subject field.
func (b *MolecularSequenceBuilder) SetSubject(v Reference) *MolecularSequenceBuilder {
	b.molecularSequence.Subject = &v
	return b
}

// AddFocus adds a Focus element.
func (b *MolecularSequenceBuilder) AddFocus(v Reference) *MolecularSequenceBuilder {
	b.molecularSequence.Focus = append(b.molecularSequence.Focus, v)
	return b
}

// SetSpecimen sets the Specimen field.
func (b *MolecularSequenceBuilder) SetSpecimen(v Reference) *MolecularSequenceBuilder {
	b.molecularSequence.Specimen = &v
	return b
}

// SetDevice sets the Device field.
func (b *MolecularSequenceBuilder) SetDevice(v Reference) *MolecularSequenceBuilder {
	b.molecularSequence.Device = &v
	return b
}

// SetPerformer sets the Performer field.
func (b *MolecularSequenceBuilder) SetPerformer(v Reference) *MolecularSequenceBuilder {
	b.molecularSequence.Performer = &v
	return b
}

// SetLiteral sets the Literal field.
func (b *MolecularSequenceBuilder) SetLiteral(v string) *MolecularSequenceBuilder {
	b.molecularSequence.Literal = &v
	return b
}

// AddFormatted adds a Formatted element.
func (b *MolecularSequenceBuilder) AddFormatted(v Attachment) *MolecularSequenceBuilder {
	b.molecularSequence.Formatted = append(b.molecularSequence.Formatted, v)
	return b
}

// AddRelative adds a Relative element.
func (b *MolecularSequenceBuilder) AddRelative(v MolecularSequenceRelative) *MolecularSequenceBuilder {
	b.molecularSequence.Relative = append(b.molecularSequence.Relative, v)
	return b
}

// =============================================================================
// MolecularSequence - Functional Options
// =============================================================================

// MolecularSequenceOption is a functional option for configuring a MolecularSequence.
type MolecularSequenceOption func(*MolecularSequence)

// NewMolecularSequence creates a new MolecularSequence with the given options.
func NewMolecularSequence(opts ...MolecularSequenceOption) *MolecularSequence {
	r := &MolecularSequence{}
	for _, opt := range opts {
		opt(r)
	}
	return r
}

// WithMolecularSequenceId sets the Id field.
func WithMolecularSequenceId(v string) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.Id = &v
	}
}

// WithMolecularSequenceMeta sets the Meta field.
func WithMolecularSequenceMeta(v Meta) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.Meta = &v
	}
}

// WithMolecularSequenceImplicitRules sets the ImplicitRules field.
func WithMolecularSequenceImplicitRules(v string) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.ImplicitRules = &v
	}
}

// WithMolecularSequenceLanguage sets the Language field.
func WithMolecularSequenceLanguage(v string) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.Language = &v
	}
}

// WithMolecularSequenceText sets the Text field.
func WithMolecularSequenceText(v Narrative) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.Text = &v
	}
}

// WithMolecularSequenceContained adds a Contained to the MolecularSequence.
func WithMolecularSequenceContained(v Resource) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.Contained = append(r.Contained, v)
	}
}

// WithMolecularSequenceExtension adds a Extension to the MolecularSequence.
func WithMolecularSequenceExtension(v Extension) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.Extension = append(r.Extension, v)
	}
}

// WithMolecularSequenceModifierExtension adds a ModifierExtension to the MolecularSequence.
func WithMolecularSequenceModifierExtension(v Extension) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.ModifierExtension = append(r.ModifierExtension, v)
	}
}

// WithMolecularSequenceIdentifier adds a Identifier to the MolecularSequence.
func WithMolecularSequenceIdentifier(v Identifier) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.Identifier = append(r.Identifier, v)
	}
}

// WithMolecularSequenceType sets the Type field.
func WithMolecularSequenceType(v SequenceType) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.Type = &v
	}
}

// WithMolecularSequenceSubject sets the Subject field.
func WithMolecularSequenceSubject(v Reference) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.Subject = &v
	}
}

// WithMolecularSequenceFocus adds a Focus to the MolecularSequence.
func WithMolecularSequenceFocus(v Reference) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.Focus = append(r.Focus, v)
	}
}

// WithMolecularSequenceSpecimen sets the Specimen field.
func WithMolecularSequenceSpecimen(v Reference) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.Specimen = &v
	}
}

// WithMolecularSequenceDevice sets the Device field.
func WithMolecularSequenceDevice(v Reference) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.Device = &v
	}
}

// WithMolecularSequencePerformer sets the Performer field.
func WithMolecularSequencePerformer(v Reference) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.Performer = &v
	}
}

// WithMolecularSequenceLiteral sets the Literal field.
func WithMolecularSequenceLiteral(v string) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.Literal = &v
	}
}

// WithMolecularSequenceFormatted adds a Formatted to the MolecularSequence.
func WithMolecularSequenceFormatted(v Attachment) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.Formatted = append(r.Formatted, v)
	}
}

// WithMolecularSequenceRelative adds a Relative to the MolecularSequence.
func WithMolecularSequenceRelative(v MolecularSequenceRelative) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.Relative = append(r.Relative, v)
	}
}
