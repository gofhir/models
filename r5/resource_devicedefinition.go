// Code generated by gofhir. DO NOT EDIT.
// Source: FHIR StructureDefinitions (consolidated resource)
// Package: r5

package r5

import (
	"bytes"
	"encoding/json"
	"encoding/xml"
	"fmt"
)

// =============================================================================
// DeviceDefinition Resource
// =============================================================================

// DeviceDefinition represents FHIR DeviceDefinition.
type DeviceDefinition struct {
	// FHIR resource type
	ResourceType string `json:"resourceType"`
	// Logical id of this artifact
	Id *string `json:"id,omitempty"`
	// Metadata about the resource
	Meta *Meta `json:"meta,omitempty"`
	// A set of rules under which this content was created
	ImplicitRules *string `json:"implicitRules,omitempty"`
	// Extension for ImplicitRules
	ImplicitRulesExt *Element `json:"_implicitRules,omitempty"`
	// Language of the resource content
	Language *string `json:"language,omitempty"`
	// Extension for Language
	LanguageExt *Element `json:"_language,omitempty"`
	// Text summary of the resource, for human interpretation
	Text *Narrative `json:"text,omitempty"`
	// Contained, inline Resources
	Contained []Resource `json:"contained,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Additional information to describe the device
	Description *string `json:"description,omitempty"`
	// Extension for Description
	DescriptionExt *Element `json:"_description,omitempty"`
	// Instance identifier
	Identifier []Identifier `json:"identifier,omitempty"`
	// Unique Device Identifier (UDI) Barcode string
	UdiDeviceIdentifier []DeviceDefinitionUdiDeviceIdentifier `json:"udiDeviceIdentifier,omitempty"`
	// Regulatory identifier(s) associated with this device
	RegulatoryIdentifier []DeviceDefinitionRegulatoryIdentifier `json:"regulatoryIdentifier,omitempty"`
	// The part number or catalog number of the device
	PartNumber *string `json:"partNumber,omitempty"`
	// Extension for PartNumber
	PartNumberExt *Element `json:"_partNumber,omitempty"`
	// Name of device manufacturer
	Manufacturer *Reference `json:"manufacturer,omitempty"`
	// The name or names of the device as given by the manufacturer
	DeviceName []DeviceDefinitionDeviceName `json:"deviceName,omitempty"`
	// The catalog or model number for the device for example as defined by the manufacturer
	ModelNumber *string `json:"modelNumber,omitempty"`
	// Extension for ModelNumber
	ModelNumberExt *Element `json:"_modelNumber,omitempty"`
	// What kind of device or device system this is
	Classification []DeviceDefinitionClassification `json:"classification,omitempty"`
	// Identifies the standards, specifications, or formal guidances for the capabilities supported by the device
	ConformsTo []DeviceDefinitionConformsTo `json:"conformsTo,omitempty"`
	// A device, part of the current one
	HasPart []DeviceDefinitionHasPart `json:"hasPart,omitempty"`
	// Information about the packaging of the device, i.e. how the device is packaged
	Packaging []DeviceDefinitionPackaging `json:"packaging,omitempty"`
	// The version of the device or software
	Version []DeviceDefinitionVersion `json:"version,omitempty"`
	// Safety characteristics of the device
	Safety []CodeableConcept `json:"safety,omitempty"`
	// Shelf Life and storage information
	ShelfLifeStorage []ProductShelfLife `json:"shelfLifeStorage,omitempty"`
	// Language code for the human-readable text strings produced by the device (all supported)
	LanguageCode []CodeableConcept `json:"languageCode,omitempty"`
	// Inherent, essentially fixed, characteristics of this kind of device, e.g., time properties, size, etc
	Property []DeviceDefinitionProperty `json:"property,omitempty"`
	// Organization responsible for device
	Owner *Reference `json:"owner,omitempty"`
	// Details for human/organization for support
	Contact []ContactPoint `json:"contact,omitempty"`
	// An associated device, attached to, used with, communicating with or linking a previous or new device model to the focal device
	Link []DeviceDefinitionLink `json:"link,omitempty"`
	// Device notes and comments
	Note []Annotation `json:"note,omitempty"`
	// A substance used to create the material(s) of which the device is made
	Material []DeviceDefinitionMaterial `json:"material,omitempty"`
	// lot-number | manufactured-date | serial-number | expiration-date | biological-source | software-version
	ProductionIdentifierInUDI []DeviceProductionIdentifierInUDI `json:"productionIdentifierInUDI,omitempty"`
	// Extension for ProductionIdentifierInUDI
	ProductionIdentifierInUDIExt []Element `json:"_productionIdentifierInUDI,omitempty"`
	// Information aimed at providing directions for the usage of this model of device
	Guideline *DeviceDefinitionGuideline `json:"guideline,omitempty"`
	// Tracking of latest field safety corrective action
	CorrectiveAction *DeviceDefinitionCorrectiveAction `json:"correctiveAction,omitempty"`
	// Billing code or reference associated with the device
	ChargeItem []DeviceDefinitionChargeItem `json:"chargeItem,omitempty"`
}

// GetResourceType returns the FHIR resource type.
func (r *DeviceDefinition) GetResourceType() string {
	return "DeviceDefinition"
}

// GetId returns the resource's logical ID.
func (r *DeviceDefinition) GetId() *string {
	return r.Id
}

// SetId sets the resource's logical ID.
func (r *DeviceDefinition) SetId(id string) {
	r.Id = &id
}

// GetMeta returns the resource's Meta element.
func (r *DeviceDefinition) GetMeta() *Meta {
	return r.Meta
}

// SetMeta sets the resource's Meta element.
func (r *DeviceDefinition) SetMeta(m *Meta) {
	r.Meta = m
}

// GetText returns the resource's narrative text.
func (r *DeviceDefinition) GetText() *Narrative {
	return r.Text
}

// SetText sets the resource's narrative text.
func (r *DeviceDefinition) SetText(t *Narrative) {
	r.Text = t
}

// GetContained returns the resource's contained resources.
func (r *DeviceDefinition) GetContained() []Resource {
	return r.Contained
}

// GetExtension returns the resource's extensions.
func (r *DeviceDefinition) GetExtension() []Extension {
	return r.Extension
}

// GetModifierExtension returns the resource's modifier extensions.
func (r *DeviceDefinition) GetModifierExtension() []Extension {
	return r.ModifierExtension
}

// MarshalJSON ensures resourceType is always included in JSON output.
// HTML escaping is disabled to preserve FHIR narrative XHTML content.
//
// Note: Use the package-level Marshal function instead of json.Marshal
// to ensure HTML in narrative text.div fields is not escaped.
func (r DeviceDefinition) MarshalJSON() ([]byte, error) {
	r.ResourceType = "DeviceDefinition"
	type Alias DeviceDefinition
	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	enc.SetEscapeHTML(false)
	if err := enc.Encode((Alias)(r)); err != nil {
		return nil, err
	}
	b := buf.Bytes()
	if len(b) > 0 && b[len(b)-1] == '\n' {
		b = b[:len(b)-1]
	}
	return b, nil
}

// UnmarshalJSON handles deserialization of polymorphic contained resources.
func (r *DeviceDefinition) UnmarshalJSON(data []byte) error {
	// Use an alias to avoid infinite recursion
	type Alias DeviceDefinition
	aux := &struct {
		Contained []json.RawMessage `json:"contained,omitempty"`
		*Alias
	}{
		Alias: (*Alias)(r),
	}

	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}

	// Unmarshal each contained resource using the dispatcher
	if len(aux.Contained) > 0 {
		r.Contained = make([]Resource, len(aux.Contained))
		for i, raw := range aux.Contained {
			resource, err := UnmarshalResource(raw)
			if err != nil {
				return fmt.Errorf("failed to unmarshal contained[%d]: %w", i, err)
			}
			r.Contained[i] = resource
		}
	}

	return nil
}

// MarshalXML serializes DeviceDefinition to FHIR-conformant XML.
func (r DeviceDefinition) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "DeviceDefinition"
		start.Name.Space = fhirNamespace
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	if err := xmlEncodePrimitiveString(e, "id", r.Id, nil); err != nil {
		return err
	}
	if r.Meta != nil {
		if err := r.Meta.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "meta"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "implicitRules", r.ImplicitRules, r.ImplicitRulesExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "language", r.Language, r.LanguageExt); err != nil {
		return err
	}
	if r.Text != nil {
		if err := r.Text.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "text"}}); err != nil {
			return err
		}
	}
	for _, c := range r.Contained {
		if c != nil {
			if err := xmlEncodeContainedResource(e, c); err != nil {
				return err
			}
		}
	}
	for _, item := range r.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range r.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "description", r.Description, r.DescriptionExt); err != nil {
		return err
	}
	for _, item := range r.Identifier {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "identifier"}}); err != nil {
			return err
		}
	}
	for _, item := range r.UdiDeviceIdentifier {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "udiDeviceIdentifier"}}); err != nil {
			return err
		}
	}
	for _, item := range r.RegulatoryIdentifier {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "regulatoryIdentifier"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "partNumber", r.PartNumber, r.PartNumberExt); err != nil {
		return err
	}
	if r.Manufacturer != nil {
		if err := r.Manufacturer.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "manufacturer"}}); err != nil {
			return err
		}
	}
	for _, item := range r.DeviceName {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "deviceName"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "modelNumber", r.ModelNumber, r.ModelNumberExt); err != nil {
		return err
	}
	for _, item := range r.Classification {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "classification"}}); err != nil {
			return err
		}
	}
	for _, item := range r.ConformsTo {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "conformsTo"}}); err != nil {
			return err
		}
	}
	for _, item := range r.HasPart {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "hasPart"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Packaging {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "packaging"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Version {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "version"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Safety {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "safety"}}); err != nil {
			return err
		}
	}
	for _, item := range r.ShelfLifeStorage {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "shelfLifeStorage"}}); err != nil {
			return err
		}
	}
	for _, item := range r.LanguageCode {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "languageCode"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Property {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "property"}}); err != nil {
			return err
		}
	}
	if r.Owner != nil {
		if err := r.Owner.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "owner"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Contact {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "contact"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Link {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "link"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Note {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "note"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Material {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "material"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveCodeArray(e, "productionIdentifierInUDI", r.ProductionIdentifierInUDI, r.ProductionIdentifierInUDIExt); err != nil {
		return err
	}
	if r.Guideline != nil {
		if err := r.Guideline.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "guideline"}}); err != nil {
			return err
		}
	}
	if r.CorrectiveAction != nil {
		if err := r.CorrectiveAction.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "correctiveAction"}}); err != nil {
			return err
		}
	}
	for _, item := range r.ChargeItem {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "chargeItem"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes DeviceDefinition from FHIR-conformant XML.
func (r *DeviceDefinition) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "id":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Id = v
			case "meta":
				var v Meta
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Meta = &v
			case "implicitRules":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ImplicitRules = v
				r.ImplicitRulesExt = ext
			case "language":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Language = v
				r.LanguageExt = ext
			case "text":
				var v Narrative
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Text = &v
			case "contained":
				res, err := xmlDecodeContainedResource(d, t)
				if err != nil {
					return err
				}
				if res != nil {
					r.Contained = append(r.Contained, res)
				}
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "description":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Description = v
				r.DescriptionExt = ext
			case "identifier":
				var v Identifier
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Identifier = append(r.Identifier, v)
			case "udiDeviceIdentifier":
				var v DeviceDefinitionUdiDeviceIdentifier
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.UdiDeviceIdentifier = append(r.UdiDeviceIdentifier, v)
			case "regulatoryIdentifier":
				var v DeviceDefinitionRegulatoryIdentifier
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.RegulatoryIdentifier = append(r.RegulatoryIdentifier, v)
			case "partNumber":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.PartNumber = v
				r.PartNumberExt = ext
			case "manufacturer":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Manufacturer = &v
			case "deviceName":
				var v DeviceDefinitionDeviceName
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.DeviceName = append(r.DeviceName, v)
			case "modelNumber":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ModelNumber = v
				r.ModelNumberExt = ext
			case "classification":
				var v DeviceDefinitionClassification
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Classification = append(r.Classification, v)
			case "conformsTo":
				var v DeviceDefinitionConformsTo
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ConformsTo = append(r.ConformsTo, v)
			case "hasPart":
				var v DeviceDefinitionHasPart
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.HasPart = append(r.HasPart, v)
			case "packaging":
				var v DeviceDefinitionPackaging
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Packaging = append(r.Packaging, v)
			case "version":
				var v DeviceDefinitionVersion
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Version = append(r.Version, v)
			case "safety":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Safety = append(r.Safety, v)
			case "shelfLifeStorage":
				var v ProductShelfLife
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ShelfLifeStorage = append(r.ShelfLifeStorage, v)
			case "languageCode":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.LanguageCode = append(r.LanguageCode, v)
			case "property":
				var v DeviceDefinitionProperty
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Property = append(r.Property, v)
			case "owner":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Owner = &v
			case "contact":
				var v ContactPoint
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Contact = append(r.Contact, v)
			case "link":
				var v DeviceDefinitionLink
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Link = append(r.Link, v)
			case "note":
				var v Annotation
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Note = append(r.Note, v)
			case "material":
				var v DeviceDefinitionMaterial
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Material = append(r.Material, v)
			case "productionIdentifierInUDI":
				v, _, err := xmlDecodePrimitiveCode[DeviceProductionIdentifierInUDI](d, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.ProductionIdentifierInUDI = append(r.ProductionIdentifierInUDI, *v)
				}
			case "guideline":
				var v DeviceDefinitionGuideline
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Guideline = &v
			case "correctiveAction":
				var v DeviceDefinitionCorrectiveAction
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.CorrectiveAction = &v
			case "chargeItem":
				var v DeviceDefinitionChargeItem
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ChargeItem = append(r.ChargeItem, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// DeviceDefinitionChargeItem represents the DeviceDefinition.chargeItem backbone element.
// Billing code or reference associated with the device
type DeviceDefinitionChargeItem struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The code or reference for the charge item
	ChargeItemCode CodeableReference `json:"chargeItemCode,omitempty"`
	// Coefficient applicable to the billing code
	Count Quantity `json:"count,omitempty"`
	// A specific time period in which this charge item applies
	EffectivePeriod *Period `json:"effectivePeriod,omitempty"`
	// The context to which this charge item applies
	UseContext []UsageContext `json:"useContext,omitempty"`
}

// MarshalXML serializes DeviceDefinitionChargeItem to FHIR-conformant XML.
func (b DeviceDefinitionChargeItem) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "DeviceDefinition.chargeItem"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := b.ChargeItemCode.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "chargeItemCode"}}); err != nil {
		return err
	}
	if err := b.Count.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "count"}}); err != nil {
		return err
	}
	if b.EffectivePeriod != nil {
		if err := b.EffectivePeriod.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "effectivePeriod"}}); err != nil {
			return err
		}
	}
	for _, item := range b.UseContext {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "useContext"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes DeviceDefinitionChargeItem from FHIR-conformant XML.
func (r *DeviceDefinitionChargeItem) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "chargeItemCode":
				if err := r.ChargeItemCode.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "count":
				if err := r.Count.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "effectivePeriod":
				var v Period
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.EffectivePeriod = &v
			case "useContext":
				var v UsageContext
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.UseContext = append(r.UseContext, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// DeviceDefinitionClassification represents the DeviceDefinition.classification backbone element.
// What kind of device or device system this is
type DeviceDefinitionClassification struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// A classification or risk class of the device model
	Type CodeableConcept `json:"type,omitempty"`
	// Further information qualifying this classification of the device model
	Justification []RelatedArtifact `json:"justification,omitempty"`
}

// MarshalXML serializes DeviceDefinitionClassification to FHIR-conformant XML.
func (b DeviceDefinitionClassification) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "DeviceDefinition.classification"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
		return err
	}
	for _, item := range b.Justification {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "justification"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes DeviceDefinitionClassification from FHIR-conformant XML.
func (r *DeviceDefinitionClassification) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "type":
				if err := r.Type.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "justification":
				var v RelatedArtifact
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Justification = append(r.Justification, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// DeviceDefinitionConformsTo represents the DeviceDefinition.conformsTo backbone element.
// Identifies the standards, specifications, or formal guidances for the capabilities supported by the device
type DeviceDefinitionConformsTo struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Describes the common type of the standard, specification, or formal guidance
	Category *CodeableConcept `json:"category,omitempty"`
	// Identifies the standard, specification, or formal guidance that the device adheres to the Device Specification type
	Specification CodeableConcept `json:"specification,omitempty"`
	// The specific form or variant of the standard, specification or formal guidance
	Version []string `json:"version,omitempty"`
	// Standard, regulation, certification, or guidance website, document, or other publication, or similar, supporting the conformance
	Source []RelatedArtifact `json:"source,omitempty"`
}

// MarshalXML serializes DeviceDefinitionConformsTo to FHIR-conformant XML.
func (b DeviceDefinitionConformsTo) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "DeviceDefinition.conformsTo"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.Category != nil {
		if err := b.Category.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "category"}}); err != nil {
			return err
		}
	}
	if err := b.Specification.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "specification"}}); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveStringArray(e, "version", b.Version, nil); err != nil {
		return err
	}
	for _, item := range b.Source {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "source"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes DeviceDefinitionConformsTo from FHIR-conformant XML.
func (r *DeviceDefinitionConformsTo) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "category":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Category = &v
			case "specification":
				if err := r.Specification.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "version":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.Version = append(r.Version, *v)
				}
			case "source":
				var v RelatedArtifact
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Source = append(r.Source, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// DeviceDefinitionCorrectiveAction represents the DeviceDefinition.correctiveAction backbone element.
// Tracking of latest field safety corrective action
type DeviceDefinitionCorrectiveAction struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Whether the corrective action was a recall
	Recall *bool `json:"recall,omitempty"`
	// model | lot-numbers | serial-numbers
	Scope *DeviceCorrectiveActionScope `json:"scope,omitempty"`
	// Start and end dates of the  corrective action
	Period Period `json:"period,omitempty"`
}

// MarshalXML serializes DeviceDefinitionCorrectiveAction to FHIR-conformant XML.
func (b DeviceDefinitionCorrectiveAction) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "DeviceDefinition.correctiveAction"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveBool(e, "recall", b.Recall, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveCode(e, "scope", b.Scope, nil); err != nil {
		return err
	}
	if err := b.Period.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "period"}}); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes DeviceDefinitionCorrectiveAction from FHIR-conformant XML.
func (r *DeviceDefinitionCorrectiveAction) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "recall":
				v, _, err := xmlDecodePrimitiveBool(d, t)
				if err != nil {
					return err
				}
				r.Recall = v
			case "scope":
				v, _, err := xmlDecodePrimitiveCode[DeviceCorrectiveActionScope](d, t)
				if err != nil {
					return err
				}
				r.Scope = v
			case "period":
				if err := r.Period.UnmarshalXML(d, t); err != nil {
					return err
				}
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// DeviceDefinitionDeviceName represents the DeviceDefinition.deviceName backbone element.
// The name or names of the device as given by the manufacturer
type DeviceDefinitionDeviceName struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// A name that is used to refer to the device
	Name *string `json:"name,omitempty"`
	// registered-name | user-friendly-name | patient-reported-name
	Type *DeviceNameType `json:"type,omitempty"`
}

// MarshalXML serializes DeviceDefinitionDeviceName to FHIR-conformant XML.
func (b DeviceDefinitionDeviceName) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "DeviceDefinition.deviceName"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "name", b.Name, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveCode(e, "type", b.Type, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes DeviceDefinitionDeviceName from FHIR-conformant XML.
func (r *DeviceDefinitionDeviceName) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "name":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Name = v
			case "type":
				v, _, err := xmlDecodePrimitiveCode[DeviceNameType](d, t)
				if err != nil {
					return err
				}
				r.Type = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// DeviceDefinitionGuideline represents the DeviceDefinition.guideline backbone element.
// Information aimed at providing directions for the usage of this model of device
type DeviceDefinitionGuideline struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The circumstances that form the setting for using the device
	UseContext []UsageContext `json:"useContext,omitempty"`
	// Detailed written and visual directions for the user on how to use the device
	UsageInstruction *string `json:"usageInstruction,omitempty"`
	// A source of information or reference for this guideline
	RelatedArtifact []RelatedArtifact `json:"relatedArtifact,omitempty"`
	// A clinical condition for which the device was designed to be used
	Indication []CodeableConcept `json:"indication,omitempty"`
	// A specific situation when a device should not be used because it may cause harm
	Contraindication []CodeableConcept `json:"contraindication,omitempty"`
	// Specific hazard alert information that a user needs to know before using the device
	Warning []CodeableConcept `json:"warning,omitempty"`
	// A description of the general purpose or medical use of the device or its function
	IntendedUse *string `json:"intendedUse,omitempty"`
}

// MarshalXML serializes DeviceDefinitionGuideline to FHIR-conformant XML.
func (b DeviceDefinitionGuideline) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "DeviceDefinition.guideline"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.UseContext {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "useContext"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "usageInstruction", b.UsageInstruction, nil); err != nil {
		return err
	}
	for _, item := range b.RelatedArtifact {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "relatedArtifact"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Indication {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "indication"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Contraindication {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "contraindication"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Warning {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "warning"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "intendedUse", b.IntendedUse, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes DeviceDefinitionGuideline from FHIR-conformant XML.
func (r *DeviceDefinitionGuideline) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "useContext":
				var v UsageContext
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.UseContext = append(r.UseContext, v)
			case "usageInstruction":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.UsageInstruction = v
			case "relatedArtifact":
				var v RelatedArtifact
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.RelatedArtifact = append(r.RelatedArtifact, v)
			case "indication":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Indication = append(r.Indication, v)
			case "contraindication":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Contraindication = append(r.Contraindication, v)
			case "warning":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Warning = append(r.Warning, v)
			case "intendedUse":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.IntendedUse = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// DeviceDefinitionHasPart represents the DeviceDefinition.hasPart backbone element.
// A device, part of the current one
type DeviceDefinitionHasPart struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Reference to the part
	Reference Reference `json:"reference,omitempty"`
	// Number of occurrences of the part
	Count *int `json:"count,omitempty"`
}

// MarshalXML serializes DeviceDefinitionHasPart to FHIR-conformant XML.
func (b DeviceDefinitionHasPart) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "DeviceDefinition.hasPart"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := b.Reference.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "reference"}}); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveInt(e, "count", b.Count, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes DeviceDefinitionHasPart from FHIR-conformant XML.
func (r *DeviceDefinitionHasPart) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "reference":
				if err := r.Reference.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "count":
				v, _, err := xmlDecodePrimitiveInt(d, t)
				if err != nil {
					return err
				}
				r.Count = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// DeviceDefinitionLink represents the DeviceDefinition.link backbone element.
// An associated device, attached to, used with, communicating with or linking a previous or new device model to the focal device
type DeviceDefinitionLink struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The type indicates the relationship of the related device to the device instance
	Relation Coding `json:"relation,omitempty"`
	// A reference to the linked device
	RelatedDevice CodeableReference `json:"relatedDevice,omitempty"`
}

// MarshalXML serializes DeviceDefinitionLink to FHIR-conformant XML.
func (b DeviceDefinitionLink) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "DeviceDefinition.link"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := b.Relation.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "relation"}}); err != nil {
		return err
	}
	if err := b.RelatedDevice.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "relatedDevice"}}); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes DeviceDefinitionLink from FHIR-conformant XML.
func (r *DeviceDefinitionLink) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "relation":
				if err := r.Relation.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "relatedDevice":
				if err := r.RelatedDevice.UnmarshalXML(d, t); err != nil {
					return err
				}
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// DeviceDefinitionMaterial represents the DeviceDefinition.material backbone element.
// A substance used to create the material(s) of which the device is made
type DeviceDefinitionMaterial struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// A relevant substance that the device contains, may contain, or is made of
	Substance CodeableConcept `json:"substance,omitempty"`
	// Indicates an alternative material of the device
	Alternate *bool `json:"alternate,omitempty"`
	// Whether the substance is a known or suspected allergen
	AllergenicIndicator *bool `json:"allergenicIndicator,omitempty"`
}

// MarshalXML serializes DeviceDefinitionMaterial to FHIR-conformant XML.
func (b DeviceDefinitionMaterial) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "DeviceDefinition.material"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := b.Substance.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "substance"}}); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveBool(e, "alternate", b.Alternate, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveBool(e, "allergenicIndicator", b.AllergenicIndicator, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes DeviceDefinitionMaterial from FHIR-conformant XML.
func (r *DeviceDefinitionMaterial) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "substance":
				if err := r.Substance.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "alternate":
				v, _, err := xmlDecodePrimitiveBool(d, t)
				if err != nil {
					return err
				}
				r.Alternate = v
			case "allergenicIndicator":
				v, _, err := xmlDecodePrimitiveBool(d, t)
				if err != nil {
					return err
				}
				r.AllergenicIndicator = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// DeviceDefinitionPackaging represents the DeviceDefinition.packaging backbone element.
// Information about the packaging of the device, i.e. how the device is packaged
type DeviceDefinitionPackaging struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Business identifier of the packaged medication
	Identifier *Identifier `json:"identifier,omitempty"`
	// A code that defines the specific type of packaging
	Type *CodeableConcept `json:"type,omitempty"`
	// The number of items contained in the package (devices or sub-packages)
	Count *int `json:"count,omitempty"`
	// An organization that distributes the packaged device
	Distributor []DeviceDefinitionPackagingDistributor `json:"distributor,omitempty"`
	// Unique Device Identifier (UDI) Barcode string on the packaging
	UdiDeviceIdentifier []DeviceDefinitionUdiDeviceIdentifier `json:"udiDeviceIdentifier,omitempty"`
	// Allows packages within packages
	Packaging []DeviceDefinitionPackaging `json:"packaging,omitempty"`
}

// MarshalXML serializes DeviceDefinitionPackaging to FHIR-conformant XML.
func (b DeviceDefinitionPackaging) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "DeviceDefinition.packaging"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.Identifier != nil {
		if err := b.Identifier.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "identifier"}}); err != nil {
			return err
		}
	}
	if b.Type != nil {
		if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveInt(e, "count", b.Count, nil); err != nil {
		return err
	}
	for _, item := range b.Distributor {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "distributor"}}); err != nil {
			return err
		}
	}
	for _, item := range b.UdiDeviceIdentifier {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "udiDeviceIdentifier"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Packaging {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "packaging"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes DeviceDefinitionPackaging from FHIR-conformant XML.
func (r *DeviceDefinitionPackaging) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "identifier":
				var v Identifier
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Identifier = &v
			case "type":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Type = &v
			case "count":
				v, _, err := xmlDecodePrimitiveInt(d, t)
				if err != nil {
					return err
				}
				r.Count = v
			case "distributor":
				var v DeviceDefinitionPackagingDistributor
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Distributor = append(r.Distributor, v)
			case "udiDeviceIdentifier":
				var v DeviceDefinitionUdiDeviceIdentifier
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.UdiDeviceIdentifier = append(r.UdiDeviceIdentifier, v)
			case "packaging":
				var v DeviceDefinitionPackaging
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Packaging = append(r.Packaging, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// DeviceDefinitionPackagingDistributor represents the DeviceDefinition.packaging.distributor backbone element.
// An organization that distributes the packaged device
type DeviceDefinitionPackagingDistributor struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Distributor's human-readable name
	Name *string `json:"name,omitempty"`
	// Distributor as an Organization resource
	OrganizationReference []Reference `json:"organizationReference,omitempty"`
}

// MarshalXML serializes DeviceDefinitionPackagingDistributor to FHIR-conformant XML.
func (b DeviceDefinitionPackagingDistributor) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "DeviceDefinition.packaging.distributor"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "name", b.Name, nil); err != nil {
		return err
	}
	for _, item := range b.OrganizationReference {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "organizationReference"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes DeviceDefinitionPackagingDistributor from FHIR-conformant XML.
func (r *DeviceDefinitionPackagingDistributor) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "name":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Name = v
			case "organizationReference":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.OrganizationReference = append(r.OrganizationReference, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// DeviceDefinitionProperty represents the DeviceDefinition.property backbone element.
// Inherent, essentially fixed, characteristics of this kind of device, e.g., time properties, size, etc
type DeviceDefinitionProperty struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Code that specifies the property being represented
	Type CodeableConcept `json:"type,omitempty"`
	// Value of the property
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`
	// Value of the property
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`
	// Value of the property
	ValueString *string `json:"valueString,omitempty"`
	// Extension for ValueString
	ValueStringExt *Element `json:"_valueString,omitempty"`
	// Value of the property
	ValueBoolean *bool `json:"valueBoolean,omitempty"`
	// Extension for ValueBoolean
	ValueBooleanExt *Element `json:"_valueBoolean,omitempty"`
	// Value of the property
	ValueInteger *int `json:"valueInteger,omitempty"`
	// Extension for ValueInteger
	ValueIntegerExt *Element `json:"_valueInteger,omitempty"`
	// Value of the property
	ValueRange *Range `json:"valueRange,omitempty"`
	// Value of the property
	ValueAttachment *Attachment `json:"valueAttachment,omitempty"`
}

// MarshalXML serializes DeviceDefinitionProperty to FHIR-conformant XML.
func (b DeviceDefinitionProperty) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "DeviceDefinition.property"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
		return err
	}
	if b.ValueQuantity != nil {
		if err := b.ValueQuantity.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueQuantity"}}); err != nil {
			return err
		}
	}
	if b.ValueCodeableConcept != nil {
		if err := b.ValueCodeableConcept.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueCodeableConcept"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "valueString", b.ValueString, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveBool(e, "valueBoolean", b.ValueBoolean, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveInt(e, "valueInteger", b.ValueInteger, nil); err != nil {
		return err
	}
	if b.ValueRange != nil {
		if err := b.ValueRange.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueRange"}}); err != nil {
			return err
		}
	}
	if b.ValueAttachment != nil {
		if err := b.ValueAttachment.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueAttachment"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes DeviceDefinitionProperty from FHIR-conformant XML.
func (r *DeviceDefinitionProperty) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "type":
				if err := r.Type.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "valueQuantity":
				var v Quantity
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueQuantity = &v
			case "valueCodeableConcept":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueCodeableConcept = &v
			case "valueString":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ValueString = v
			case "valueBoolean":
				v, _, err := xmlDecodePrimitiveBool(d, t)
				if err != nil {
					return err
				}
				r.ValueBoolean = v
			case "valueInteger":
				v, _, err := xmlDecodePrimitiveInt(d, t)
				if err != nil {
					return err
				}
				r.ValueInteger = v
			case "valueRange":
				var v Range
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueRange = &v
			case "valueAttachment":
				var v Attachment
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueAttachment = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// DeviceDefinitionRegulatoryIdentifier represents the DeviceDefinition.regulatoryIdentifier backbone element.
// Regulatory identifier(s) associated with this device
type DeviceDefinitionRegulatoryIdentifier struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// basic | master | license
	Type *DeviceDefinitionRegulatoryIdentifierType `json:"type,omitempty"`
	// The identifier itself
	DeviceIdentifier *string `json:"deviceIdentifier,omitempty"`
	// The organization that issued this identifier
	Issuer *string `json:"issuer,omitempty"`
	// The jurisdiction to which the deviceIdentifier applies
	Jurisdiction *string `json:"jurisdiction,omitempty"`
}

// MarshalXML serializes DeviceDefinitionRegulatoryIdentifier to FHIR-conformant XML.
func (b DeviceDefinitionRegulatoryIdentifier) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "DeviceDefinition.regulatoryIdentifier"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveCode(e, "type", b.Type, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "deviceIdentifier", b.DeviceIdentifier, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "issuer", b.Issuer, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "jurisdiction", b.Jurisdiction, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes DeviceDefinitionRegulatoryIdentifier from FHIR-conformant XML.
func (r *DeviceDefinitionRegulatoryIdentifier) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "type":
				v, _, err := xmlDecodePrimitiveCode[DeviceDefinitionRegulatoryIdentifierType](d, t)
				if err != nil {
					return err
				}
				r.Type = v
			case "deviceIdentifier":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.DeviceIdentifier = v
			case "issuer":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Issuer = v
			case "jurisdiction":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Jurisdiction = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// DeviceDefinitionUdiDeviceIdentifier represents the DeviceDefinition.udiDeviceIdentifier backbone element.
// Unique Device Identifier (UDI) Barcode string
type DeviceDefinitionUdiDeviceIdentifier struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The identifier that is to be associated with every Device that references this DeviceDefintiion for the issuer and jurisdiction provided in the DeviceDefinition.udiDeviceIdentifier
	DeviceIdentifier *string `json:"deviceIdentifier,omitempty"`
	// The organization that assigns the identifier algorithm
	Issuer *string `json:"issuer,omitempty"`
	// The jurisdiction to which the deviceIdentifier applies
	Jurisdiction *string `json:"jurisdiction,omitempty"`
	// Indicates whether and when the device is available on the market
	MarketDistribution []DeviceDefinitionUdiDeviceIdentifierMarketDistribution `json:"marketDistribution,omitempty"`
}

// MarshalXML serializes DeviceDefinitionUdiDeviceIdentifier to FHIR-conformant XML.
func (b DeviceDefinitionUdiDeviceIdentifier) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "DeviceDefinition.udiDeviceIdentifier"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "deviceIdentifier", b.DeviceIdentifier, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "issuer", b.Issuer, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "jurisdiction", b.Jurisdiction, nil); err != nil {
		return err
	}
	for _, item := range b.MarketDistribution {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "marketDistribution"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes DeviceDefinitionUdiDeviceIdentifier from FHIR-conformant XML.
func (r *DeviceDefinitionUdiDeviceIdentifier) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "deviceIdentifier":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.DeviceIdentifier = v
			case "issuer":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Issuer = v
			case "jurisdiction":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Jurisdiction = v
			case "marketDistribution":
				var v DeviceDefinitionUdiDeviceIdentifierMarketDistribution
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.MarketDistribution = append(r.MarketDistribution, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// DeviceDefinitionUdiDeviceIdentifierMarketDistribution represents the DeviceDefinition.udiDeviceIdentifier.marketDistribution backbone element.
// Indicates whether and when the device is available on the market
type DeviceDefinitionUdiDeviceIdentifierMarketDistribution struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Begin and end dates for the commercial distribution of the device
	MarketPeriod Period `json:"marketPeriod,omitempty"`
	// National state or territory where the device is commercialized
	SubJurisdiction *string `json:"subJurisdiction,omitempty"`
}

// MarshalXML serializes DeviceDefinitionUdiDeviceIdentifierMarketDistribution to FHIR-conformant XML.
func (b DeviceDefinitionUdiDeviceIdentifierMarketDistribution) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "DeviceDefinition.udiDeviceIdentifier.marketDistribution"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := b.MarketPeriod.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "marketPeriod"}}); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "subJurisdiction", b.SubJurisdiction, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes DeviceDefinitionUdiDeviceIdentifierMarketDistribution from FHIR-conformant XML.
func (r *DeviceDefinitionUdiDeviceIdentifierMarketDistribution) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "marketPeriod":
				if err := r.MarketPeriod.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "subJurisdiction":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.SubJurisdiction = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// DeviceDefinitionVersion represents the DeviceDefinition.version backbone element.
// The version of the device or software
type DeviceDefinitionVersion struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The type of the device version, e.g. manufacturer, approved, internal
	Type *CodeableConcept `json:"type,omitempty"`
	// The hardware or software module of the device to which the version applies
	Component *Identifier `json:"component,omitempty"`
	// The version text
	Value *string `json:"value,omitempty"`
}

// MarshalXML serializes DeviceDefinitionVersion to FHIR-conformant XML.
func (b DeviceDefinitionVersion) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "DeviceDefinition.version"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.Type != nil {
		if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
			return err
		}
	}
	if b.Component != nil {
		if err := b.Component.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "component"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "value", b.Value, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes DeviceDefinitionVersion from FHIR-conformant XML.
func (r *DeviceDefinitionVersion) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "type":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Type = &v
			case "component":
				var v Identifier
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Component = &v
			case "value":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Value = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// =============================================================================
// DeviceDefinition - Fluent Builder
// =============================================================================

// DeviceDefinitionBuilder provides a fluent API for constructing DeviceDefinition resources.
type DeviceDefinitionBuilder struct {
	deviceDefinition *DeviceDefinition
}

// NewDeviceDefinitionBuilder creates a new DeviceDefinitionBuilder.
func NewDeviceDefinitionBuilder() *DeviceDefinitionBuilder {
	return &DeviceDefinitionBuilder{
		deviceDefinition: &DeviceDefinition{},
	}
}

// Build returns the constructed DeviceDefinition resource.
func (b *DeviceDefinitionBuilder) Build() *DeviceDefinition {
	return b.deviceDefinition
}

// SetId sets the Id field.
func (b *DeviceDefinitionBuilder) SetId(v string) *DeviceDefinitionBuilder {
	b.deviceDefinition.Id = &v
	return b
}

// SetMeta sets the Meta field.
func (b *DeviceDefinitionBuilder) SetMeta(v Meta) *DeviceDefinitionBuilder {
	b.deviceDefinition.Meta = &v
	return b
}

// SetImplicitRules sets the ImplicitRules field.
func (b *DeviceDefinitionBuilder) SetImplicitRules(v string) *DeviceDefinitionBuilder {
	b.deviceDefinition.ImplicitRules = &v
	return b
}

// SetLanguage sets the Language field.
func (b *DeviceDefinitionBuilder) SetLanguage(v string) *DeviceDefinitionBuilder {
	b.deviceDefinition.Language = &v
	return b
}

// SetText sets the Text field.
func (b *DeviceDefinitionBuilder) SetText(v Narrative) *DeviceDefinitionBuilder {
	b.deviceDefinition.Text = &v
	return b
}

// AddContained adds a Contained element.
func (b *DeviceDefinitionBuilder) AddContained(v Resource) *DeviceDefinitionBuilder {
	b.deviceDefinition.Contained = append(b.deviceDefinition.Contained, v)
	return b
}

// AddExtension adds a Extension element.
func (b *DeviceDefinitionBuilder) AddExtension(v Extension) *DeviceDefinitionBuilder {
	b.deviceDefinition.Extension = append(b.deviceDefinition.Extension, v)
	return b
}

// AddModifierExtension adds a ModifierExtension element.
func (b *DeviceDefinitionBuilder) AddModifierExtension(v Extension) *DeviceDefinitionBuilder {
	b.deviceDefinition.ModifierExtension = append(b.deviceDefinition.ModifierExtension, v)
	return b
}

// SetDescription sets the Description field.
func (b *DeviceDefinitionBuilder) SetDescription(v string) *DeviceDefinitionBuilder {
	b.deviceDefinition.Description = &v
	return b
}

// AddIdentifier adds a Identifier element.
func (b *DeviceDefinitionBuilder) AddIdentifier(v Identifier) *DeviceDefinitionBuilder {
	b.deviceDefinition.Identifier = append(b.deviceDefinition.Identifier, v)
	return b
}

// AddUdiDeviceIdentifier adds a UdiDeviceIdentifier element.
func (b *DeviceDefinitionBuilder) AddUdiDeviceIdentifier(v DeviceDefinitionUdiDeviceIdentifier) *DeviceDefinitionBuilder {
	b.deviceDefinition.UdiDeviceIdentifier = append(b.deviceDefinition.UdiDeviceIdentifier, v)
	return b
}

// AddRegulatoryIdentifier adds a RegulatoryIdentifier element.
func (b *DeviceDefinitionBuilder) AddRegulatoryIdentifier(v DeviceDefinitionRegulatoryIdentifier) *DeviceDefinitionBuilder {
	b.deviceDefinition.RegulatoryIdentifier = append(b.deviceDefinition.RegulatoryIdentifier, v)
	return b
}

// SetPartNumber sets the PartNumber field.
func (b *DeviceDefinitionBuilder) SetPartNumber(v string) *DeviceDefinitionBuilder {
	b.deviceDefinition.PartNumber = &v
	return b
}

// SetManufacturer sets the Manufacturer field.
func (b *DeviceDefinitionBuilder) SetManufacturer(v Reference) *DeviceDefinitionBuilder {
	b.deviceDefinition.Manufacturer = &v
	return b
}

// AddDeviceName adds a DeviceName element.
func (b *DeviceDefinitionBuilder) AddDeviceName(v DeviceDefinitionDeviceName) *DeviceDefinitionBuilder {
	b.deviceDefinition.DeviceName = append(b.deviceDefinition.DeviceName, v)
	return b
}

// SetModelNumber sets the ModelNumber field.
func (b *DeviceDefinitionBuilder) SetModelNumber(v string) *DeviceDefinitionBuilder {
	b.deviceDefinition.ModelNumber = &v
	return b
}

// AddClassification adds a Classification element.
func (b *DeviceDefinitionBuilder) AddClassification(v DeviceDefinitionClassification) *DeviceDefinitionBuilder {
	b.deviceDefinition.Classification = append(b.deviceDefinition.Classification, v)
	return b
}

// AddConformsTo adds a ConformsTo element.
func (b *DeviceDefinitionBuilder) AddConformsTo(v DeviceDefinitionConformsTo) *DeviceDefinitionBuilder {
	b.deviceDefinition.ConformsTo = append(b.deviceDefinition.ConformsTo, v)
	return b
}

// AddHasPart adds a HasPart element.
func (b *DeviceDefinitionBuilder) AddHasPart(v DeviceDefinitionHasPart) *DeviceDefinitionBuilder {
	b.deviceDefinition.HasPart = append(b.deviceDefinition.HasPart, v)
	return b
}

// AddPackaging adds a Packaging element.
func (b *DeviceDefinitionBuilder) AddPackaging(v DeviceDefinitionPackaging) *DeviceDefinitionBuilder {
	b.deviceDefinition.Packaging = append(b.deviceDefinition.Packaging, v)
	return b
}

// AddVersion adds a Version element.
func (b *DeviceDefinitionBuilder) AddVersion(v DeviceDefinitionVersion) *DeviceDefinitionBuilder {
	b.deviceDefinition.Version = append(b.deviceDefinition.Version, v)
	return b
}

// AddSafety adds a Safety element.
func (b *DeviceDefinitionBuilder) AddSafety(v CodeableConcept) *DeviceDefinitionBuilder {
	b.deviceDefinition.Safety = append(b.deviceDefinition.Safety, v)
	return b
}

// AddShelfLifeStorage adds a ShelfLifeStorage element.
func (b *DeviceDefinitionBuilder) AddShelfLifeStorage(v ProductShelfLife) *DeviceDefinitionBuilder {
	b.deviceDefinition.ShelfLifeStorage = append(b.deviceDefinition.ShelfLifeStorage, v)
	return b
}

// AddLanguageCode adds a LanguageCode element.
func (b *DeviceDefinitionBuilder) AddLanguageCode(v CodeableConcept) *DeviceDefinitionBuilder {
	b.deviceDefinition.LanguageCode = append(b.deviceDefinition.LanguageCode, v)
	return b
}

// AddProperty adds a Property element.
func (b *DeviceDefinitionBuilder) AddProperty(v DeviceDefinitionProperty) *DeviceDefinitionBuilder {
	b.deviceDefinition.Property = append(b.deviceDefinition.Property, v)
	return b
}

// SetOwner sets the Owner field.
func (b *DeviceDefinitionBuilder) SetOwner(v Reference) *DeviceDefinitionBuilder {
	b.deviceDefinition.Owner = &v
	return b
}

// AddContact adds a Contact element.
func (b *DeviceDefinitionBuilder) AddContact(v ContactPoint) *DeviceDefinitionBuilder {
	b.deviceDefinition.Contact = append(b.deviceDefinition.Contact, v)
	return b
}

// AddLink adds a Link element.
func (b *DeviceDefinitionBuilder) AddLink(v DeviceDefinitionLink) *DeviceDefinitionBuilder {
	b.deviceDefinition.Link = append(b.deviceDefinition.Link, v)
	return b
}

// AddNote adds a Note element.
func (b *DeviceDefinitionBuilder) AddNote(v Annotation) *DeviceDefinitionBuilder {
	b.deviceDefinition.Note = append(b.deviceDefinition.Note, v)
	return b
}

// AddMaterial adds a Material element.
func (b *DeviceDefinitionBuilder) AddMaterial(v DeviceDefinitionMaterial) *DeviceDefinitionBuilder {
	b.deviceDefinition.Material = append(b.deviceDefinition.Material, v)
	return b
}

// AddProductionIdentifierInUDI adds a ProductionIdentifierInUDI element.
func (b *DeviceDefinitionBuilder) AddProductionIdentifierInUDI(v DeviceProductionIdentifierInUDI) *DeviceDefinitionBuilder {
	b.deviceDefinition.ProductionIdentifierInUDI = append(b.deviceDefinition.ProductionIdentifierInUDI, v)
	return b
}

// SetGuideline sets the Guideline field.
func (b *DeviceDefinitionBuilder) SetGuideline(v DeviceDefinitionGuideline) *DeviceDefinitionBuilder {
	b.deviceDefinition.Guideline = &v
	return b
}

// SetCorrectiveAction sets the CorrectiveAction field.
func (b *DeviceDefinitionBuilder) SetCorrectiveAction(v DeviceDefinitionCorrectiveAction) *DeviceDefinitionBuilder {
	b.deviceDefinition.CorrectiveAction = &v
	return b
}

// AddChargeItem adds a ChargeItem element.
func (b *DeviceDefinitionBuilder) AddChargeItem(v DeviceDefinitionChargeItem) *DeviceDefinitionBuilder {
	b.deviceDefinition.ChargeItem = append(b.deviceDefinition.ChargeItem, v)
	return b
}

// =============================================================================
// DeviceDefinition - Functional Options
// =============================================================================

// DeviceDefinitionOption is a functional option for configuring a DeviceDefinition.
type DeviceDefinitionOption func(*DeviceDefinition)

// NewDeviceDefinition creates a new DeviceDefinition with the given options.
func NewDeviceDefinition(opts ...DeviceDefinitionOption) *DeviceDefinition {
	r := &DeviceDefinition{}
	for _, opt := range opts {
		opt(r)
	}
	return r
}

// WithDeviceDefinitionId sets the Id field.
func WithDeviceDefinitionId(v string) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.Id = &v
	}
}

// WithDeviceDefinitionMeta sets the Meta field.
func WithDeviceDefinitionMeta(v Meta) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.Meta = &v
	}
}

// WithDeviceDefinitionImplicitRules sets the ImplicitRules field.
func WithDeviceDefinitionImplicitRules(v string) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.ImplicitRules = &v
	}
}

// WithDeviceDefinitionLanguage sets the Language field.
func WithDeviceDefinitionLanguage(v string) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.Language = &v
	}
}

// WithDeviceDefinitionText sets the Text field.
func WithDeviceDefinitionText(v Narrative) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.Text = &v
	}
}

// WithDeviceDefinitionContained adds a Contained to the DeviceDefinition.
func WithDeviceDefinitionContained(v Resource) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.Contained = append(r.Contained, v)
	}
}

// WithDeviceDefinitionExtension adds a Extension to the DeviceDefinition.
func WithDeviceDefinitionExtension(v Extension) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.Extension = append(r.Extension, v)
	}
}

// WithDeviceDefinitionModifierExtension adds a ModifierExtension to the DeviceDefinition.
func WithDeviceDefinitionModifierExtension(v Extension) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.ModifierExtension = append(r.ModifierExtension, v)
	}
}

// WithDeviceDefinitionDescription sets the Description field.
func WithDeviceDefinitionDescription(v string) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.Description = &v
	}
}

// WithDeviceDefinitionIdentifier adds a Identifier to the DeviceDefinition.
func WithDeviceDefinitionIdentifier(v Identifier) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.Identifier = append(r.Identifier, v)
	}
}

// WithDeviceDefinitionUdiDeviceIdentifier adds a UdiDeviceIdentifier to the DeviceDefinition.
func WithDeviceDefinitionUdiDeviceIdentifier(v DeviceDefinitionUdiDeviceIdentifier) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.UdiDeviceIdentifier = append(r.UdiDeviceIdentifier, v)
	}
}

// WithDeviceDefinitionRegulatoryIdentifier adds a RegulatoryIdentifier to the DeviceDefinition.
func WithDeviceDefinitionRegulatoryIdentifier(v DeviceDefinitionRegulatoryIdentifier) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.RegulatoryIdentifier = append(r.RegulatoryIdentifier, v)
	}
}

// WithDeviceDefinitionPartNumber sets the PartNumber field.
func WithDeviceDefinitionPartNumber(v string) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.PartNumber = &v
	}
}

// WithDeviceDefinitionManufacturer sets the Manufacturer field.
func WithDeviceDefinitionManufacturer(v Reference) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.Manufacturer = &v
	}
}

// WithDeviceDefinitionDeviceName adds a DeviceName to the DeviceDefinition.
func WithDeviceDefinitionDeviceName(v DeviceDefinitionDeviceName) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.DeviceName = append(r.DeviceName, v)
	}
}

// WithDeviceDefinitionModelNumber sets the ModelNumber field.
func WithDeviceDefinitionModelNumber(v string) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.ModelNumber = &v
	}
}

// WithDeviceDefinitionClassification adds a Classification to the DeviceDefinition.
func WithDeviceDefinitionClassification(v DeviceDefinitionClassification) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.Classification = append(r.Classification, v)
	}
}

// WithDeviceDefinitionConformsTo adds a ConformsTo to the DeviceDefinition.
func WithDeviceDefinitionConformsTo(v DeviceDefinitionConformsTo) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.ConformsTo = append(r.ConformsTo, v)
	}
}

// WithDeviceDefinitionHasPart adds a HasPart to the DeviceDefinition.
func WithDeviceDefinitionHasPart(v DeviceDefinitionHasPart) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.HasPart = append(r.HasPart, v)
	}
}

// WithDeviceDefinitionPackaging adds a Packaging to the DeviceDefinition.
func WithDeviceDefinitionPackaging(v DeviceDefinitionPackaging) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.Packaging = append(r.Packaging, v)
	}
}

// WithDeviceDefinitionVersion adds a Version to the DeviceDefinition.
func WithDeviceDefinitionVersion(v DeviceDefinitionVersion) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.Version = append(r.Version, v)
	}
}

// WithDeviceDefinitionSafety adds a Safety to the DeviceDefinition.
func WithDeviceDefinitionSafety(v CodeableConcept) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.Safety = append(r.Safety, v)
	}
}

// WithDeviceDefinitionShelfLifeStorage adds a ShelfLifeStorage to the DeviceDefinition.
func WithDeviceDefinitionShelfLifeStorage(v ProductShelfLife) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.ShelfLifeStorage = append(r.ShelfLifeStorage, v)
	}
}

// WithDeviceDefinitionLanguageCode adds a LanguageCode to the DeviceDefinition.
func WithDeviceDefinitionLanguageCode(v CodeableConcept) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.LanguageCode = append(r.LanguageCode, v)
	}
}

// WithDeviceDefinitionProperty adds a Property to the DeviceDefinition.
func WithDeviceDefinitionProperty(v DeviceDefinitionProperty) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.Property = append(r.Property, v)
	}
}

// WithDeviceDefinitionOwner sets the Owner field.
func WithDeviceDefinitionOwner(v Reference) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.Owner = &v
	}
}

// WithDeviceDefinitionContact adds a Contact to the DeviceDefinition.
func WithDeviceDefinitionContact(v ContactPoint) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.Contact = append(r.Contact, v)
	}
}

// WithDeviceDefinitionLink adds a Link to the DeviceDefinition.
func WithDeviceDefinitionLink(v DeviceDefinitionLink) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.Link = append(r.Link, v)
	}
}

// WithDeviceDefinitionNote adds a Note to the DeviceDefinition.
func WithDeviceDefinitionNote(v Annotation) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.Note = append(r.Note, v)
	}
}

// WithDeviceDefinitionMaterial adds a Material to the DeviceDefinition.
func WithDeviceDefinitionMaterial(v DeviceDefinitionMaterial) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.Material = append(r.Material, v)
	}
}

// WithDeviceDefinitionProductionIdentifierInUDI adds a ProductionIdentifierInUDI to the DeviceDefinition.
func WithDeviceDefinitionProductionIdentifierInUDI(v DeviceProductionIdentifierInUDI) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.ProductionIdentifierInUDI = append(r.ProductionIdentifierInUDI, v)
	}
}

// WithDeviceDefinitionGuideline sets the Guideline field.
func WithDeviceDefinitionGuideline(v DeviceDefinitionGuideline) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.Guideline = &v
	}
}

// WithDeviceDefinitionCorrectiveAction sets the CorrectiveAction field.
func WithDeviceDefinitionCorrectiveAction(v DeviceDefinitionCorrectiveAction) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.CorrectiveAction = &v
	}
}

// WithDeviceDefinitionChargeItem adds a ChargeItem to the DeviceDefinition.
func WithDeviceDefinitionChargeItem(v DeviceDefinitionChargeItem) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.ChargeItem = append(r.ChargeItem, v)
	}
}
