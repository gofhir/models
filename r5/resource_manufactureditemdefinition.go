// Code generated by gofhir. DO NOT EDIT.
// Source: FHIR StructureDefinitions (consolidated resource)
// Package: r5

package r5

import (
	"bytes"
	"encoding/json"
	"encoding/xml"
	"fmt"
)

// =============================================================================
// ManufacturedItemDefinition Resource
// =============================================================================

// ManufacturedItemDefinition represents FHIR ManufacturedItemDefinition.
type ManufacturedItemDefinition struct {
	// FHIR resource type
	ResourceType string `json:"resourceType"`
	// Logical id of this artifact
	Id *string `json:"id,omitempty"`
	// Metadata about the resource
	Meta *Meta `json:"meta,omitempty"`
	// A set of rules under which this content was created
	ImplicitRules *string `json:"implicitRules,omitempty"`
	// Extension for ImplicitRules
	ImplicitRulesExt *Element `json:"_implicitRules,omitempty"`
	// Language of the resource content
	Language *string `json:"language,omitempty"`
	// Extension for Language
	LanguageExt *Element `json:"_language,omitempty"`
	// Text summary of the resource, for human interpretation
	Text *Narrative `json:"text,omitempty"`
	// Contained, inline Resources
	Contained []Resource `json:"contained,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Unique identifier
	Identifier []Identifier `json:"identifier,omitempty"`
	// draft | active | retired | unknown
	Status *PublicationStatus `json:"status,omitempty"`
	// Extension for Status
	StatusExt *Element `json:"_status,omitempty"`
	// A descriptive name applied to this item
	Name *string `json:"name,omitempty"`
	// Extension for Name
	NameExt *Element `json:"_name,omitempty"`
	// Dose form as manufactured (before any necessary transformation)
	ManufacturedDoseForm CodeableConcept `json:"manufacturedDoseForm"`
	// The “real-world” units in which the quantity of the item is described
	UnitOfPresentation *CodeableConcept `json:"unitOfPresentation,omitempty"`
	// Manufacturer of the item, one of several possible
	Manufacturer []Reference `json:"manufacturer,omitempty"`
	// Allows specifying that an item is on the market for sale, or that it is not available, and the dates and locations associated
	MarketingStatus []MarketingStatus `json:"marketingStatus,omitempty"`
	// The ingredients of this manufactured item. Only needed if these are not specified by incoming references from the Ingredient resource
	Ingredient []CodeableConcept `json:"ingredient,omitempty"`
	// General characteristics of this item
	Property []ManufacturedItemDefinitionProperty `json:"property,omitempty"`
	// Physical parts of the manufactured item, that it is intrisically made from. This is distinct from the ingredients that are part of its chemical makeup
	Component []ManufacturedItemDefinitionComponent `json:"component,omitempty"`
}

// GetResourceType returns the FHIR resource type.
func (r *ManufacturedItemDefinition) GetResourceType() string {
	return "ManufacturedItemDefinition"
}

// GetId returns the resource's logical ID.
func (r *ManufacturedItemDefinition) GetId() *string {
	return r.Id
}

// SetId sets the resource's logical ID.
func (r *ManufacturedItemDefinition) SetId(id string) {
	r.Id = &id
}

// GetMeta returns the resource's Meta element.
func (r *ManufacturedItemDefinition) GetMeta() *Meta {
	return r.Meta
}

// SetMeta sets the resource's Meta element.
func (r *ManufacturedItemDefinition) SetMeta(m *Meta) {
	r.Meta = m
}

// GetText returns the resource's narrative text.
func (r *ManufacturedItemDefinition) GetText() *Narrative {
	return r.Text
}

// SetText sets the resource's narrative text.
func (r *ManufacturedItemDefinition) SetText(t *Narrative) {
	r.Text = t
}

// GetContained returns the resource's contained resources.
func (r *ManufacturedItemDefinition) GetContained() []Resource {
	return r.Contained
}

// GetExtension returns the resource's extensions.
func (r *ManufacturedItemDefinition) GetExtension() []Extension {
	return r.Extension
}

// GetModifierExtension returns the resource's modifier extensions.
func (r *ManufacturedItemDefinition) GetModifierExtension() []Extension {
	return r.ModifierExtension
}

// MarshalJSON ensures resourceType is always included in JSON output.
// HTML escaping is disabled to preserve FHIR narrative XHTML content.
//
// Note: Use the package-level Marshal function instead of json.Marshal
// to ensure HTML in narrative text.div fields is not escaped.
func (r ManufacturedItemDefinition) MarshalJSON() ([]byte, error) {
	r.ResourceType = "ManufacturedItemDefinition"
	type Alias ManufacturedItemDefinition
	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	enc.SetEscapeHTML(false)
	if err := enc.Encode((Alias)(r)); err != nil {
		return nil, err
	}
	b := buf.Bytes()
	if len(b) > 0 && b[len(b)-1] == '\n' {
		b = b[:len(b)-1]
	}
	return b, nil
}

// UnmarshalJSON handles deserialization of polymorphic contained resources.
func (r *ManufacturedItemDefinition) UnmarshalJSON(data []byte) error {
	// Use an alias to avoid infinite recursion
	type Alias ManufacturedItemDefinition
	aux := &struct {
		Contained []json.RawMessage `json:"contained,omitempty"`
		*Alias
	}{
		Alias: (*Alias)(r),
	}

	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}

	// Unmarshal each contained resource using the dispatcher
	if len(aux.Contained) > 0 {
		r.Contained = make([]Resource, len(aux.Contained))
		for i, raw := range aux.Contained {
			resource, err := UnmarshalResource(raw)
			if err != nil {
				return fmt.Errorf("failed to unmarshal contained[%d]: %w", i, err)
			}
			r.Contained[i] = resource
		}
	}

	return nil
}

// MarshalXML serializes ManufacturedItemDefinition to FHIR-conformant XML.
func (r ManufacturedItemDefinition) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "ManufacturedItemDefinition"
		start.Name.Space = fhirNamespace
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	if err := xmlEncodePrimitiveString(e, "id", r.Id, nil); err != nil {
		return err
	}
	if r.Meta != nil {
		if err := r.Meta.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "meta"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "implicitRules", r.ImplicitRules, r.ImplicitRulesExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "language", r.Language, r.LanguageExt); err != nil {
		return err
	}
	if r.Text != nil {
		if err := r.Text.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "text"}}); err != nil {
			return err
		}
	}
	for _, c := range r.Contained {
		if c != nil {
			if err := xmlEncodeContainedResource(e, c); err != nil {
				return err
			}
		}
	}
	for _, item := range r.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range r.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Identifier {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "identifier"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveCode(e, "status", r.Status, r.StatusExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "name", r.Name, r.NameExt); err != nil {
		return err
	}
	if err := r.ManufacturedDoseForm.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "manufacturedDoseForm"}}); err != nil {
		return err
	}
	if r.UnitOfPresentation != nil {
		if err := r.UnitOfPresentation.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "unitOfPresentation"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Manufacturer {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "manufacturer"}}); err != nil {
			return err
		}
	}
	for _, item := range r.MarketingStatus {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "marketingStatus"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Ingredient {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "ingredient"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Property {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "property"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Component {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "component"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes ManufacturedItemDefinition from FHIR-conformant XML.
func (r *ManufacturedItemDefinition) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "id":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Id = v
			case "meta":
				var v Meta
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Meta = &v
			case "implicitRules":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ImplicitRules = v
				r.ImplicitRulesExt = ext
			case "language":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Language = v
				r.LanguageExt = ext
			case "text":
				var v Narrative
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Text = &v
			case "contained":
				res, err := xmlDecodeContainedResource(d, t)
				if err != nil {
					return err
				}
				if res != nil {
					r.Contained = append(r.Contained, res)
				}
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "identifier":
				var v Identifier
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Identifier = append(r.Identifier, v)
			case "status":
				v, ext, err := xmlDecodePrimitiveCode[PublicationStatus](d, t)
				if err != nil {
					return err
				}
				r.Status = v
				r.StatusExt = ext
			case "name":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Name = v
				r.NameExt = ext
			case "manufacturedDoseForm":
				if err := r.ManufacturedDoseForm.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "unitOfPresentation":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.UnitOfPresentation = &v
			case "manufacturer":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Manufacturer = append(r.Manufacturer, v)
			case "marketingStatus":
				var v MarketingStatus
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.MarketingStatus = append(r.MarketingStatus, v)
			case "ingredient":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Ingredient = append(r.Ingredient, v)
			case "property":
				var v ManufacturedItemDefinitionProperty
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Property = append(r.Property, v)
			case "component":
				var v ManufacturedItemDefinitionComponent
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Component = append(r.Component, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// ManufacturedItemDefinitionComponent represents the ManufacturedItemDefinition.component backbone element.
// Physical parts of the manufactured item, that it is intrisically made from. This is distinct from the ingredients that are part of its chemical makeup
type ManufacturedItemDefinitionComponent struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Defining type of the component e.g. shell, layer, ink
	Type CodeableConcept `json:"type,omitempty"`
	// The function of this component within the item e.g. delivers active ingredient, masks taste
	Function []CodeableConcept `json:"function,omitempty"`
	// The measurable amount of total quantity of all substances in the component, expressable in different ways (e.g. by mass or volume)
	Amount []Quantity `json:"amount,omitempty"`
	// A reference to a constituent of the manufactured item as a whole, linked here so that its component location within the item can be indicated. This not where the item's ingredient are primarily stated (for which see Ingredient.for or ManufacturedItemDefinition.ingredient)
	Constituent []ManufacturedItemDefinitionComponentConstituent `json:"constituent,omitempty"`
	// General characteristics of this component
	Property []ManufacturedItemDefinitionProperty `json:"property,omitempty"`
	// A component that this component contains or is made from
	Component []ManufacturedItemDefinitionComponent `json:"component,omitempty"`
}

// MarshalXML serializes ManufacturedItemDefinitionComponent to FHIR-conformant XML.
func (b ManufacturedItemDefinitionComponent) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "ManufacturedItemDefinition.component"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
		return err
	}
	for _, item := range b.Function {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "function"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Amount {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "amount"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Constituent {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "constituent"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Property {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "property"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Component {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "component"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes ManufacturedItemDefinitionComponent from FHIR-conformant XML.
func (r *ManufacturedItemDefinitionComponent) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "type":
				if err := r.Type.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "function":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Function = append(r.Function, v)
			case "amount":
				var v Quantity
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Amount = append(r.Amount, v)
			case "constituent":
				var v ManufacturedItemDefinitionComponentConstituent
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Constituent = append(r.Constituent, v)
			case "property":
				var v ManufacturedItemDefinitionProperty
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Property = append(r.Property, v)
			case "component":
				var v ManufacturedItemDefinitionComponent
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Component = append(r.Component, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// ManufacturedItemDefinitionComponentConstituent represents the ManufacturedItemDefinition.component.constituent backbone element.
// A reference to a constituent of the manufactured item as a whole, linked here so that its component location within the item can be indicated. This not where the item's ingredient are primarily stated (for which see Ingredient.for or ManufacturedItemDefinition.ingredient)
type ManufacturedItemDefinitionComponentConstituent struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The measurable amount of the substance, expressable in different ways (e.g. by mass or volume)
	Amount []Quantity `json:"amount,omitempty"`
	// The physical location of the constituent/ingredient within the component
	Location []CodeableConcept `json:"location,omitempty"`
	// The function of this constituent within the component e.g. binder
	Function []CodeableConcept `json:"function,omitempty"`
	// The ingredient that is the constituent of the given component
	HasIngredient []CodeableReference `json:"hasIngredient,omitempty"`
}

// MarshalXML serializes ManufacturedItemDefinitionComponentConstituent to FHIR-conformant XML.
func (b ManufacturedItemDefinitionComponentConstituent) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "ManufacturedItemDefinition.component.constituent"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Amount {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "amount"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Location {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "location"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Function {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "function"}}); err != nil {
			return err
		}
	}
	for _, item := range b.HasIngredient {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "hasIngredient"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes ManufacturedItemDefinitionComponentConstituent from FHIR-conformant XML.
func (r *ManufacturedItemDefinitionComponentConstituent) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "amount":
				var v Quantity
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Amount = append(r.Amount, v)
			case "location":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Location = append(r.Location, v)
			case "function":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Function = append(r.Function, v)
			case "hasIngredient":
				var v CodeableReference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.HasIngredient = append(r.HasIngredient, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// ManufacturedItemDefinitionProperty represents the ManufacturedItemDefinition.property backbone element.
// General characteristics of this item
type ManufacturedItemDefinitionProperty struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// A code expressing the type of characteristic
	Type CodeableConcept `json:"type,omitempty"`
	// A value for the characteristic
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`
	// A value for the characteristic
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`
	// A value for the characteristic
	ValueDate *string `json:"valueDate,omitempty"`
	// Extension for ValueDate
	ValueDateExt *Element `json:"_valueDate,omitempty"`
	// A value for the characteristic
	ValueBoolean *bool `json:"valueBoolean,omitempty"`
	// Extension for ValueBoolean
	ValueBooleanExt *Element `json:"_valueBoolean,omitempty"`
	// A value for the characteristic
	ValueMarkdown *string `json:"valueMarkdown,omitempty"`
	// Extension for ValueMarkdown
	ValueMarkdownExt *Element `json:"_valueMarkdown,omitempty"`
	// A value for the characteristic
	ValueAttachment *Attachment `json:"valueAttachment,omitempty"`
	// A value for the characteristic
	ValueReference *Reference `json:"valueReference,omitempty"`
}

// MarshalXML serializes ManufacturedItemDefinitionProperty to FHIR-conformant XML.
func (b ManufacturedItemDefinitionProperty) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "ManufacturedItemDefinition.property"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
		return err
	}
	if b.ValueCodeableConcept != nil {
		if err := b.ValueCodeableConcept.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueCodeableConcept"}}); err != nil {
			return err
		}
	}
	if b.ValueQuantity != nil {
		if err := b.ValueQuantity.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueQuantity"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "valueDate", b.ValueDate, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveBool(e, "valueBoolean", b.ValueBoolean, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "valueMarkdown", b.ValueMarkdown, nil); err != nil {
		return err
	}
	if b.ValueAttachment != nil {
		if err := b.ValueAttachment.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueAttachment"}}); err != nil {
			return err
		}
	}
	if b.ValueReference != nil {
		if err := b.ValueReference.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueReference"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes ManufacturedItemDefinitionProperty from FHIR-conformant XML.
func (r *ManufacturedItemDefinitionProperty) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "type":
				if err := r.Type.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "valueCodeableConcept":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueCodeableConcept = &v
			case "valueQuantity":
				var v Quantity
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueQuantity = &v
			case "valueDate":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ValueDate = v
			case "valueBoolean":
				v, _, err := xmlDecodePrimitiveBool(d, t)
				if err != nil {
					return err
				}
				r.ValueBoolean = v
			case "valueMarkdown":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ValueMarkdown = v
			case "valueAttachment":
				var v Attachment
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueAttachment = &v
			case "valueReference":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueReference = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// =============================================================================
// ManufacturedItemDefinition - Fluent Builder
// =============================================================================

// ManufacturedItemDefinitionBuilder provides a fluent API for constructing ManufacturedItemDefinition resources.
type ManufacturedItemDefinitionBuilder struct {
	manufacturedItemDefinition *ManufacturedItemDefinition
}

// NewManufacturedItemDefinitionBuilder creates a new ManufacturedItemDefinitionBuilder.
func NewManufacturedItemDefinitionBuilder() *ManufacturedItemDefinitionBuilder {
	return &ManufacturedItemDefinitionBuilder{
		manufacturedItemDefinition: &ManufacturedItemDefinition{},
	}
}

// Build returns the constructed ManufacturedItemDefinition resource.
func (b *ManufacturedItemDefinitionBuilder) Build() *ManufacturedItemDefinition {
	return b.manufacturedItemDefinition
}

// SetId sets the Id field.
func (b *ManufacturedItemDefinitionBuilder) SetId(v string) *ManufacturedItemDefinitionBuilder {
	b.manufacturedItemDefinition.Id = &v
	return b
}

// SetMeta sets the Meta field.
func (b *ManufacturedItemDefinitionBuilder) SetMeta(v Meta) *ManufacturedItemDefinitionBuilder {
	b.manufacturedItemDefinition.Meta = &v
	return b
}

// SetImplicitRules sets the ImplicitRules field.
func (b *ManufacturedItemDefinitionBuilder) SetImplicitRules(v string) *ManufacturedItemDefinitionBuilder {
	b.manufacturedItemDefinition.ImplicitRules = &v
	return b
}

// SetLanguage sets the Language field.
func (b *ManufacturedItemDefinitionBuilder) SetLanguage(v string) *ManufacturedItemDefinitionBuilder {
	b.manufacturedItemDefinition.Language = &v
	return b
}

// SetText sets the Text field.
func (b *ManufacturedItemDefinitionBuilder) SetText(v Narrative) *ManufacturedItemDefinitionBuilder {
	b.manufacturedItemDefinition.Text = &v
	return b
}

// AddContained adds a Contained element.
func (b *ManufacturedItemDefinitionBuilder) AddContained(v Resource) *ManufacturedItemDefinitionBuilder {
	b.manufacturedItemDefinition.Contained = append(b.manufacturedItemDefinition.Contained, v)
	return b
}

// AddExtension adds a Extension element.
func (b *ManufacturedItemDefinitionBuilder) AddExtension(v Extension) *ManufacturedItemDefinitionBuilder {
	b.manufacturedItemDefinition.Extension = append(b.manufacturedItemDefinition.Extension, v)
	return b
}

// AddModifierExtension adds a ModifierExtension element.
func (b *ManufacturedItemDefinitionBuilder) AddModifierExtension(v Extension) *ManufacturedItemDefinitionBuilder {
	b.manufacturedItemDefinition.ModifierExtension = append(b.manufacturedItemDefinition.ModifierExtension, v)
	return b
}

// AddIdentifier adds a Identifier element.
func (b *ManufacturedItemDefinitionBuilder) AddIdentifier(v Identifier) *ManufacturedItemDefinitionBuilder {
	b.manufacturedItemDefinition.Identifier = append(b.manufacturedItemDefinition.Identifier, v)
	return b
}

// SetStatus sets the Status field.
func (b *ManufacturedItemDefinitionBuilder) SetStatus(v PublicationStatus) *ManufacturedItemDefinitionBuilder {
	b.manufacturedItemDefinition.Status = &v
	return b
}

// SetName sets the Name field.
func (b *ManufacturedItemDefinitionBuilder) SetName(v string) *ManufacturedItemDefinitionBuilder {
	b.manufacturedItemDefinition.Name = &v
	return b
}

// SetManufacturedDoseForm sets the ManufacturedDoseForm field.
func (b *ManufacturedItemDefinitionBuilder) SetManufacturedDoseForm(v CodeableConcept) *ManufacturedItemDefinitionBuilder {
	b.manufacturedItemDefinition.ManufacturedDoseForm = v
	return b
}

// SetUnitOfPresentation sets the UnitOfPresentation field.
func (b *ManufacturedItemDefinitionBuilder) SetUnitOfPresentation(v CodeableConcept) *ManufacturedItemDefinitionBuilder {
	b.manufacturedItemDefinition.UnitOfPresentation = &v
	return b
}

// AddManufacturer adds a Manufacturer element.
func (b *ManufacturedItemDefinitionBuilder) AddManufacturer(v Reference) *ManufacturedItemDefinitionBuilder {
	b.manufacturedItemDefinition.Manufacturer = append(b.manufacturedItemDefinition.Manufacturer, v)
	return b
}

// AddMarketingStatus adds a MarketingStatus element.
func (b *ManufacturedItemDefinitionBuilder) AddMarketingStatus(v MarketingStatus) *ManufacturedItemDefinitionBuilder {
	b.manufacturedItemDefinition.MarketingStatus = append(b.manufacturedItemDefinition.MarketingStatus, v)
	return b
}

// AddIngredient adds a Ingredient element.
func (b *ManufacturedItemDefinitionBuilder) AddIngredient(v CodeableConcept) *ManufacturedItemDefinitionBuilder {
	b.manufacturedItemDefinition.Ingredient = append(b.manufacturedItemDefinition.Ingredient, v)
	return b
}

// AddProperty adds a Property element.
func (b *ManufacturedItemDefinitionBuilder) AddProperty(v ManufacturedItemDefinitionProperty) *ManufacturedItemDefinitionBuilder {
	b.manufacturedItemDefinition.Property = append(b.manufacturedItemDefinition.Property, v)
	return b
}

// AddComponent adds a Component element.
func (b *ManufacturedItemDefinitionBuilder) AddComponent(v ManufacturedItemDefinitionComponent) *ManufacturedItemDefinitionBuilder {
	b.manufacturedItemDefinition.Component = append(b.manufacturedItemDefinition.Component, v)
	return b
}

// =============================================================================
// ManufacturedItemDefinition - Functional Options
// =============================================================================

// ManufacturedItemDefinitionOption is a functional option for configuring a ManufacturedItemDefinition.
type ManufacturedItemDefinitionOption func(*ManufacturedItemDefinition)

// NewManufacturedItemDefinition creates a new ManufacturedItemDefinition with the given options.
func NewManufacturedItemDefinition(opts ...ManufacturedItemDefinitionOption) *ManufacturedItemDefinition {
	r := &ManufacturedItemDefinition{}
	for _, opt := range opts {
		opt(r)
	}
	return r
}

// WithManufacturedItemDefinitionId sets the Id field.
func WithManufacturedItemDefinitionId(v string) ManufacturedItemDefinitionOption {
	return func(r *ManufacturedItemDefinition) {
		r.Id = &v
	}
}

// WithManufacturedItemDefinitionMeta sets the Meta field.
func WithManufacturedItemDefinitionMeta(v Meta) ManufacturedItemDefinitionOption {
	return func(r *ManufacturedItemDefinition) {
		r.Meta = &v
	}
}

// WithManufacturedItemDefinitionImplicitRules sets the ImplicitRules field.
func WithManufacturedItemDefinitionImplicitRules(v string) ManufacturedItemDefinitionOption {
	return func(r *ManufacturedItemDefinition) {
		r.ImplicitRules = &v
	}
}

// WithManufacturedItemDefinitionLanguage sets the Language field.
func WithManufacturedItemDefinitionLanguage(v string) ManufacturedItemDefinitionOption {
	return func(r *ManufacturedItemDefinition) {
		r.Language = &v
	}
}

// WithManufacturedItemDefinitionText sets the Text field.
func WithManufacturedItemDefinitionText(v Narrative) ManufacturedItemDefinitionOption {
	return func(r *ManufacturedItemDefinition) {
		r.Text = &v
	}
}

// WithManufacturedItemDefinitionContained adds a Contained to the ManufacturedItemDefinition.
func WithManufacturedItemDefinitionContained(v Resource) ManufacturedItemDefinitionOption {
	return func(r *ManufacturedItemDefinition) {
		r.Contained = append(r.Contained, v)
	}
}

// WithManufacturedItemDefinitionExtension adds a Extension to the ManufacturedItemDefinition.
func WithManufacturedItemDefinitionExtension(v Extension) ManufacturedItemDefinitionOption {
	return func(r *ManufacturedItemDefinition) {
		r.Extension = append(r.Extension, v)
	}
}

// WithManufacturedItemDefinitionModifierExtension adds a ModifierExtension to the ManufacturedItemDefinition.
func WithManufacturedItemDefinitionModifierExtension(v Extension) ManufacturedItemDefinitionOption {
	return func(r *ManufacturedItemDefinition) {
		r.ModifierExtension = append(r.ModifierExtension, v)
	}
}

// WithManufacturedItemDefinitionIdentifier adds a Identifier to the ManufacturedItemDefinition.
func WithManufacturedItemDefinitionIdentifier(v Identifier) ManufacturedItemDefinitionOption {
	return func(r *ManufacturedItemDefinition) {
		r.Identifier = append(r.Identifier, v)
	}
}

// WithManufacturedItemDefinitionStatus sets the Status field.
func WithManufacturedItemDefinitionStatus(v PublicationStatus) ManufacturedItemDefinitionOption {
	return func(r *ManufacturedItemDefinition) {
		r.Status = &v
	}
}

// WithManufacturedItemDefinitionName sets the Name field.
func WithManufacturedItemDefinitionName(v string) ManufacturedItemDefinitionOption {
	return func(r *ManufacturedItemDefinition) {
		r.Name = &v
	}
}

// WithManufacturedItemDefinitionManufacturedDoseForm sets the ManufacturedDoseForm field.
func WithManufacturedItemDefinitionManufacturedDoseForm(v CodeableConcept) ManufacturedItemDefinitionOption {
	return func(r *ManufacturedItemDefinition) {
		r.ManufacturedDoseForm = v
	}
}

// WithManufacturedItemDefinitionUnitOfPresentation sets the UnitOfPresentation field.
func WithManufacturedItemDefinitionUnitOfPresentation(v CodeableConcept) ManufacturedItemDefinitionOption {
	return func(r *ManufacturedItemDefinition) {
		r.UnitOfPresentation = &v
	}
}

// WithManufacturedItemDefinitionManufacturer adds a Manufacturer to the ManufacturedItemDefinition.
func WithManufacturedItemDefinitionManufacturer(v Reference) ManufacturedItemDefinitionOption {
	return func(r *ManufacturedItemDefinition) {
		r.Manufacturer = append(r.Manufacturer, v)
	}
}

// WithManufacturedItemDefinitionMarketingStatus adds a MarketingStatus to the ManufacturedItemDefinition.
func WithManufacturedItemDefinitionMarketingStatus(v MarketingStatus) ManufacturedItemDefinitionOption {
	return func(r *ManufacturedItemDefinition) {
		r.MarketingStatus = append(r.MarketingStatus, v)
	}
}

// WithManufacturedItemDefinitionIngredient adds a Ingredient to the ManufacturedItemDefinition.
func WithManufacturedItemDefinitionIngredient(v CodeableConcept) ManufacturedItemDefinitionOption {
	return func(r *ManufacturedItemDefinition) {
		r.Ingredient = append(r.Ingredient, v)
	}
}

// WithManufacturedItemDefinitionProperty adds a Property to the ManufacturedItemDefinition.
func WithManufacturedItemDefinitionProperty(v ManufacturedItemDefinitionProperty) ManufacturedItemDefinitionOption {
	return func(r *ManufacturedItemDefinition) {
		r.Property = append(r.Property, v)
	}
}

// WithManufacturedItemDefinitionComponent adds a Component to the ManufacturedItemDefinition.
func WithManufacturedItemDefinitionComponent(v ManufacturedItemDefinitionComponent) ManufacturedItemDefinitionOption {
	return func(r *ManufacturedItemDefinition) {
		r.Component = append(r.Component, v)
	}
}
