{{- /* Template for generating a single consolidated datatypes file:
     all datatype structs + backbone structs + XML marshal/unmarshal */ -}}
// Code generated by gofhir. DO NOT EDIT.
// Source: FHIR StructureDefinitions (consolidated datatypes)
// Package: {{.PackageName}}

package {{.PackageName}}

{{- /* Check if any backbone has a Resource field to determine if we need fmt/json imports */ -}}
{{- $needsJSON := false -}}
{{- range .Backbones -}}
{{- range .Properties -}}
{{- if eq .GoType "Resource" -}}
{{- $needsJSON = true -}}
{{- end -}}
{{- end -}}
{{- end }}

import (
	"encoding/xml"
{{- if $needsJSON }}
	"encoding/json"
	"fmt"
{{- end }}
)

// =============================================================================
// Datatype Struct Definitions
// =============================================================================

{{range .Types}}
{{if .Description}}// {{.Name}} {{.Description}}
{{else}}// {{.Name}} represents FHIR {{.FHIRName}}.
{{end -}}
type {{.Name}} struct {
{{- range .Properties}}
	{{if .Description}}// {{.Description}}
	{{end -}}
	{{.Name}} {{.GoType}} `json:"{{.JSONName}}{{if or .IsArray .IsPointer}},omitempty{{end}}"`
	{{- if and .HasExtension (not .IsChoice)}}
	// Extension for {{.Name}}
	{{- if .IsArray}}
	{{.Name}}Ext []Element `json:"_{{.JSONName}},omitempty"`
	{{- else}}
	{{.Name}}Ext *Element `json:"_{{.JSONName}},omitempty"`
	{{- end}}
	{{- end}}
{{- end}}
}

{{end}}

{{- /* ================================================================== */ -}}
{{- /* Backbone Struct Definitions (for datatypes with nested backbones)   */ -}}
{{- /* ================================================================== */ -}}

{{range .Backbones}}
{{- /* Check if this backbone has a Resource field */ -}}
{{- $hasResourceField := false -}}
{{- $resourceFieldName := "" -}}
{{- $resourceJSONName := "" -}}
{{- range .Properties -}}
{{- if eq .GoType "Resource" -}}
{{- $hasResourceField = true -}}
{{- $resourceFieldName = .Name -}}
{{- $resourceJSONName = .JSONName -}}
{{- end -}}
{{- end -}}

// {{.Name}} represents the {{.FHIRName}} backbone element.
{{- if .Description}}
// {{.Description}}
{{- end}}
type {{.Name}} struct {
{{- range .Properties}}
	{{- if .Description}}
	// {{.Description}}
	{{- end}}
	{{.Name}} {{.GoType}} `json:"{{.JSONName}},omitempty"`
{{- end}}
}

{{- if $hasResourceField }}

// UnmarshalJSON handles deserialization of polymorphic resource field.
func (b *{{.Name}}) UnmarshalJSON(data []byte) error {
	type Alias {{.Name}}
	aux := &struct {
		{{$resourceFieldName}} json.RawMessage `json:"{{$resourceJSONName}},omitempty"`
		*Alias
	}{
		Alias: (*Alias)(b),
	}

	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}

	if len(aux.{{$resourceFieldName}}) > 0 {
		resource, err := UnmarshalResource(aux.{{$resourceFieldName}})
		if err != nil {
			return fmt.Errorf("failed to unmarshal {{$resourceJSONName}}: %w", err)
		}
		b.{{$resourceFieldName}} = resource
	}

	return nil
}
{{- end }}

{{end}}

// =============================================================================
// Datatype XML Serialization
// =============================================================================

{{range .Types}}
{{- $typeName := .Name -}}
// MarshalXML serializes {{.Name}} to FHIR-conformant XML.
func (d {{.Name}}) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "{{.FHIRName}}"
	}
{{- /* On datatypes, "id" is an XML attribute, not a child element */ -}}
{{- if hasIdField .}}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
{{- end}}
{{- /* On Extension, "url" is an XML attribute */ -}}
{{- if eq .Name "Extension"}}
	if d.Url != "" {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "url"}, Value: d.Url})
	}
{{- end}}
	if err := e.EncodeToken(start); err != nil {
		return err
	}
{{range .Properties}}
{{- /* Skip id - already handled as XML attribute above */ -}}
{{- if eq .JSONName "id"}}{{continue}}{{end}}
{{- /* Skip url on Extension - already handled as XML attribute above */ -}}
{{- if and (eq .JSONName "url") (eq $typeName "Extension")}}{{continue}}{{end}}
{{- /* Skip _field extension companions - consumed by their parent primitive */ -}}
{{- if isExtField . }}{{continue}}{{end}}
{{- /* Contained resources (MetadataResource and similar) */ -}}
{{- if eq .JSONName "contained"}}
	for _, c := range d.Contained {
		if c != nil {
			if err := xmlEncodeContainedResource(e, c); err != nil {
				return err
			}
		}
	}
{{- /* Raw XHTML (Narrative.div) */ -}}
{{- else if and (eq .FHIRType "xhtml") (not .IsArray)}}
	if err := xmlEncodeRawXHTML(e, d.{{.Name}}); err != nil {
		return err
	}
{{- /* Primitive scalars */ -}}
{{- else if and .IsPrimitive (not .IsArray)}}
	if err := {{xmlPrimitiveFunc .GoType}}(e, "{{.JSONName}}", d.{{.Name}}, {{extFieldRef "d" .}}); err != nil {
		return err
	}
{{- /* Primitive arrays */ -}}
{{- else if and .IsPrimitive .IsArray}}
	if err := {{xmlPrimitiveArrayFunc .GoType}}(e, "{{.JSONName}}", d.{{.Name}}, {{extFieldRef "d" .}}); err != nil {
		return err
	}
{{- /* Polymorphic Resource field */ -}}
{{- else if eq .GoType "Resource"}}
	if d.{{.Name}} != nil {
		if err := xmlEncodeInlineResource(e, d.{{.Name}}); err != nil {
			return err
		}
	}
{{- /* Complex type arrays */ -}}
{{- else if .IsArray}}
	for _, item := range d.{{.Name}} {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "{{.JSONName}}"}}); err != nil {
			return err
		}
	}
{{- /* Complex type pointers */ -}}
{{- else if .IsPointer}}
	if d.{{.Name}} != nil {
		if err := d.{{.Name}}.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "{{.JSONName}}"}}); err != nil {
			return err
		}
	}
{{- /* Complex type required (non-pointer) */ -}}
{{- else}}
	if err := d.{{.Name}}.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "{{.JSONName}}"}}); err != nil {
		return err
	}
{{- end}}
{{- end}}

	return e.EncodeToken(start.End())
}

{{end}}

// =============================================================================
// Backbone XML Serialization (for datatype backbones)
// =============================================================================

{{range .Backbones}}
// MarshalXML serializes {{.Name}} to FHIR-conformant XML.
func (b {{.Name}}) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "{{.FHIRName}}"
	}
{{- /* On backbone elements, "id" is an XML attribute, not a child element */ -}}
{{- if hasIdField .}}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
{{- end}}
	if err := e.EncodeToken(start); err != nil {
		return err
	}
{{range .Properties}}
{{- if eq .JSONName "id"}}{{continue}}{{end}}
{{- if isExtField . }}{{continue}}{{end}}
{{- if eq .GoType "Resource"}}
	if b.{{.Name}} != nil {
		if err := xmlEncodeInlineResource(e, b.{{.Name}}); err != nil {
			return err
		}
	}
{{- else if and (eq .FHIRType "xhtml") (not .IsArray)}}
	if err := xmlEncodeRawXHTML(e, b.{{.Name}}); err != nil {
		return err
	}
{{- else if and .IsPrimitive (not .IsArray)}}
	if err := {{xmlPrimitiveFunc .GoType}}(e, "{{.JSONName}}", b.{{.Name}}, nil); err != nil {
		return err
	}
{{- else if and .IsPrimitive .IsArray}}
	if err := {{xmlPrimitiveArrayFunc .GoType}}(e, "{{.JSONName}}", b.{{.Name}}, nil); err != nil {
		return err
	}
{{- else if .IsArray}}
	for _, item := range b.{{.Name}} {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "{{.JSONName}}"}}); err != nil {
			return err
		}
	}
{{- else if .IsPointer}}
	if b.{{.Name}} != nil {
		if err := b.{{.Name}}.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "{{.JSONName}}"}}); err != nil {
			return err
		}
	}
{{- else}}
	if err := b.{{.Name}}.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "{{.JSONName}}"}}); err != nil {
		return err
	}
{{- end}}
{{- end}}

	return e.EncodeToken(start.End())
}

{{end}}

// =============================================================================
// Datatype XML Deserialization
// =============================================================================

{{range .Types}}
{{- $typeName := .Name -}}
// UnmarshalXML deserializes {{.Name}} from FHIR-conformant XML.
func (r *{{.Name}}) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
{{- /* On datatypes, "id" is an XML attribute */ -}}
{{- if hasIdField .}}
	for _, attr := range start.Attr {
{{- if eq .Name "Extension"}}
		switch attr.Name.Local {
		case "id":
			v := attr.Value
			r.Id = &v
		case "url":
			r.Url = attr.Value
		}
{{- else}}
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
{{- end}}
	}
{{- end}}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
{{- range .Properties}}
{{- if eq .JSONName "id"}}{{continue}}{{end}}
{{- if and (eq .JSONName "url") (eq $typeName "Extension")}}{{continue}}{{end}}
{{- if isExtField . }}{{continue}}{{end}}
{{- if eq .JSONName "contained"}}
			case "contained":
				res, err := xmlDecodeContainedResource(dec, t)
				if err != nil {
					return err
				}
				if res != nil {
					r.Contained = append(r.Contained, res)
				}
{{- else if and (eq .FHIRType "xhtml") (not .IsArray)}}
			case "{{.JSONName}}":
				v, err := xmlDecodeRawXHTML(dec, t)
				if err != nil {
					return err
				}
				r.{{.Name}} = v
{{- else if and .IsPrimitive (not .IsArray)}}
			case "{{.JSONName}}":
				v, ext, err := {{xmlPrimitiveDecodeFunc .GoType}}(dec, t)
				if err != nil {
					return err
				}
				r.{{.Name}} = v
{{- if and .HasExtension (not .IsChoice)}}
				r.{{.Name}}Ext = ext
{{- else}}
				_ = ext
{{- end}}
{{- else if and .IsPrimitive .IsArray}}
			case "{{.JSONName}}":
				v, _, err := {{xmlPrimitiveDecodeFunc (elemType .GoType)}}(dec, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.{{.Name}} = append(r.{{.Name}}, *v)
				}
{{- else if eq .GoType "Resource"}}
{{- /* Handled via inline resource in default branch - skip here */ -}}
{{- else if .IsArray}}
			case "{{.JSONName}}":
				var v {{elemType .GoType}}
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.{{.Name}} = append(r.{{.Name}}, v)
{{- else if .IsPointer}}
			case "{{.JSONName}}":
				var v {{derefType .GoType}}
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.{{.Name}} = &v
{{- else}}
			case "{{.JSONName}}":
				if err := r.{{.Name}}.UnmarshalXML(dec, t); err != nil {
					return err
				}
{{- end}}
{{- end}}
			default:
{{- if hasResourceField .}}
				if IsKnownResourceType(t.Name.Local) {
					res, err := xmlDecodeInlineResource(dec, t)
					if err != nil {
						return err
					}
					r.{{resourceFieldName .}} = res
				} else {
					if err := dec.Skip(); err != nil {
						return err
					}
				}
{{- else}}
				if err := dec.Skip(); err != nil {
					return err
				}
{{- end}}
			}
		case xml.EndElement:
			return nil
		}
	}
}

{{end}}

// =============================================================================
// Backbone XML Deserialization (for datatype backbones)
// =============================================================================

{{range .Backbones}}
// UnmarshalXML deserializes {{.Name}} from FHIR-conformant XML.
func (r *{{.Name}}) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
{{- if hasIdField .}}
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}
{{- end}}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
{{- range .Properties}}
{{- if eq .JSONName "id"}}{{continue}}{{end}}
{{- if isExtField . }}{{continue}}{{end}}
{{- if eq .GoType "Resource"}}
{{- else if and (eq .FHIRType "xhtml") (not .IsArray)}}
			case "{{.JSONName}}":
				v, err := xmlDecodeRawXHTML(d, t)
				if err != nil {
					return err
				}
				r.{{.Name}} = v
{{- else if and .IsPrimitive (not .IsArray)}}
			case "{{.JSONName}}":
				v, _, err := {{xmlPrimitiveDecodeFunc .GoType}}(d, t)
				if err != nil {
					return err
				}
				r.{{.Name}} = v
{{- else if and .IsPrimitive .IsArray}}
			case "{{.JSONName}}":
				v, _, err := {{xmlPrimitiveDecodeFunc (elemType .GoType)}}(d, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.{{.Name}} = append(r.{{.Name}}, *v)
				}
{{- else if .IsArray}}
			case "{{.JSONName}}":
				var v {{elemType .GoType}}
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.{{.Name}} = append(r.{{.Name}}, v)
{{- else if .IsPointer}}
			case "{{.JSONName}}":
				var v {{derefType .GoType}}
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.{{.Name}} = &v
{{- else}}
			case "{{.JSONName}}":
				if err := r.{{.Name}}.UnmarshalXML(d, t); err != nil {
					return err
				}
{{- end}}
{{- end}}
			default:
{{- if hasResourceField .}}
				if IsKnownResourceType(t.Name.Local) {
					res, err := xmlDecodeInlineResource(d, t)
					if err != nil {
						return err
					}
					r.{{resourceFieldName .}} = res
				} else {
					if err := d.Skip(); err != nil {
						return err
					}
				}
{{- else}}
				if err := d.Skip(); err != nil {
					return err
				}
{{- end}}
			}
		case xml.EndElement:
			return nil
		}
	}
}

{{end}}
