{{- /* Template for generating xml_helpers.go - shared XML encoding utilities */ -}}
// Code generated by gofhir. DO NOT EDIT.
// Source: FHIR XML serialization helpers
// Package: {{.PackageName}}

package {{.PackageName}}

import (
	"bytes"
	"encoding/xml"
	"fmt"
	"regexp"
	"strconv"
	"strings"
)

const fhirNamespace = "http://hl7.org/fhir"

// emptyElementRe matches empty XML elements: <tag attr="val"></tag>
// and converts them to self-closing form: <tag attr="val"/>
// This matches FHIR spec convention for primitive elements.
var emptyElementRe = regexp.MustCompile(`<([a-zA-Z][a-zA-Z0-9]*)(\s[^>]*)></[a-zA-Z][a-zA-Z0-9]*>`)

// collapseEmptyElements converts <tag attr="val"></tag> to <tag attr="val"/>.
func collapseEmptyElements(xmlBytes []byte) []byte {
	return emptyElementRe.ReplaceAllFunc(xmlBytes, func(match []byte) []byte {
		sub := emptyElementRe.FindSubmatch(match)
		if len(sub) < 3 {
			return match
		}
		openTag := sub[1]
		attrs := sub[2]
		// Extract closing tag name from </tagname>
		closeIdx := bytes.LastIndex(match, []byte("</"))
		if closeIdx < 0 {
			return match
		}
		closeTag := match[closeIdx+2 : len(match)-1]
		if !bytes.Equal(openTag, closeTag) {
			return match
		}
		var buf bytes.Buffer
		buf.WriteByte('<')
		buf.Write(openTag)
		buf.Write(attrs)
		buf.WriteString("/>")
		return buf.Bytes()
	})
}

// MarshalResourceXML serializes a FHIR resource to XML bytes with XML declaration.
//
// The output includes the XML declaration header and the resource element
// with the FHIR namespace (xmlns="http://hl7.org/fhir").
// Empty elements are rendered as self-closing tags per FHIR convention.
func MarshalResourceXML(resource Resource) ([]byte, error) {
	var buf bytes.Buffer
	buf.WriteString(xml.Header)

	enc := xml.NewEncoder(&buf)
	type xmlMarshaler interface {
		MarshalXML(*xml.Encoder, xml.StartElement) error
	}
	m, ok := resource.(xmlMarshaler)
	if !ok {
		return nil, fmt.Errorf("resource %s does not implement MarshalXML", resource.GetResourceType())
	}
	if err := m.MarshalXML(enc, xml.StartElement{}); err != nil {
		return nil, err
	}
	if err := enc.Flush(); err != nil {
		return nil, err
	}
	return collapseEmptyElements(buf.Bytes()), nil
}

// MarshalResourceXMLIndent is like MarshalResourceXML but applies indentation.
// Empty elements are rendered as self-closing tags per FHIR convention.
func MarshalResourceXMLIndent(resource Resource, prefix, indent string) ([]byte, error) {
	var buf bytes.Buffer
	buf.WriteString(xml.Header)

	enc := xml.NewEncoder(&buf)
	enc.Indent(prefix, indent)
	type xmlMarshaler interface {
		MarshalXML(*xml.Encoder, xml.StartElement) error
	}
	m, ok := resource.(xmlMarshaler)
	if !ok {
		return nil, fmt.Errorf("resource %s does not implement MarshalXML", resource.GetResourceType())
	}
	if err := m.MarshalXML(enc, xml.StartElement{}); err != nil {
		return nil, err
	}
	if err := enc.Flush(); err != nil {
		return nil, err
	}
	return collapseEmptyElements(buf.Bytes()), nil
}

// xmlEncodePrimitiveString encodes a FHIR string primitive as an XML element
// with a value attribute: <name value="stringValue"/>.
// If ext is non-nil, merges the Element's id as an attribute and extensions as children.
func xmlEncodePrimitiveString(e *xml.Encoder, name string, value *string, ext *Element) error {
	if value == nil && ext == nil {
		return nil
	}
	start := xml.StartElement{Name: xml.Name{Local: name}}
	if value != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "value"}, Value: *value})
	}
	if ext != nil && ext.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *ext.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}
	if ext != nil {
		if err := xmlEncodeExtensionChildren(e, ext); err != nil {
			return err
		}
	}
	return e.EncodeToken(start.End())
}

// xmlEncodePrimitiveBool encodes a FHIR boolean primitive.
func xmlEncodePrimitiveBool(e *xml.Encoder, name string, value *bool, ext *Element) error {
	if value == nil && ext == nil {
		return nil
	}
	var strVal *string
	if value != nil {
		s := strconv.FormatBool(*value)
		strVal = &s
	}
	return xmlEncodePrimitiveString(e, name, strVal, ext)
}

// xmlEncodePrimitiveInt encodes a FHIR integer primitive.
func xmlEncodePrimitiveInt(e *xml.Encoder, name string, value *int, ext *Element) error {
	if value == nil && ext == nil {
		return nil
	}
	var strVal *string
	if value != nil {
		s := strconv.Itoa(*value)
		strVal = &s
	}
	return xmlEncodePrimitiveString(e, name, strVal, ext)
}

// xmlEncodePrimitiveInt64 encodes a FHIR integer64 primitive.
func xmlEncodePrimitiveInt64(e *xml.Encoder, name string, value *int64, ext *Element) error {
	if value == nil && ext == nil {
		return nil
	}
	var strVal *string
	if value != nil {
		s := strconv.FormatInt(*value, 10)
		strVal = &s
	}
	return xmlEncodePrimitiveString(e, name, strVal, ext)
}

// xmlEncodePrimitiveUint32 encodes a FHIR unsignedInt/positiveInt primitive.
func xmlEncodePrimitiveUint32(e *xml.Encoder, name string, value *uint32, ext *Element) error {
	if value == nil && ext == nil {
		return nil
	}
	var strVal *string
	if value != nil {
		s := strconv.FormatUint(uint64(*value), 10)
		strVal = &s
	}
	return xmlEncodePrimitiveString(e, name, strVal, ext)
}

// xmlEncodePrimitiveDecimal encodes a FHIR decimal primitive.
func xmlEncodePrimitiveDecimal(e *xml.Encoder, name string, value *Decimal, ext *Element) error {
	if value == nil && ext == nil {
		return nil
	}
	var strVal *string
	if value != nil {
		s := value.String()
		strVal = &s
	}
	return xmlEncodePrimitiveString(e, name, strVal, ext)
}

// xmlEncodePrimitiveCode encodes a FHIR code primitive with a custom string-based type.
// This handles types like AdministrativeGender, NarrativeStatus, etc.
func xmlEncodePrimitiveCode[T ~string](e *xml.Encoder, name string, value *T, ext *Element) error {
	if value == nil && ext == nil {
		return nil
	}
	var strVal *string
	if value != nil {
		s := string(*value)
		strVal = &s
	}
	return xmlEncodePrimitiveString(e, name, strVal, ext)
}

// xmlEncodePrimitiveStringArray encodes a repeating FHIR string primitive.
// Each item becomes a separate XML element: <name value="item1"/><name value="item2"/>
func xmlEncodePrimitiveStringArray(e *xml.Encoder, name string, values []string, exts []Element) error {
	for i := range values {
		var ext *Element
		if i < len(exts) {
			ext = &exts[i]
			if ext.Id == nil && len(ext.Extension) == 0 {
				ext = nil
			}
		}
		val := values[i]
		if err := xmlEncodePrimitiveString(e, name, &val, ext); err != nil {
			return err
		}
	}
	return nil
}

// xmlEncodePrimitiveBoolArray encodes a repeating FHIR boolean primitive.
func xmlEncodePrimitiveBoolArray(e *xml.Encoder, name string, values []bool, exts []Element) error {
	for i := range values {
		var ext *Element
		if i < len(exts) {
			ext = &exts[i]
			if ext.Id == nil && len(ext.Extension) == 0 {
				ext = nil
			}
		}
		val := values[i]
		if err := xmlEncodePrimitiveBool(e, name, &val, ext); err != nil {
			return err
		}
	}
	return nil
}

// xmlEncodePrimitiveIntArray encodes a repeating FHIR integer primitive.
func xmlEncodePrimitiveIntArray(e *xml.Encoder, name string, values []int, exts []Element) error {
	for i := range values {
		var ext *Element
		if i < len(exts) {
			ext = &exts[i]
			if ext.Id == nil && len(ext.Extension) == 0 {
				ext = nil
			}
		}
		val := values[i]
		if err := xmlEncodePrimitiveInt(e, name, &val, ext); err != nil {
			return err
		}
	}
	return nil
}

// xmlEncodePrimitiveInt64Array encodes a repeating FHIR integer64 primitive.
func xmlEncodePrimitiveInt64Array(e *xml.Encoder, name string, values []int64, exts []Element) error {
	for i := range values {
		var ext *Element
		if i < len(exts) {
			ext = &exts[i]
			if ext.Id == nil && len(ext.Extension) == 0 {
				ext = nil
			}
		}
		val := values[i]
		if err := xmlEncodePrimitiveInt64(e, name, &val, ext); err != nil {
			return err
		}
	}
	return nil
}

// xmlEncodePrimitiveUint32Array encodes a repeating FHIR unsignedInt/positiveInt primitive.
func xmlEncodePrimitiveUint32Array(e *xml.Encoder, name string, values []uint32, exts []Element) error {
	for i := range values {
		var ext *Element
		if i < len(exts) {
			ext = &exts[i]
			if ext.Id == nil && len(ext.Extension) == 0 {
				ext = nil
			}
		}
		val := values[i]
		if err := xmlEncodePrimitiveUint32(e, name, &val, ext); err != nil {
			return err
		}
	}
	return nil
}

// xmlEncodePrimitiveDecimalArray encodes a repeating FHIR decimal primitive.
func xmlEncodePrimitiveDecimalArray(e *xml.Encoder, name string, values []Decimal, exts []Element) error {
	for i := range values {
		var ext *Element
		if i < len(exts) {
			ext = &exts[i]
			if ext.Id == nil && len(ext.Extension) == 0 {
				ext = nil
			}
		}
		val := values[i]
		if err := xmlEncodePrimitiveDecimal(e, name, &val, ext); err != nil {
			return err
		}
	}
	return nil
}

// xmlEncodePrimitiveCodeArray encodes a repeating FHIR code primitive with custom string-based type.
func xmlEncodePrimitiveCodeArray[T ~string](e *xml.Encoder, name string, values []T, exts []Element) error {
	for i := range values {
		var ext *Element
		if i < len(exts) {
			ext = &exts[i]
			if ext.Id == nil && len(ext.Extension) == 0 {
				ext = nil
			}
		}
		val := values[i]
		if err := xmlEncodePrimitiveCode(e, name, &val, ext); err != nil {
			return err
		}
	}
	return nil
}

// xmlEncodeExtensionChildren encodes the children of an Element (extensions)
// as child XML elements within the current element.
func xmlEncodeExtensionChildren(e *xml.Encoder, elem *Element) error {
	for i := range elem.Extension {
		if err := elem.Extension[i].MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	return nil
}

// xmlEncodeContainedResource encodes a polymorphic contained resource.
// The output is: <contained><ResourceType>...</ResourceType></contained>
func xmlEncodeContainedResource(e *xml.Encoder, resource Resource) error {
	start := xml.StartElement{Name: xml.Name{Local: "contained"}}
	if err := e.EncodeToken(start); err != nil {
		return err
	}
	if err := xmlEncodeInlineResource(e, resource); err != nil {
		return err
	}
	return e.EncodeToken(start.End())
}

// xmlEncodeInlineResource encodes a resource directly using its type name
// as the element name, without a FHIR namespace (for contained/Bundle.entry).
func xmlEncodeInlineResource(e *xml.Encoder, resource Resource) error {
	type xmlMarshaler interface {
		MarshalXML(*xml.Encoder, xml.StartElement) error
	}
	m, ok := resource.(xmlMarshaler)
	if !ok {
		return fmt.Errorf("resource %s does not implement MarshalXML", resource.GetResourceType())
	}
	inner := xml.StartElement{Name: xml.Name{Local: resource.GetResourceType()}}
	return m.MarshalXML(e, inner)
}

// xmlEncodeRawXHTML injects raw XHTML content verbatim into the XML output.
// The rawXHTML string should contain the full <div xmlns="...">...</div> element.
func xmlEncodeRawXHTML(e *xml.Encoder, rawXHTML *string) error {
	if rawXHTML == nil || *rawXHTML == "" {
		return nil
	}
	type rawInner struct {
		Content string `xml:",innerxml"`
	}
	return e.Encode(rawInner{Content: *rawXHTML})
}

// ============================================================================
// XML Deserialization Helpers
// ============================================================================

// UnmarshalResourceXML deserializes FHIR XML bytes to the correct resource type.
// It reads the root element name to determine the resource type, creates the
// appropriate struct via the registry, and calls UnmarshalXML.
func UnmarshalResourceXML(data []byte) (Resource, error) {
	d := xml.NewDecoder(bytes.NewReader(data))
	for {
		tok, err := d.Token()
		if err != nil {
			return nil, fmt.Errorf("failed to find root element: %w", err)
		}
		if start, ok := tok.(xml.StartElement); ok {
			resource, err := NewResource(start.Name.Local)
			if err != nil {
				return nil, fmt.Errorf("unknown resource type %q: %w", start.Name.Local, err)
			}
			type xmlUnmarshaler interface {
				UnmarshalXML(*xml.Decoder, xml.StartElement) error
			}
			u, ok := resource.(xmlUnmarshaler)
			if !ok {
				return nil, fmt.Errorf("resource %s does not implement UnmarshalXML", start.Name.Local)
			}
			if err := u.UnmarshalXML(d, start); err != nil {
				return nil, err
			}
			return resource, nil
		}
	}
}

// xmlDecodePrimitiveString decodes a FHIR string primitive element.
// Returns the value from the "value" attribute and an *Element if extensions/id are present.
func xmlDecodePrimitiveString(d *xml.Decoder, start xml.StartElement) (*string, *Element, error) {
	var value *string
	var elem *Element

	for _, attr := range start.Attr {
		switch attr.Name.Local {
		case "value":
			v := attr.Value
			value = &v
		case "id":
			if elem == nil {
				elem = &Element{}
			}
			id := attr.Value
			elem.Id = &id
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return nil, nil, err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			if t.Name.Local == "extension" {
				if elem == nil {
					elem = &Element{}
				}
				var ext Extension
				if err := ext.UnmarshalXML(d, t); err != nil {
					return nil, nil, err
				}
				elem.Extension = append(elem.Extension, ext)
			} else {
				if err := d.Skip(); err != nil {
					return nil, nil, err
				}
			}
		case xml.EndElement:
			return value, elem, nil
		}
	}
}

// xmlDecodePrimitiveBool decodes a FHIR boolean primitive element.
func xmlDecodePrimitiveBool(d *xml.Decoder, start xml.StartElement) (*bool, *Element, error) {
	s, elem, err := xmlDecodePrimitiveString(d, start)
	if err != nil {
		return nil, nil, err
	}
	if s == nil {
		return nil, elem, nil
	}
	v, err := strconv.ParseBool(*s)
	if err != nil {
		return nil, nil, fmt.Errorf("invalid boolean value %q: %w", *s, err)
	}
	return &v, elem, nil
}

// xmlDecodePrimitiveInt decodes a FHIR integer primitive element.
func xmlDecodePrimitiveInt(d *xml.Decoder, start xml.StartElement) (*int, *Element, error) {
	s, elem, err := xmlDecodePrimitiveString(d, start)
	if err != nil {
		return nil, nil, err
	}
	if s == nil {
		return nil, elem, nil
	}
	v, err := strconv.Atoi(*s)
	if err != nil {
		return nil, nil, fmt.Errorf("invalid integer value %q: %w", *s, err)
	}
	return &v, elem, nil
}

// xmlDecodePrimitiveInt64 decodes a FHIR integer64 primitive element.
func xmlDecodePrimitiveInt64(d *xml.Decoder, start xml.StartElement) (*int64, *Element, error) {
	s, elem, err := xmlDecodePrimitiveString(d, start)
	if err != nil {
		return nil, nil, err
	}
	if s == nil {
		return nil, elem, nil
	}
	v, err := strconv.ParseInt(*s, 10, 64)
	if err != nil {
		return nil, nil, fmt.Errorf("invalid int64 value %q: %w", *s, err)
	}
	return &v, elem, nil
}

// xmlDecodePrimitiveUint32 decodes a FHIR unsignedInt/positiveInt primitive element.
func xmlDecodePrimitiveUint32(d *xml.Decoder, start xml.StartElement) (*uint32, *Element, error) {
	s, elem, err := xmlDecodePrimitiveString(d, start)
	if err != nil {
		return nil, nil, err
	}
	if s == nil {
		return nil, elem, nil
	}
	v, err := strconv.ParseUint(*s, 10, 32)
	if err != nil {
		return nil, nil, fmt.Errorf("invalid uint32 value %q: %w", *s, err)
	}
	u := uint32(v)
	return &u, elem, nil
}

// xmlDecodePrimitiveDecimal decodes a FHIR decimal primitive element.
func xmlDecodePrimitiveDecimal(d *xml.Decoder, start xml.StartElement) (*Decimal, *Element, error) {
	s, elem, err := xmlDecodePrimitiveString(d, start)
	if err != nil {
		return nil, nil, err
	}
	if s == nil {
		return nil, elem, nil
	}
	dec, err := NewDecimalFromString(*s)
	if err != nil {
		return nil, nil, fmt.Errorf("invalid decimal %q: %w", *s, err)
	}
	return dec, elem, nil
}

// xmlDecodePrimitiveCode decodes a FHIR code primitive with a custom string-based type.
func xmlDecodePrimitiveCode[T ~string](d *xml.Decoder, start xml.StartElement) (*T, *Element, error) {
	s, elem, err := xmlDecodePrimitiveString(d, start)
	if err != nil {
		return nil, nil, err
	}
	if s == nil {
		return nil, elem, nil
	}
	v := T(*s)
	return &v, elem, nil
}

// xmlDecodeContainedResource decodes a <contained> element containing a polymorphic resource.
// The pattern is: <contained><ResourceType>...</ResourceType></contained>
func xmlDecodeContainedResource(d *xml.Decoder, start xml.StartElement) (Resource, error) {
	for {
		tok, err := d.Token()
		if err != nil {
			return nil, err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			res, err := xmlDecodeInlineResource(d, t)
			if err != nil {
				return nil, err
			}
			// Consume remaining tokens until </contained>
			for {
				tok2, err := d.Token()
				if err != nil {
					return nil, err
				}
				if _, ok := tok2.(xml.EndElement); ok {
					return res, nil
				}
			}
		case xml.EndElement:
			return nil, nil
		}
	}
}

// xmlDecodeInlineResource decodes a resource element where the element name IS the resource type.
func xmlDecodeInlineResource(d *xml.Decoder, start xml.StartElement) (Resource, error) {
	resource, err := NewResource(start.Name.Local)
	if err != nil {
		return nil, fmt.Errorf("unknown resource type %q: %w", start.Name.Local, err)
	}
	type xmlUnmarshaler interface {
		UnmarshalXML(*xml.Decoder, xml.StartElement) error
	}
	u, ok := resource.(xmlUnmarshaler)
	if !ok {
		return nil, fmt.Errorf("resource %s does not implement UnmarshalXML", start.Name.Local)
	}
	if err := u.UnmarshalXML(d, start); err != nil {
		return nil, err
	}
	return resource, nil
}

// xmlDecodeRawXHTML reads a raw XHTML element (e.g., <div xmlns="...">...</div>)
// and returns the full element as a string.
func xmlDecodeRawXHTML(d *xml.Decoder, start xml.StartElement) (*string, error) {
	var buf bytes.Buffer
	buf.WriteString("<")
	buf.WriteString(start.Name.Local)
	for _, attr := range start.Attr {
		buf.WriteString(" ")
		if attr.Name.Space != "" {
			buf.WriteString(attr.Name.Space)
			buf.WriteString(":")
		}
		buf.WriteString(attr.Name.Local)
		buf.WriteString(`="`)
		buf.WriteString(xmlEscapeAttr(attr.Value))
		buf.WriteString(`"`)
	}
	buf.WriteString(">")

	depth := 1
	for depth > 0 {
		tok, err := d.Token()
		if err != nil {
			return nil, err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			depth++
			buf.WriteString("<")
			buf.WriteString(t.Name.Local)
			for _, a := range t.Attr {
				buf.WriteString(" ")
				if a.Name.Space != "" {
					buf.WriteString(a.Name.Space)
					buf.WriteString(":")
				}
				buf.WriteString(a.Name.Local)
				buf.WriteString(`="`)
				buf.WriteString(xmlEscapeAttr(a.Value))
				buf.WriteString(`"`)
			}
			buf.WriteString(">")
		case xml.EndElement:
			depth--
			if depth > 0 {
				buf.WriteString("</")
				buf.WriteString(t.Name.Local)
				buf.WriteString(">")
			}
		case xml.CharData:
			xml.EscapeText(&buf, t)
		case xml.Comment:
			buf.WriteString("<!--")
			buf.Write(t)
			buf.WriteString("-->")
		}
	}

	buf.WriteString("</")
	buf.WriteString(start.Name.Local)
	buf.WriteString(">")

	result := buf.String()
	return &result, nil
}

// xmlEscapeAttr escapes special characters in XML attribute values.
func xmlEscapeAttr(s string) string {
	s = strings.ReplaceAll(s, "&", "&amp;")
	s = strings.ReplaceAll(s, "<", "&lt;")
	s = strings.ReplaceAll(s, ">", "&gt;")
	s = strings.ReplaceAll(s, `"`, "&quot;")
	return s
}
