{{- /* Template for generating a consolidated resource file:
     struct + backbones + JSON marshal/unmarshal + XML marshal/unmarshal */ -}}
// Code generated by gofhir. DO NOT EDIT.
// Source: FHIR StructureDefinitions (consolidated resource)
// Package: {{.PackageName}}

package {{.PackageName}}

{{- /* Determine if fmt import is needed (contained or Resource fields) */ -}}
{{- $needsFmt := false -}}
{{- range .Resource.Properties -}}
{{- if eq .JSONName "contained" -}}{{- $needsFmt = true -}}{{- end -}}
{{- end -}}
{{- range .Backbones -}}
{{- range .Properties -}}
{{- if eq .GoType "Resource" -}}{{- $needsFmt = true -}}{{- end -}}
{{- end -}}
{{- end }}

import (
	"bytes"
	"encoding/json"
	"encoding/xml"
{{- if $needsFmt }}
	"fmt"
{{- end }}
)

// =============================================================================
// {{.Resource.Name}} Resource
// =============================================================================

{{with .Resource}}
{{if .Description}}// {{.Name}} {{.Description}}
{{else}}// {{.Name}} represents FHIR {{.FHIRName}}.
{{end -}}
type {{.Name}} struct {
	// FHIR resource type
	ResourceType string `json:"resourceType"`
{{- range .Properties}}
	{{if .Description}}// {{.Description}}
	{{end -}}
	{{.Name}} {{.GoType}} `json:"{{.JSONName}}{{if or .IsArray .IsPointer}},omitempty{{end}}"`
	{{- if and .HasExtension (not .IsChoice)}}
	// Extension for {{.Name}}
	{{- if .IsArray}}
	{{.Name}}Ext []Element `json:"_{{.JSONName}},omitempty"`
	{{- else}}
	{{.Name}}Ext *Element `json:"_{{.JSONName}},omitempty"`
	{{- end}}
	{{- end}}
{{- end}}
}

// GetResourceType returns the FHIR resource type.
func (r *{{.Name}}) GetResourceType() string {
	return "{{.FHIRName}}"
}

{{- /* Check which properties exist */ -}}
{{- $hasId := false -}}
{{- $hasMeta := false -}}
{{- $hasText := false -}}
{{- $hasContained := false -}}
{{- $hasExtension := false -}}
{{- $hasModifierExtension := false -}}
{{- range .Properties -}}
{{- if eq .JSONName "id" -}}{{- $hasId = true -}}{{- end -}}
{{- if eq .JSONName "meta" -}}{{- $hasMeta = true -}}{{- end -}}
{{- if eq .JSONName "text" -}}{{- $hasText = true -}}{{- end -}}
{{- if eq .JSONName "contained" -}}{{- $hasContained = true -}}{{- end -}}
{{- if eq .JSONName "extension" -}}{{- $hasExtension = true -}}{{- end -}}
{{- if eq .JSONName "modifierExtension" -}}{{- $hasModifierExtension = true -}}{{- end -}}
{{- end -}}

{{- /* Resource interface methods (id, meta) */ -}}
{{- if $hasId }}

// GetId returns the resource's logical ID.
func (r *{{.Name}}) GetId() *string {
	return r.Id
}

// SetId sets the resource's logical ID.
func (r *{{.Name}}) SetId(id string) {
	r.Id = &id
}
{{- end }}

{{- if $hasMeta }}

// GetMeta returns the resource's Meta element.
func (r *{{.Name}}) GetMeta() *Meta {
	return r.Meta
}

// SetMeta sets the resource's Meta element.
func (r *{{.Name}}) SetMeta(m *Meta) {
	r.Meta = m
}
{{- end }}

{{- /* DomainResource interface methods */ -}}
{{- if $hasText }}

// GetText returns the resource's narrative text.
func (r *{{.Name}}) GetText() *Narrative {
	return r.Text
}

// SetText sets the resource's narrative text.
func (r *{{.Name}}) SetText(t *Narrative) {
	r.Text = t
}
{{- end }}

{{- if $hasContained }}

// GetContained returns the resource's contained resources.
func (r *{{.Name}}) GetContained() []Resource {
	return r.Contained
}
{{- end }}

{{- if $hasExtension }}

// GetExtension returns the resource's extensions.
func (r *{{.Name}}) GetExtension() []Extension {
	return r.Extension
}
{{- end }}

{{- if $hasModifierExtension }}

// GetModifierExtension returns the resource's modifier extensions.
func (r *{{.Name}}) GetModifierExtension() []Extension {
	return r.ModifierExtension
}
{{- end }}

// MarshalJSON ensures resourceType is always included in JSON output.
// HTML escaping is disabled to preserve FHIR narrative XHTML content.
//
// Note: Use the package-level Marshal function instead of json.Marshal
// to ensure HTML in narrative text.div fields is not escaped.
func (r {{.Name}}) MarshalJSON() ([]byte, error) {
	r.ResourceType = "{{.FHIRName}}"
	type Alias {{.Name}}
	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	enc.SetEscapeHTML(false)
	if err := enc.Encode((Alias)(r)); err != nil {
		return nil, err
	}
	b := buf.Bytes()
	if len(b) > 0 && b[len(b)-1] == '\n' {
		b = b[:len(b)-1]
	}
	return b, nil
}

{{- if $hasContained }}

// UnmarshalJSON handles deserialization of polymorphic contained resources.
func (r *{{.Name}}) UnmarshalJSON(data []byte) error {
	// Use an alias to avoid infinite recursion
	type Alias {{.Name}}
	aux := &struct {
		Contained []json.RawMessage `json:"contained,omitempty"`
		*Alias
	}{
		Alias: (*Alias)(r),
	}

	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}

	// Unmarshal each contained resource using the dispatcher
	if len(aux.Contained) > 0 {
		r.Contained = make([]Resource, len(aux.Contained))
		for i, raw := range aux.Contained {
			resource, err := UnmarshalResource(raw)
			if err != nil {
				return fmt.Errorf("failed to unmarshal contained[%d]: %w", i, err)
			}
			r.Contained[i] = resource
		}
	}

	return nil
}
{{- end }}

// MarshalXML serializes {{.Name}} to FHIR-conformant XML.
func (r {{.Name}}) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "{{.FHIRName}}"
		start.Name.Space = fhirNamespace
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}
{{range .Properties}}
{{- /* Skip ResourceType field - it becomes the XML element name */ -}}
{{- if eq .JSONName "resourceType"}}{{continue}}{{end}}
{{- /* Skip _field extension companions - consumed by their parent primitive */ -}}
{{- if isExtField . }}{{continue}}{{end}}
{{- /* Resource id - primitive but not flagged by analyzer due to System.String type */ -}}
{{- if eq .JSONName "id"}}
	if err := xmlEncodePrimitiveString(e, "id", r.{{.Name}}, nil); err != nil {
		return err
	}
{{- /* Contained resources */ -}}
{{- else if eq .JSONName "contained"}}
	for _, c := range r.Contained {
		if c != nil {
			if err := xmlEncodeContainedResource(e, c); err != nil {
				return err
			}
		}
	}
{{- /* Raw XHTML (Narrative.div) */ -}}
{{- else if and (eq .FHIRType "xhtml") (not .IsArray)}}
	if err := xmlEncodeRawXHTML(e, r.{{.Name}}); err != nil {
		return err
	}
{{- /* Primitive scalars */ -}}
{{- else if and .IsPrimitive (not .IsArray)}}
	if err := {{xmlPrimitiveFunc .GoType}}(e, "{{.JSONName}}", r.{{.Name}}, {{extFieldRef "r" .}}); err != nil {
		return err
	}
{{- /* Primitive arrays */ -}}
{{- else if and .IsPrimitive .IsArray}}
	if err := {{xmlPrimitiveArrayFunc .GoType}}(e, "{{.JSONName}}", r.{{.Name}}, {{extFieldRef "r" .}}); err != nil {
		return err
	}
{{- /* Polymorphic Resource field (e.g., Bundle entry) */ -}}
{{- else if eq .GoType "Resource"}}
	if r.{{.Name}} != nil {
		if err := xmlEncodeInlineResource(e, r.{{.Name}}); err != nil {
			return err
		}
	}
{{- /* Complex type arrays */ -}}
{{- else if .IsArray}}
	for _, item := range r.{{.Name}} {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "{{.JSONName}}"}}); err != nil {
			return err
		}
	}
{{- /* Complex type pointers */ -}}
{{- else if .IsPointer}}
	if r.{{.Name}} != nil {
		if err := r.{{.Name}}.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "{{.JSONName}}"}}); err != nil {
			return err
		}
	}
{{- /* Complex type required (non-pointer) */ -}}
{{- else}}
	if err := r.{{.Name}}.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "{{.JSONName}}"}}); err != nil {
		return err
	}
{{- end}}
{{- end}}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes {{.Name}} from FHIR-conformant XML.
func (r *{{.Name}}) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
{{- range .Properties}}
{{- /* Skip ResourceType field */ -}}
{{- if eq .JSONName "resourceType"}}{{continue}}{{end}}
{{- /* Skip _field extension companions */ -}}
{{- if isExtField . }}{{continue}}{{end}}
{{- /* Resource id - child element */ -}}
{{- if eq .JSONName "id"}}
			case "id":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Id = v
{{- /* Contained resources */ -}}
{{- else if eq .JSONName "contained"}}
			case "contained":
				res, err := xmlDecodeContainedResource(d, t)
				if err != nil {
					return err
				}
				if res != nil {
					r.Contained = append(r.Contained, res)
				}
{{- /* Raw XHTML (Narrative.div) */ -}}
{{- else if and (eq .FHIRType "xhtml") (not .IsArray)}}
			case "{{.JSONName}}":
				v, err := xmlDecodeRawXHTML(d, t)
				if err != nil {
					return err
				}
				r.{{.Name}} = v
{{- /* Primitive scalars */ -}}
{{- else if and .IsPrimitive (not .IsArray)}}
			case "{{.JSONName}}":
				v, ext, err := {{xmlPrimitiveDecodeFunc .GoType}}(d, t)
				if err != nil {
					return err
				}
				r.{{.Name}} = v
{{- if and .HasExtension (not .IsChoice)}}
				r.{{.Name}}Ext = ext
{{- else}}
				_ = ext
{{- end}}
{{- /* Primitive arrays */ -}}
{{- else if and .IsPrimitive .IsArray}}
			case "{{.JSONName}}":
				v, _, err := {{xmlPrimitiveDecodeFunc (elemType .GoType)}}(d, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.{{.Name}} = append(r.{{.Name}}, *v)
				}
{{- /* Polymorphic Resource field */ -}}
{{- else if eq .GoType "Resource"}}
{{- /* Handled via inline resource - should not appear on resources */ -}}
{{- /* Complex type arrays */ -}}
{{- else if .IsArray}}
			case "{{.JSONName}}":
				var v {{elemType .GoType}}
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.{{.Name}} = append(r.{{.Name}}, v)
{{- /* Complex type pointers */ -}}
{{- else if .IsPointer}}
			case "{{.JSONName}}":
				var v {{derefType .GoType}}
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.{{.Name}} = &v
{{- /* Complex type required (non-pointer) */ -}}
{{- else}}
			case "{{.JSONName}}":
				if err := r.{{.Name}}.UnmarshalXML(d, t); err != nil {
					return err
				}
{{- end}}
{{- end}}
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}
{{end}}

{{- /* ================================================================== */ -}}
{{- /* Backbone Element Definitions                                       */ -}}
{{- /* ================================================================== */ -}}

{{range .Backbones}}
{{- /* Check if this backbone has a Resource field */ -}}
{{- $hasResourceField := false -}}
{{- $resourceFieldName := "" -}}
{{- $resourceJSONName := "" -}}
{{- range .Properties -}}
{{- if eq .GoType "Resource" -}}
{{- $hasResourceField = true -}}
{{- $resourceFieldName = .Name -}}
{{- $resourceJSONName = .JSONName -}}
{{- end -}}
{{- end -}}

// {{.Name}} represents the {{.FHIRName}} backbone element.
{{- if .Description}}
// {{.Description}}
{{- end}}
type {{.Name}} struct {
{{- range .Properties}}
	{{- if .Description}}
	// {{.Description}}
	{{- end}}
	{{.Name}} {{.GoType}} `json:"{{.JSONName}},omitempty"`
{{- end}}
}

{{- if $hasResourceField }}

// UnmarshalJSON handles deserialization of polymorphic resource field.
func (b *{{.Name}}) UnmarshalJSON(data []byte) error {
	// Use an alias to avoid infinite recursion
	type Alias {{.Name}}
	aux := &struct {
		{{$resourceFieldName}} json.RawMessage `json:"{{$resourceJSONName}},omitempty"`
		*Alias
	}{
		Alias: (*Alias)(b),
	}

	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}

	// Unmarshal the resource field using the dispatcher
	if len(aux.{{$resourceFieldName}}) > 0 {
		resource, err := UnmarshalResource(aux.{{$resourceFieldName}})
		if err != nil {
			return fmt.Errorf("failed to unmarshal {{$resourceJSONName}}: %w", err)
		}
		b.{{$resourceFieldName}} = resource
	}

	return nil
}
{{- end }}

// MarshalXML serializes {{.Name}} to FHIR-conformant XML.
func (b {{.Name}}) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "{{.FHIRName}}"
	}
{{- /* On backbone elements, "id" is an XML attribute, not a child element */ -}}
{{- if hasIdField .}}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
{{- end}}
	if err := e.EncodeToken(start); err != nil {
		return err
	}
{{range .Properties}}
{{- /* Skip id - already handled as XML attribute above */ -}}
{{- if eq .JSONName "id"}}{{continue}}{{end}}
{{- /* Skip _field extension companions - consumed by their parent primitive */ -}}
{{- if isExtField . }}{{continue}}{{end}}
{{- /* Polymorphic Resource field (e.g., BundleEntry.Resource) */ -}}
{{- if eq .GoType "Resource"}}
	if b.{{.Name}} != nil {
		if err := xmlEncodeInlineResource(e, b.{{.Name}}); err != nil {
			return err
		}
	}
{{- /* Raw XHTML */ -}}
{{- else if and (eq .FHIRType "xhtml") (not .IsArray)}}
	if err := xmlEncodeRawXHTML(e, b.{{.Name}}); err != nil {
		return err
	}
{{- /* Primitive scalars (backbones don't have extension companion fields) */ -}}
{{- else if and .IsPrimitive (not .IsArray)}}
	if err := {{xmlPrimitiveFunc .GoType}}(e, "{{.JSONName}}", b.{{.Name}}, nil); err != nil {
		return err
	}
{{- /* Primitive arrays (backbones don't have extension companion fields) */ -}}
{{- else if and .IsPrimitive .IsArray}}
	if err := {{xmlPrimitiveArrayFunc .GoType}}(e, "{{.JSONName}}", b.{{.Name}}, nil); err != nil {
		return err
	}
{{- /* Complex type arrays */ -}}
{{- else if .IsArray}}
	for _, item := range b.{{.Name}} {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "{{.JSONName}}"}}); err != nil {
			return err
		}
	}
{{- /* Complex type pointers */ -}}
{{- else if .IsPointer}}
	if b.{{.Name}} != nil {
		if err := b.{{.Name}}.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "{{.JSONName}}"}}); err != nil {
			return err
		}
	}
{{- /* Complex type required (non-pointer) */ -}}
{{- else}}
	if err := b.{{.Name}}.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "{{.JSONName}}"}}); err != nil {
		return err
	}
{{- end}}
{{- end}}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes {{.Name}} from FHIR-conformant XML.
func (r *{{.Name}}) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
{{- /* On backbone elements, "id" is an XML attribute */ -}}
{{- if hasIdField .}}
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}
{{- end}}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
{{- range .Properties}}
{{- /* Skip id - already handled as XML attribute above */ -}}
{{- if eq .JSONName "id"}}{{continue}}{{end}}
{{- /* Skip _field extension companions */ -}}
{{- if isExtField . }}{{continue}}{{end}}
{{- /* Polymorphic Resource field (e.g., BundleEntry.Resource) - handled in default */ -}}
{{- if eq .GoType "Resource"}}
{{- /* Raw XHTML */ -}}
{{- else if and (eq .FHIRType "xhtml") (not .IsArray)}}
			case "{{.JSONName}}":
				v, err := xmlDecodeRawXHTML(d, t)
				if err != nil {
					return err
				}
				r.{{.Name}} = v
{{- /* Primitive scalars (backbones don't have extension companion fields) */ -}}
{{- else if and .IsPrimitive (not .IsArray)}}
			case "{{.JSONName}}":
				v, _, err := {{xmlPrimitiveDecodeFunc .GoType}}(d, t)
				if err != nil {
					return err
				}
				r.{{.Name}} = v
{{- /* Primitive arrays */ -}}
{{- else if and .IsPrimitive .IsArray}}
			case "{{.JSONName}}":
				v, _, err := {{xmlPrimitiveDecodeFunc (elemType .GoType)}}(d, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.{{.Name}} = append(r.{{.Name}}, *v)
				}
{{- /* Complex type arrays */ -}}
{{- else if .IsArray}}
			case "{{.JSONName}}":
				var v {{elemType .GoType}}
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.{{.Name}} = append(r.{{.Name}}, v)
{{- /* Complex type pointers */ -}}
{{- else if .IsPointer}}
			case "{{.JSONName}}":
				var v {{derefType .GoType}}
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.{{.Name}} = &v
{{- /* Complex type required (non-pointer) */ -}}
{{- else}}
			case "{{.JSONName}}":
				if err := r.{{.Name}}.UnmarshalXML(d, t); err != nil {
					return err
				}
{{- end}}
{{- end}}
			default:
{{- if $hasResourceField}}
				if IsKnownResourceType(t.Name.Local) {
					res, err := xmlDecodeInlineResource(d, t)
					if err != nil {
						return err
					}
					r.{{$resourceFieldName}} = res
				} else {
					if err := d.Skip(); err != nil {
						return err
					}
				}
{{- else}}
				if err := d.Skip(); err != nil {
					return err
				}
{{- end}}
			}
		case xml.EndElement:
			return nil
		}
	}
}

{{end}}

// =============================================================================
// {{.Builder.Name}} - Fluent Builder
// =============================================================================

{{- $r := .Builder }}

// {{$r.Name}}Builder provides a fluent API for constructing {{$r.Name}} resources.
type {{$r.Name}}Builder struct {
	{{$r.LowerName}} *{{$r.Name}}
}

// New{{$r.Name}}Builder creates a new {{$r.Name}}Builder.
func New{{$r.Name}}Builder() *{{$r.Name}}Builder {
	return &{{$r.Name}}Builder{
		{{$r.LowerName}}: &{{$r.Name}}{},
	}
}

// Build returns the constructed {{$r.Name}} resource.
func (b *{{$r.Name}}Builder) Build() *{{$r.Name}} {
	return b.{{$r.LowerName}}
}

{{range $r.Properties}}
{{- if not (eq .GoType "*interface{}")}}
{{- if .IsArray}}
// Add{{.Name}} adds a {{.Name}} element.
func (b *{{$r.Name}}Builder) Add{{.Name}}(v {{.ElementType}}) *{{$r.Name}}Builder {
	b.{{$r.LowerName}}.{{.Name}} = append(b.{{$r.LowerName}}.{{.Name}}, v)
	return b
}

{{- else if .IsPointer}}
// Set{{.Name}} sets the {{.Name}} field.
func (b *{{$r.Name}}Builder) Set{{.Name}}(v {{.BaseType}}) *{{$r.Name}}Builder {
	b.{{$r.LowerName}}.{{.Name}} = &v
	return b
}

{{- else}}
// Set{{.Name}} sets the {{.Name}} field.
func (b *{{$r.Name}}Builder) Set{{.Name}}(v {{.GoType}}) *{{$r.Name}}Builder {
	b.{{$r.LowerName}}.{{.Name}} = v
	return b
}

{{- end}}
{{- end}}
{{- end}}

// =============================================================================
// {{$r.Name}} - Functional Options
// =============================================================================

// {{$r.Name}}Option is a functional option for configuring a {{$r.Name}}.
type {{$r.Name}}Option func(*{{$r.Name}})

// New{{$r.Name}} creates a new {{$r.Name}} with the given options.
func New{{$r.Name}}(opts ...{{$r.Name}}Option) *{{$r.Name}} {
	r := &{{$r.Name}}{}
	for _, opt := range opts {
		opt(r)
	}
	return r
}

{{range $r.Properties}}
{{- if not (eq .GoType "*interface{}")}}
{{- if .IsArray}}
// With{{$r.Name}}{{.Name}} adds a {{.Name}} to the {{$r.Name}}.
func With{{$r.Name}}{{.Name}}(v {{.ElementType}}) {{$r.Name}}Option {
	return func(r *{{$r.Name}}) {
		r.{{.Name}} = append(r.{{.Name}}, v)
	}
}

{{- else if .IsPointer}}
// With{{$r.Name}}{{.Name}} sets the {{.Name}} field.
func With{{$r.Name}}{{.Name}}(v {{.BaseType}}) {{$r.Name}}Option {
	return func(r *{{$r.Name}}) {
		r.{{.Name}} = &v
	}
}

{{- else}}
// With{{$r.Name}}{{.Name}} sets the {{.Name}} field.
func With{{$r.Name}}{{.Name}}(v {{.GoType}}) {{$r.Name}}Option {
	return func(r *{{$r.Name}}) {
		r.{{.Name}} = v
	}
}

{{- end}}
{{- end}}
{{- end}}
