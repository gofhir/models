// Code generated by gofhir. DO NOT EDIT.
// Source: FHIR StructureDefinitions (consolidated resource)
// Package: r4

package r4

import (
	"bytes"
	"encoding/json"
	"encoding/xml"
	"fmt"
)

// =============================================================================
// SubstanceSpecification Resource
// =============================================================================

// SubstanceSpecification represents FHIR SubstanceSpecification.
type SubstanceSpecification struct {
	// FHIR resource type
	ResourceType string `json:"resourceType"`
	// Logical id of this artifact
	Id *string `json:"id,omitempty"`
	// Metadata about the resource
	Meta *Meta `json:"meta,omitempty"`
	// A set of rules under which this content was created
	ImplicitRules *string `json:"implicitRules,omitempty"`
	// Extension for ImplicitRules
	ImplicitRulesExt *Element `json:"_implicitRules,omitempty"`
	// Language of the resource content
	Language *string `json:"language,omitempty"`
	// Extension for Language
	LanguageExt *Element `json:"_language,omitempty"`
	// Text summary of the resource, for human interpretation
	Text *Narrative `json:"text,omitempty"`
	// Contained, inline Resources
	Contained []Resource `json:"contained,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Identifier by which this substance is known
	Identifier *Identifier `json:"identifier,omitempty"`
	// High level categorization, e.g. polymer or nucleic acid
	Type *CodeableConcept `json:"type,omitempty"`
	// Status of substance within the catalogue e.g. approved
	Status *CodeableConcept `json:"status,omitempty"`
	// If the substance applies to only human or veterinary use
	Domain *CodeableConcept `json:"domain,omitempty"`
	// Textual description of the substance
	Description *string `json:"description,omitempty"`
	// Extension for Description
	DescriptionExt *Element `json:"_description,omitempty"`
	// Supporting literature
	Source []Reference `json:"source,omitempty"`
	// Textual comment about this record of a substance
	Comment *string `json:"comment,omitempty"`
	// Extension for Comment
	CommentExt *Element `json:"_comment,omitempty"`
	// Moiety, for structural modifications
	Moiety []SubstanceSpecificationMoiety `json:"moiety,omitempty"`
	// General specifications for this substance, including how it is related to other substances
	Property []SubstanceSpecificationProperty `json:"property,omitempty"`
	// General information detailing this substance
	ReferenceInformation *Reference `json:"referenceInformation,omitempty"`
	// Structural information
	Structure *SubstanceSpecificationStructure `json:"structure,omitempty"`
	// Codes associated with the substance
	Code []SubstanceSpecificationCode `json:"code,omitempty"`
	// Names applicable to this substance
	Name []SubstanceSpecificationName `json:"name,omitempty"`
	// The molecular weight or weight range (for proteins, polymers or nucleic acids)
	MolecularWeight []SubstanceSpecificationStructureIsotopeMolecularWeight `json:"molecularWeight,omitempty"`
	// A link between this substance and another, with details of the relationship
	Relationship []SubstanceSpecificationRelationship `json:"relationship,omitempty"`
	// Data items specific to nucleic acids
	NucleicAcid *Reference `json:"nucleicAcid,omitempty"`
	// Data items specific to polymers
	Polymer *Reference `json:"polymer,omitempty"`
	// Data items specific to proteins
	Protein *Reference `json:"protein,omitempty"`
	// Material or taxonomic/anatomical source for the substance
	SourceMaterial *Reference `json:"sourceMaterial,omitempty"`
}

// GetResourceType returns the FHIR resource type.
func (r *SubstanceSpecification) GetResourceType() string {
	return "SubstanceSpecification"
}

// GetId returns the resource's logical ID.
func (r *SubstanceSpecification) GetId() *string {
	return r.Id
}

// SetId sets the resource's logical ID.
func (r *SubstanceSpecification) SetId(id string) {
	r.Id = &id
}

// GetMeta returns the resource's Meta element.
func (r *SubstanceSpecification) GetMeta() *Meta {
	return r.Meta
}

// SetMeta sets the resource's Meta element.
func (r *SubstanceSpecification) SetMeta(m *Meta) {
	r.Meta = m
}

// GetText returns the resource's narrative text.
func (r *SubstanceSpecification) GetText() *Narrative {
	return r.Text
}

// SetText sets the resource's narrative text.
func (r *SubstanceSpecification) SetText(t *Narrative) {
	r.Text = t
}

// GetContained returns the resource's contained resources.
func (r *SubstanceSpecification) GetContained() []Resource {
	return r.Contained
}

// GetExtension returns the resource's extensions.
func (r *SubstanceSpecification) GetExtension() []Extension {
	return r.Extension
}

// GetModifierExtension returns the resource's modifier extensions.
func (r *SubstanceSpecification) GetModifierExtension() []Extension {
	return r.ModifierExtension
}

// MarshalJSON ensures resourceType is always included in JSON output.
// HTML escaping is disabled to preserve FHIR narrative XHTML content.
//
// Note: Use the package-level Marshal function instead of json.Marshal
// to ensure HTML in narrative text.div fields is not escaped.
func (r SubstanceSpecification) MarshalJSON() ([]byte, error) {
	r.ResourceType = "SubstanceSpecification"
	type Alias SubstanceSpecification
	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	enc.SetEscapeHTML(false)
	if err := enc.Encode((Alias)(r)); err != nil {
		return nil, err
	}
	b := buf.Bytes()
	if len(b) > 0 && b[len(b)-1] == '\n' {
		b = b[:len(b)-1]
	}
	return b, nil
}

// UnmarshalJSON handles deserialization of polymorphic contained resources.
func (r *SubstanceSpecification) UnmarshalJSON(data []byte) error {
	// Use an alias to avoid infinite recursion
	type Alias SubstanceSpecification
	aux := &struct {
		Contained []json.RawMessage `json:"contained,omitempty"`
		*Alias
	}{
		Alias: (*Alias)(r),
	}

	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}

	// Unmarshal each contained resource using the dispatcher
	if len(aux.Contained) > 0 {
		r.Contained = make([]Resource, len(aux.Contained))
		for i, raw := range aux.Contained {
			resource, err := UnmarshalResource(raw)
			if err != nil {
				return fmt.Errorf("failed to unmarshal contained[%d]: %w", i, err)
			}
			r.Contained[i] = resource
		}
	}

	return nil
}

// MarshalXML serializes SubstanceSpecification to FHIR-conformant XML.
func (r SubstanceSpecification) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "SubstanceSpecification"
		start.Name.Space = fhirNamespace
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	if err := xmlEncodePrimitiveString(e, "id", r.Id, nil); err != nil {
		return err
	}
	if r.Meta != nil {
		if err := r.Meta.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "meta"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "implicitRules", r.ImplicitRules, r.ImplicitRulesExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "language", r.Language, r.LanguageExt); err != nil {
		return err
	}
	if r.Text != nil {
		if err := r.Text.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "text"}}); err != nil {
			return err
		}
	}
	for _, c := range r.Contained {
		if c != nil {
			if err := xmlEncodeContainedResource(e, c); err != nil {
				return err
			}
		}
	}
	for _, item := range r.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range r.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if r.Identifier != nil {
		if err := r.Identifier.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "identifier"}}); err != nil {
			return err
		}
	}
	if r.Type != nil {
		if err := r.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
			return err
		}
	}
	if r.Status != nil {
		if err := r.Status.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "status"}}); err != nil {
			return err
		}
	}
	if r.Domain != nil {
		if err := r.Domain.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "domain"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "description", r.Description, r.DescriptionExt); err != nil {
		return err
	}
	for _, item := range r.Source {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "source"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "comment", r.Comment, r.CommentExt); err != nil {
		return err
	}
	for _, item := range r.Moiety {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "moiety"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Property {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "property"}}); err != nil {
			return err
		}
	}
	if r.ReferenceInformation != nil {
		if err := r.ReferenceInformation.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "referenceInformation"}}); err != nil {
			return err
		}
	}
	if r.Structure != nil {
		if err := r.Structure.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "structure"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Code {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "code"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Name {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "name"}}); err != nil {
			return err
		}
	}
	for _, item := range r.MolecularWeight {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "molecularWeight"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Relationship {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "relationship"}}); err != nil {
			return err
		}
	}
	if r.NucleicAcid != nil {
		if err := r.NucleicAcid.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "nucleicAcid"}}); err != nil {
			return err
		}
	}
	if r.Polymer != nil {
		if err := r.Polymer.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "polymer"}}); err != nil {
			return err
		}
	}
	if r.Protein != nil {
		if err := r.Protein.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "protein"}}); err != nil {
			return err
		}
	}
	if r.SourceMaterial != nil {
		if err := r.SourceMaterial.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "sourceMaterial"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes SubstanceSpecification from FHIR-conformant XML.
func (r *SubstanceSpecification) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "id":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Id = v
			case "meta":
				var v Meta
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Meta = &v
			case "implicitRules":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ImplicitRules = v
				r.ImplicitRulesExt = ext
			case "language":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Language = v
				r.LanguageExt = ext
			case "text":
				var v Narrative
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Text = &v
			case "contained":
				res, err := xmlDecodeContainedResource(d, t)
				if err != nil {
					return err
				}
				if res != nil {
					r.Contained = append(r.Contained, res)
				}
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "identifier":
				var v Identifier
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Identifier = &v
			case "type":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Type = &v
			case "status":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Status = &v
			case "domain":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Domain = &v
			case "description":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Description = v
				r.DescriptionExt = ext
			case "source":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Source = append(r.Source, v)
			case "comment":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Comment = v
				r.CommentExt = ext
			case "moiety":
				var v SubstanceSpecificationMoiety
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Moiety = append(r.Moiety, v)
			case "property":
				var v SubstanceSpecificationProperty
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Property = append(r.Property, v)
			case "referenceInformation":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ReferenceInformation = &v
			case "structure":
				var v SubstanceSpecificationStructure
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Structure = &v
			case "code":
				var v SubstanceSpecificationCode
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Code = append(r.Code, v)
			case "name":
				var v SubstanceSpecificationName
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Name = append(r.Name, v)
			case "molecularWeight":
				var v SubstanceSpecificationStructureIsotopeMolecularWeight
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.MolecularWeight = append(r.MolecularWeight, v)
			case "relationship":
				var v SubstanceSpecificationRelationship
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Relationship = append(r.Relationship, v)
			case "nucleicAcid":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.NucleicAcid = &v
			case "polymer":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Polymer = &v
			case "protein":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Protein = &v
			case "sourceMaterial":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.SourceMaterial = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// SubstanceSpecificationCode represents the SubstanceSpecification.code backbone element.
// Codes associated with the substance
type SubstanceSpecificationCode struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The specific code
	Code *CodeableConcept `json:"code,omitempty"`
	// Status of the code assignment
	Status *CodeableConcept `json:"status,omitempty"`
	// The date at which the code status is changed as part of the terminology maintenance
	StatusDate *string `json:"statusDate,omitempty"`
	// Any comment can be provided in this field, if necessary
	Comment *string `json:"comment,omitempty"`
	// Supporting literature
	Source []Reference `json:"source,omitempty"`
}

// MarshalXML serializes SubstanceSpecificationCode to FHIR-conformant XML.
func (b SubstanceSpecificationCode) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "SubstanceSpecification.code"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.Code != nil {
		if err := b.Code.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "code"}}); err != nil {
			return err
		}
	}
	if b.Status != nil {
		if err := b.Status.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "status"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "statusDate", b.StatusDate, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "comment", b.Comment, nil); err != nil {
		return err
	}
	for _, item := range b.Source {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "source"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes SubstanceSpecificationCode from FHIR-conformant XML.
func (r *SubstanceSpecificationCode) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "code":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Code = &v
			case "status":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Status = &v
			case "statusDate":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.StatusDate = v
			case "comment":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Comment = v
			case "source":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Source = append(r.Source, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// SubstanceSpecificationMoiety represents the SubstanceSpecification.moiety backbone element.
// Moiety, for structural modifications
type SubstanceSpecificationMoiety struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Role that the moiety is playing
	Role *CodeableConcept `json:"role,omitempty"`
	// Identifier by which this moiety substance is known
	Identifier *Identifier `json:"identifier,omitempty"`
	// Textual name for this moiety substance
	Name *string `json:"name,omitempty"`
	// Stereochemistry type
	Stereochemistry *CodeableConcept `json:"stereochemistry,omitempty"`
	// Optical activity type
	OpticalActivity *CodeableConcept `json:"opticalActivity,omitempty"`
	// Molecular formula
	MolecularFormula *string `json:"molecularFormula,omitempty"`
	// Quantitative value for this moiety
	AmountQuantity *Quantity `json:"amountQuantity,omitempty"`
	// Quantitative value for this moiety
	AmountString *string `json:"amountString,omitempty"`
	// Extension for AmountString
	AmountStringExt *Element `json:"_amountString,omitempty"`
}

// MarshalXML serializes SubstanceSpecificationMoiety to FHIR-conformant XML.
func (b SubstanceSpecificationMoiety) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "SubstanceSpecification.moiety"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.Role != nil {
		if err := b.Role.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "role"}}); err != nil {
			return err
		}
	}
	if b.Identifier != nil {
		if err := b.Identifier.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "identifier"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "name", b.Name, nil); err != nil {
		return err
	}
	if b.Stereochemistry != nil {
		if err := b.Stereochemistry.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "stereochemistry"}}); err != nil {
			return err
		}
	}
	if b.OpticalActivity != nil {
		if err := b.OpticalActivity.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "opticalActivity"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "molecularFormula", b.MolecularFormula, nil); err != nil {
		return err
	}
	if b.AmountQuantity != nil {
		if err := b.AmountQuantity.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "amountQuantity"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "amountString", b.AmountString, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes SubstanceSpecificationMoiety from FHIR-conformant XML.
func (r *SubstanceSpecificationMoiety) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "role":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Role = &v
			case "identifier":
				var v Identifier
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Identifier = &v
			case "name":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Name = v
			case "stereochemistry":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Stereochemistry = &v
			case "opticalActivity":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.OpticalActivity = &v
			case "molecularFormula":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.MolecularFormula = v
			case "amountQuantity":
				var v Quantity
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.AmountQuantity = &v
			case "amountString":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.AmountString = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// SubstanceSpecificationName represents the SubstanceSpecification.name backbone element.
// Names applicable to this substance
type SubstanceSpecificationName struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The actual name
	Name *string `json:"name,omitempty"`
	// Name type
	Type *CodeableConcept `json:"type,omitempty"`
	// The status of the name
	Status *CodeableConcept `json:"status,omitempty"`
	// If this is the preferred name for this substance
	Preferred *bool `json:"preferred,omitempty"`
	// Language of the name
	Language []CodeableConcept `json:"language,omitempty"`
	// The use context of this name for example if there is a different name a drug active ingredient as opposed to a food colour additive
	Domain []CodeableConcept `json:"domain,omitempty"`
	// The jurisdiction where this name applies
	Jurisdiction []CodeableConcept `json:"jurisdiction,omitempty"`
	// A synonym of this name
	Synonym []SubstanceSpecificationName `json:"synonym,omitempty"`
	// A translation for this name
	Translation []SubstanceSpecificationName `json:"translation,omitempty"`
	// Details of the official nature of this name
	Official []SubstanceSpecificationNameOfficial `json:"official,omitempty"`
	// Supporting literature
	Source []Reference `json:"source,omitempty"`
}

// MarshalXML serializes SubstanceSpecificationName to FHIR-conformant XML.
func (b SubstanceSpecificationName) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "SubstanceSpecification.name"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "name", b.Name, nil); err != nil {
		return err
	}
	if b.Type != nil {
		if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
			return err
		}
	}
	if b.Status != nil {
		if err := b.Status.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "status"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveBool(e, "preferred", b.Preferred, nil); err != nil {
		return err
	}
	for _, item := range b.Language {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "language"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Domain {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "domain"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Jurisdiction {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "jurisdiction"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Synonym {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "synonym"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Translation {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "translation"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Official {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "official"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Source {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "source"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes SubstanceSpecificationName from FHIR-conformant XML.
func (r *SubstanceSpecificationName) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "name":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Name = v
			case "type":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Type = &v
			case "status":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Status = &v
			case "preferred":
				v, _, err := xmlDecodePrimitiveBool(d, t)
				if err != nil {
					return err
				}
				r.Preferred = v
			case "language":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Language = append(r.Language, v)
			case "domain":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Domain = append(r.Domain, v)
			case "jurisdiction":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Jurisdiction = append(r.Jurisdiction, v)
			case "synonym":
				var v SubstanceSpecificationName
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Synonym = append(r.Synonym, v)
			case "translation":
				var v SubstanceSpecificationName
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Translation = append(r.Translation, v)
			case "official":
				var v SubstanceSpecificationNameOfficial
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Official = append(r.Official, v)
			case "source":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Source = append(r.Source, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// SubstanceSpecificationNameOfficial represents the SubstanceSpecification.name.official backbone element.
// Details of the official nature of this name
type SubstanceSpecificationNameOfficial struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Which authority uses this official name
	Authority *CodeableConcept `json:"authority,omitempty"`
	// The status of the official name
	Status *CodeableConcept `json:"status,omitempty"`
	// Date of official name change
	Date *string `json:"date,omitempty"`
}

// MarshalXML serializes SubstanceSpecificationNameOfficial to FHIR-conformant XML.
func (b SubstanceSpecificationNameOfficial) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "SubstanceSpecification.name.official"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.Authority != nil {
		if err := b.Authority.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "authority"}}); err != nil {
			return err
		}
	}
	if b.Status != nil {
		if err := b.Status.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "status"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "date", b.Date, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes SubstanceSpecificationNameOfficial from FHIR-conformant XML.
func (r *SubstanceSpecificationNameOfficial) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "authority":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Authority = &v
			case "status":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Status = &v
			case "date":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Date = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// SubstanceSpecificationProperty represents the SubstanceSpecification.property backbone element.
// General specifications for this substance, including how it is related to other substances
type SubstanceSpecificationProperty struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// A category for this property, e.g. Physical, Chemical, Enzymatic
	Category *CodeableConcept `json:"category,omitempty"`
	// Property type e.g. viscosity, pH, isoelectric point
	Code *CodeableConcept `json:"code,omitempty"`
	// Parameters that were used in the measurement of a property (e.g. for viscosity: measured at 20C with a pH of 7.1)
	Parameters *string `json:"parameters,omitempty"`
	// A substance upon which a defining property depends (e.g. for solubility: in water, in alcohol)
	DefiningSubstanceReference *Reference `json:"definingSubstanceReference,omitempty"`
	// A substance upon which a defining property depends (e.g. for solubility: in water, in alcohol)
	DefiningSubstanceCodeableConcept *CodeableConcept `json:"definingSubstanceCodeableConcept,omitempty"`
	// Quantitative value for this property
	AmountQuantity *Quantity `json:"amountQuantity,omitempty"`
	// Quantitative value for this property
	AmountString *string `json:"amountString,omitempty"`
	// Extension for AmountString
	AmountStringExt *Element `json:"_amountString,omitempty"`
}

// MarshalXML serializes SubstanceSpecificationProperty to FHIR-conformant XML.
func (b SubstanceSpecificationProperty) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "SubstanceSpecification.property"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.Category != nil {
		if err := b.Category.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "category"}}); err != nil {
			return err
		}
	}
	if b.Code != nil {
		if err := b.Code.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "code"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "parameters", b.Parameters, nil); err != nil {
		return err
	}
	if b.DefiningSubstanceReference != nil {
		if err := b.DefiningSubstanceReference.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "definingSubstanceReference"}}); err != nil {
			return err
		}
	}
	if b.DefiningSubstanceCodeableConcept != nil {
		if err := b.DefiningSubstanceCodeableConcept.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "definingSubstanceCodeableConcept"}}); err != nil {
			return err
		}
	}
	if b.AmountQuantity != nil {
		if err := b.AmountQuantity.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "amountQuantity"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "amountString", b.AmountString, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes SubstanceSpecificationProperty from FHIR-conformant XML.
func (r *SubstanceSpecificationProperty) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "category":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Category = &v
			case "code":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Code = &v
			case "parameters":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Parameters = v
			case "definingSubstanceReference":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.DefiningSubstanceReference = &v
			case "definingSubstanceCodeableConcept":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.DefiningSubstanceCodeableConcept = &v
			case "amountQuantity":
				var v Quantity
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.AmountQuantity = &v
			case "amountString":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.AmountString = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// SubstanceSpecificationRelationship represents the SubstanceSpecification.relationship backbone element.
// A link between this substance and another, with details of the relationship
type SubstanceSpecificationRelationship struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// A pointer to another substance, as a resource or just a representational code
	SubstanceReference *Reference `json:"substanceReference,omitempty"`
	// A pointer to another substance, as a resource or just a representational code
	SubstanceCodeableConcept *CodeableConcept `json:"substanceCodeableConcept,omitempty"`
	// For example "salt to parent", "active moiety", "starting material"
	Relationship *CodeableConcept `json:"relationship,omitempty"`
	// For example where an enzyme strongly bonds with a particular substance, this is a defining relationship for that enzyme, out of several possible substance relationships
	IsDefining *bool `json:"isDefining,omitempty"`
	// A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other
	AmountQuantity *Quantity `json:"amountQuantity,omitempty"`
	// A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other
	AmountRange *Range `json:"amountRange,omitempty"`
	// A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other
	AmountRatio *Ratio `json:"amountRatio,omitempty"`
	// A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other
	AmountString *string `json:"amountString,omitempty"`
	// Extension for AmountString
	AmountStringExt *Element `json:"_amountString,omitempty"`
	// For use when the numeric
	AmountRatioLowLimit *Ratio `json:"amountRatioLowLimit,omitempty"`
	// An operator for the amount, for example "average", "approximately", "less than"
	AmountType *CodeableConcept `json:"amountType,omitempty"`
	// Supporting literature
	Source []Reference `json:"source,omitempty"`
}

// MarshalXML serializes SubstanceSpecificationRelationship to FHIR-conformant XML.
func (b SubstanceSpecificationRelationship) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "SubstanceSpecification.relationship"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.SubstanceReference != nil {
		if err := b.SubstanceReference.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "substanceReference"}}); err != nil {
			return err
		}
	}
	if b.SubstanceCodeableConcept != nil {
		if err := b.SubstanceCodeableConcept.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "substanceCodeableConcept"}}); err != nil {
			return err
		}
	}
	if b.Relationship != nil {
		if err := b.Relationship.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "relationship"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveBool(e, "isDefining", b.IsDefining, nil); err != nil {
		return err
	}
	if b.AmountQuantity != nil {
		if err := b.AmountQuantity.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "amountQuantity"}}); err != nil {
			return err
		}
	}
	if b.AmountRange != nil {
		if err := b.AmountRange.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "amountRange"}}); err != nil {
			return err
		}
	}
	if b.AmountRatio != nil {
		if err := b.AmountRatio.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "amountRatio"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "amountString", b.AmountString, nil); err != nil {
		return err
	}
	if b.AmountRatioLowLimit != nil {
		if err := b.AmountRatioLowLimit.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "amountRatioLowLimit"}}); err != nil {
			return err
		}
	}
	if b.AmountType != nil {
		if err := b.AmountType.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "amountType"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Source {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "source"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes SubstanceSpecificationRelationship from FHIR-conformant XML.
func (r *SubstanceSpecificationRelationship) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "substanceReference":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.SubstanceReference = &v
			case "substanceCodeableConcept":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.SubstanceCodeableConcept = &v
			case "relationship":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Relationship = &v
			case "isDefining":
				v, _, err := xmlDecodePrimitiveBool(d, t)
				if err != nil {
					return err
				}
				r.IsDefining = v
			case "amountQuantity":
				var v Quantity
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.AmountQuantity = &v
			case "amountRange":
				var v Range
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.AmountRange = &v
			case "amountRatio":
				var v Ratio
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.AmountRatio = &v
			case "amountString":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.AmountString = v
			case "amountRatioLowLimit":
				var v Ratio
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.AmountRatioLowLimit = &v
			case "amountType":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.AmountType = &v
			case "source":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Source = append(r.Source, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// SubstanceSpecificationStructure represents the SubstanceSpecification.structure backbone element.
// Structural information
type SubstanceSpecificationStructure struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Stereochemistry type
	Stereochemistry *CodeableConcept `json:"stereochemistry,omitempty"`
	// Optical activity type
	OpticalActivity *CodeableConcept `json:"opticalActivity,omitempty"`
	// Molecular formula
	MolecularFormula *string `json:"molecularFormula,omitempty"`
	// Specified per moiety according to the Hill system, i.e. first C, then H, then alphabetical, each moiety separated by a dot
	MolecularFormulaByMoiety *string `json:"molecularFormulaByMoiety,omitempty"`
	// Applicable for single substances that contain a radionuclide or a non-natural isotopic ratio
	Isotope []SubstanceSpecificationStructureIsotope `json:"isotope,omitempty"`
	// The molecular weight or weight range (for proteins, polymers or nucleic acids)
	MolecularWeight *SubstanceSpecificationStructureIsotopeMolecularWeight `json:"molecularWeight,omitempty"`
	// Supporting literature
	Source []Reference `json:"source,omitempty"`
	// Molecular structural representation
	Representation []SubstanceSpecificationStructureRepresentation `json:"representation,omitempty"`
}

// MarshalXML serializes SubstanceSpecificationStructure to FHIR-conformant XML.
func (b SubstanceSpecificationStructure) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "SubstanceSpecification.structure"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.Stereochemistry != nil {
		if err := b.Stereochemistry.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "stereochemistry"}}); err != nil {
			return err
		}
	}
	if b.OpticalActivity != nil {
		if err := b.OpticalActivity.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "opticalActivity"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "molecularFormula", b.MolecularFormula, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "molecularFormulaByMoiety", b.MolecularFormulaByMoiety, nil); err != nil {
		return err
	}
	for _, item := range b.Isotope {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "isotope"}}); err != nil {
			return err
		}
	}
	if b.MolecularWeight != nil {
		if err := b.MolecularWeight.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "molecularWeight"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Source {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "source"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Representation {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "representation"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes SubstanceSpecificationStructure from FHIR-conformant XML.
func (r *SubstanceSpecificationStructure) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "stereochemistry":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Stereochemistry = &v
			case "opticalActivity":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.OpticalActivity = &v
			case "molecularFormula":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.MolecularFormula = v
			case "molecularFormulaByMoiety":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.MolecularFormulaByMoiety = v
			case "isotope":
				var v SubstanceSpecificationStructureIsotope
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Isotope = append(r.Isotope, v)
			case "molecularWeight":
				var v SubstanceSpecificationStructureIsotopeMolecularWeight
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.MolecularWeight = &v
			case "source":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Source = append(r.Source, v)
			case "representation":
				var v SubstanceSpecificationStructureRepresentation
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Representation = append(r.Representation, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// SubstanceSpecificationStructureIsotope represents the SubstanceSpecification.structure.isotope backbone element.
// Applicable for single substances that contain a radionuclide or a non-natural isotopic ratio
type SubstanceSpecificationStructureIsotope struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Substance identifier for each non-natural or radioisotope
	Identifier *Identifier `json:"identifier,omitempty"`
	// Substance name for each non-natural or radioisotope
	Name *CodeableConcept `json:"name,omitempty"`
	// The type of isotopic substitution present in a single substance
	Substitution *CodeableConcept `json:"substitution,omitempty"`
	// Half life - for a non-natural nuclide
	HalfLife *Quantity `json:"halfLife,omitempty"`
	// The molecular weight or weight range (for proteins, polymers or nucleic acids)
	MolecularWeight *SubstanceSpecificationStructureIsotopeMolecularWeight `json:"molecularWeight,omitempty"`
}

// MarshalXML serializes SubstanceSpecificationStructureIsotope to FHIR-conformant XML.
func (b SubstanceSpecificationStructureIsotope) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "SubstanceSpecification.structure.isotope"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.Identifier != nil {
		if err := b.Identifier.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "identifier"}}); err != nil {
			return err
		}
	}
	if b.Name != nil {
		if err := b.Name.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "name"}}); err != nil {
			return err
		}
	}
	if b.Substitution != nil {
		if err := b.Substitution.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "substitution"}}); err != nil {
			return err
		}
	}
	if b.HalfLife != nil {
		if err := b.HalfLife.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "halfLife"}}); err != nil {
			return err
		}
	}
	if b.MolecularWeight != nil {
		if err := b.MolecularWeight.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "molecularWeight"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes SubstanceSpecificationStructureIsotope from FHIR-conformant XML.
func (r *SubstanceSpecificationStructureIsotope) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "identifier":
				var v Identifier
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Identifier = &v
			case "name":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Name = &v
			case "substitution":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Substitution = &v
			case "halfLife":
				var v Quantity
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.HalfLife = &v
			case "molecularWeight":
				var v SubstanceSpecificationStructureIsotopeMolecularWeight
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.MolecularWeight = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// SubstanceSpecificationStructureIsotopeMolecularWeight represents the SubstanceSpecification.structure.isotope.molecularWeight backbone element.
// The molecular weight or weight range (for proteins, polymers or nucleic acids)
type SubstanceSpecificationStructureIsotopeMolecularWeight struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The method by which the molecular weight was determined
	Method *CodeableConcept `json:"method,omitempty"`
	// Type of molecular weight such as exact, average (also known as. number average), weight average
	Type *CodeableConcept `json:"type,omitempty"`
	// Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field
	Amount *Quantity `json:"amount,omitempty"`
}

// MarshalXML serializes SubstanceSpecificationStructureIsotopeMolecularWeight to FHIR-conformant XML.
func (b SubstanceSpecificationStructureIsotopeMolecularWeight) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "SubstanceSpecification.structure.isotope.molecularWeight"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.Method != nil {
		if err := b.Method.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "method"}}); err != nil {
			return err
		}
	}
	if b.Type != nil {
		if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
			return err
		}
	}
	if b.Amount != nil {
		if err := b.Amount.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "amount"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes SubstanceSpecificationStructureIsotopeMolecularWeight from FHIR-conformant XML.
func (r *SubstanceSpecificationStructureIsotopeMolecularWeight) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "method":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Method = &v
			case "type":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Type = &v
			case "amount":
				var v Quantity
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Amount = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// SubstanceSpecificationStructureRepresentation represents the SubstanceSpecification.structure.representation backbone element.
// Molecular structural representation
type SubstanceSpecificationStructureRepresentation struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The type of structure (e.g. Full, Partial, Representative)
	Type *CodeableConcept `json:"type,omitempty"`
	// The structural representation as text string in a format e.g. InChI, SMILES, MOLFILE, CDX
	Representation *string `json:"representation,omitempty"`
	// An attached file with the structural representation
	Attachment *Attachment `json:"attachment,omitempty"`
}

// MarshalXML serializes SubstanceSpecificationStructureRepresentation to FHIR-conformant XML.
func (b SubstanceSpecificationStructureRepresentation) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "SubstanceSpecification.structure.representation"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.Type != nil {
		if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "representation", b.Representation, nil); err != nil {
		return err
	}
	if b.Attachment != nil {
		if err := b.Attachment.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "attachment"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes SubstanceSpecificationStructureRepresentation from FHIR-conformant XML.
func (r *SubstanceSpecificationStructureRepresentation) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "type":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Type = &v
			case "representation":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Representation = v
			case "attachment":
				var v Attachment
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Attachment = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// =============================================================================
// SubstanceSpecification - Fluent Builder
// =============================================================================

// SubstanceSpecificationBuilder provides a fluent API for constructing SubstanceSpecification resources.
type SubstanceSpecificationBuilder struct {
	substanceSpecification *SubstanceSpecification
}

// NewSubstanceSpecificationBuilder creates a new SubstanceSpecificationBuilder.
func NewSubstanceSpecificationBuilder() *SubstanceSpecificationBuilder {
	return &SubstanceSpecificationBuilder{
		substanceSpecification: &SubstanceSpecification{},
	}
}

// Build returns the constructed SubstanceSpecification resource.
func (b *SubstanceSpecificationBuilder) Build() *SubstanceSpecification {
	return b.substanceSpecification
}

// SetId sets the Id field.
func (b *SubstanceSpecificationBuilder) SetId(v string) *SubstanceSpecificationBuilder {
	b.substanceSpecification.Id = &v
	return b
}

// SetMeta sets the Meta field.
func (b *SubstanceSpecificationBuilder) SetMeta(v Meta) *SubstanceSpecificationBuilder {
	b.substanceSpecification.Meta = &v
	return b
}

// SetImplicitRules sets the ImplicitRules field.
func (b *SubstanceSpecificationBuilder) SetImplicitRules(v string) *SubstanceSpecificationBuilder {
	b.substanceSpecification.ImplicitRules = &v
	return b
}

// SetLanguage sets the Language field.
func (b *SubstanceSpecificationBuilder) SetLanguage(v string) *SubstanceSpecificationBuilder {
	b.substanceSpecification.Language = &v
	return b
}

// SetText sets the Text field.
func (b *SubstanceSpecificationBuilder) SetText(v Narrative) *SubstanceSpecificationBuilder {
	b.substanceSpecification.Text = &v
	return b
}

// AddContained adds a Contained element.
func (b *SubstanceSpecificationBuilder) AddContained(v Resource) *SubstanceSpecificationBuilder {
	b.substanceSpecification.Contained = append(b.substanceSpecification.Contained, v)
	return b
}

// AddExtension adds a Extension element.
func (b *SubstanceSpecificationBuilder) AddExtension(v Extension) *SubstanceSpecificationBuilder {
	b.substanceSpecification.Extension = append(b.substanceSpecification.Extension, v)
	return b
}

// AddModifierExtension adds a ModifierExtension element.
func (b *SubstanceSpecificationBuilder) AddModifierExtension(v Extension) *SubstanceSpecificationBuilder {
	b.substanceSpecification.ModifierExtension = append(b.substanceSpecification.ModifierExtension, v)
	return b
}

// SetIdentifier sets the Identifier field.
func (b *SubstanceSpecificationBuilder) SetIdentifier(v Identifier) *SubstanceSpecificationBuilder {
	b.substanceSpecification.Identifier = &v
	return b
}

// SetType sets the Type field.
func (b *SubstanceSpecificationBuilder) SetType(v CodeableConcept) *SubstanceSpecificationBuilder {
	b.substanceSpecification.Type = &v
	return b
}

// SetStatus sets the Status field.
func (b *SubstanceSpecificationBuilder) SetStatus(v CodeableConcept) *SubstanceSpecificationBuilder {
	b.substanceSpecification.Status = &v
	return b
}

// SetDomain sets the Domain field.
func (b *SubstanceSpecificationBuilder) SetDomain(v CodeableConcept) *SubstanceSpecificationBuilder {
	b.substanceSpecification.Domain = &v
	return b
}

// SetDescription sets the Description field.
func (b *SubstanceSpecificationBuilder) SetDescription(v string) *SubstanceSpecificationBuilder {
	b.substanceSpecification.Description = &v
	return b
}

// AddSource adds a Source element.
func (b *SubstanceSpecificationBuilder) AddSource(v Reference) *SubstanceSpecificationBuilder {
	b.substanceSpecification.Source = append(b.substanceSpecification.Source, v)
	return b
}

// SetComment sets the Comment field.
func (b *SubstanceSpecificationBuilder) SetComment(v string) *SubstanceSpecificationBuilder {
	b.substanceSpecification.Comment = &v
	return b
}

// AddMoiety adds a Moiety element.
func (b *SubstanceSpecificationBuilder) AddMoiety(v SubstanceSpecificationMoiety) *SubstanceSpecificationBuilder {
	b.substanceSpecification.Moiety = append(b.substanceSpecification.Moiety, v)
	return b
}

// AddProperty adds a Property element.
func (b *SubstanceSpecificationBuilder) AddProperty(v SubstanceSpecificationProperty) *SubstanceSpecificationBuilder {
	b.substanceSpecification.Property = append(b.substanceSpecification.Property, v)
	return b
}

// SetReferenceInformation sets the ReferenceInformation field.
func (b *SubstanceSpecificationBuilder) SetReferenceInformation(v Reference) *SubstanceSpecificationBuilder {
	b.substanceSpecification.ReferenceInformation = &v
	return b
}

// SetStructure sets the Structure field.
func (b *SubstanceSpecificationBuilder) SetStructure(v SubstanceSpecificationStructure) *SubstanceSpecificationBuilder {
	b.substanceSpecification.Structure = &v
	return b
}

// AddCode adds a Code element.
func (b *SubstanceSpecificationBuilder) AddCode(v SubstanceSpecificationCode) *SubstanceSpecificationBuilder {
	b.substanceSpecification.Code = append(b.substanceSpecification.Code, v)
	return b
}

// AddName adds a Name element.
func (b *SubstanceSpecificationBuilder) AddName(v SubstanceSpecificationName) *SubstanceSpecificationBuilder {
	b.substanceSpecification.Name = append(b.substanceSpecification.Name, v)
	return b
}

// AddMolecularWeight adds a MolecularWeight element.
func (b *SubstanceSpecificationBuilder) AddMolecularWeight(v SubstanceSpecificationStructureIsotopeMolecularWeight) *SubstanceSpecificationBuilder {
	b.substanceSpecification.MolecularWeight = append(b.substanceSpecification.MolecularWeight, v)
	return b
}

// AddRelationship adds a Relationship element.
func (b *SubstanceSpecificationBuilder) AddRelationship(v SubstanceSpecificationRelationship) *SubstanceSpecificationBuilder {
	b.substanceSpecification.Relationship = append(b.substanceSpecification.Relationship, v)
	return b
}

// SetNucleicAcid sets the NucleicAcid field.
func (b *SubstanceSpecificationBuilder) SetNucleicAcid(v Reference) *SubstanceSpecificationBuilder {
	b.substanceSpecification.NucleicAcid = &v
	return b
}

// SetPolymer sets the Polymer field.
func (b *SubstanceSpecificationBuilder) SetPolymer(v Reference) *SubstanceSpecificationBuilder {
	b.substanceSpecification.Polymer = &v
	return b
}

// SetProtein sets the Protein field.
func (b *SubstanceSpecificationBuilder) SetProtein(v Reference) *SubstanceSpecificationBuilder {
	b.substanceSpecification.Protein = &v
	return b
}

// SetSourceMaterial sets the SourceMaterial field.
func (b *SubstanceSpecificationBuilder) SetSourceMaterial(v Reference) *SubstanceSpecificationBuilder {
	b.substanceSpecification.SourceMaterial = &v
	return b
}

// =============================================================================
// SubstanceSpecification - Functional Options
// =============================================================================

// SubstanceSpecificationOption is a functional option for configuring a SubstanceSpecification.
type SubstanceSpecificationOption func(*SubstanceSpecification)

// NewSubstanceSpecification creates a new SubstanceSpecification with the given options.
func NewSubstanceSpecification(opts ...SubstanceSpecificationOption) *SubstanceSpecification {
	r := &SubstanceSpecification{}
	for _, opt := range opts {
		opt(r)
	}
	return r
}

// WithSubstanceSpecificationId sets the Id field.
func WithSubstanceSpecificationId(v string) SubstanceSpecificationOption {
	return func(r *SubstanceSpecification) {
		r.Id = &v
	}
}

// WithSubstanceSpecificationMeta sets the Meta field.
func WithSubstanceSpecificationMeta(v Meta) SubstanceSpecificationOption {
	return func(r *SubstanceSpecification) {
		r.Meta = &v
	}
}

// WithSubstanceSpecificationImplicitRules sets the ImplicitRules field.
func WithSubstanceSpecificationImplicitRules(v string) SubstanceSpecificationOption {
	return func(r *SubstanceSpecification) {
		r.ImplicitRules = &v
	}
}

// WithSubstanceSpecificationLanguage sets the Language field.
func WithSubstanceSpecificationLanguage(v string) SubstanceSpecificationOption {
	return func(r *SubstanceSpecification) {
		r.Language = &v
	}
}

// WithSubstanceSpecificationText sets the Text field.
func WithSubstanceSpecificationText(v Narrative) SubstanceSpecificationOption {
	return func(r *SubstanceSpecification) {
		r.Text = &v
	}
}

// WithSubstanceSpecificationContained adds a Contained to the SubstanceSpecification.
func WithSubstanceSpecificationContained(v Resource) SubstanceSpecificationOption {
	return func(r *SubstanceSpecification) {
		r.Contained = append(r.Contained, v)
	}
}

// WithSubstanceSpecificationExtension adds a Extension to the SubstanceSpecification.
func WithSubstanceSpecificationExtension(v Extension) SubstanceSpecificationOption {
	return func(r *SubstanceSpecification) {
		r.Extension = append(r.Extension, v)
	}
}

// WithSubstanceSpecificationModifierExtension adds a ModifierExtension to the SubstanceSpecification.
func WithSubstanceSpecificationModifierExtension(v Extension) SubstanceSpecificationOption {
	return func(r *SubstanceSpecification) {
		r.ModifierExtension = append(r.ModifierExtension, v)
	}
}

// WithSubstanceSpecificationIdentifier sets the Identifier field.
func WithSubstanceSpecificationIdentifier(v Identifier) SubstanceSpecificationOption {
	return func(r *SubstanceSpecification) {
		r.Identifier = &v
	}
}

// WithSubstanceSpecificationType sets the Type field.
func WithSubstanceSpecificationType(v CodeableConcept) SubstanceSpecificationOption {
	return func(r *SubstanceSpecification) {
		r.Type = &v
	}
}

// WithSubstanceSpecificationStatus sets the Status field.
func WithSubstanceSpecificationStatus(v CodeableConcept) SubstanceSpecificationOption {
	return func(r *SubstanceSpecification) {
		r.Status = &v
	}
}

// WithSubstanceSpecificationDomain sets the Domain field.
func WithSubstanceSpecificationDomain(v CodeableConcept) SubstanceSpecificationOption {
	return func(r *SubstanceSpecification) {
		r.Domain = &v
	}
}

// WithSubstanceSpecificationDescription sets the Description field.
func WithSubstanceSpecificationDescription(v string) SubstanceSpecificationOption {
	return func(r *SubstanceSpecification) {
		r.Description = &v
	}
}

// WithSubstanceSpecificationSource adds a Source to the SubstanceSpecification.
func WithSubstanceSpecificationSource(v Reference) SubstanceSpecificationOption {
	return func(r *SubstanceSpecification) {
		r.Source = append(r.Source, v)
	}
}

// WithSubstanceSpecificationComment sets the Comment field.
func WithSubstanceSpecificationComment(v string) SubstanceSpecificationOption {
	return func(r *SubstanceSpecification) {
		r.Comment = &v
	}
}

// WithSubstanceSpecificationMoiety adds a Moiety to the SubstanceSpecification.
func WithSubstanceSpecificationMoiety(v SubstanceSpecificationMoiety) SubstanceSpecificationOption {
	return func(r *SubstanceSpecification) {
		r.Moiety = append(r.Moiety, v)
	}
}

// WithSubstanceSpecificationProperty adds a Property to the SubstanceSpecification.
func WithSubstanceSpecificationProperty(v SubstanceSpecificationProperty) SubstanceSpecificationOption {
	return func(r *SubstanceSpecification) {
		r.Property = append(r.Property, v)
	}
}

// WithSubstanceSpecificationReferenceInformation sets the ReferenceInformation field.
func WithSubstanceSpecificationReferenceInformation(v Reference) SubstanceSpecificationOption {
	return func(r *SubstanceSpecification) {
		r.ReferenceInformation = &v
	}
}

// WithSubstanceSpecificationStructure sets the Structure field.
func WithSubstanceSpecificationStructure(v SubstanceSpecificationStructure) SubstanceSpecificationOption {
	return func(r *SubstanceSpecification) {
		r.Structure = &v
	}
}

// WithSubstanceSpecificationCode adds a Code to the SubstanceSpecification.
func WithSubstanceSpecificationCode(v SubstanceSpecificationCode) SubstanceSpecificationOption {
	return func(r *SubstanceSpecification) {
		r.Code = append(r.Code, v)
	}
}

// WithSubstanceSpecificationName adds a Name to the SubstanceSpecification.
func WithSubstanceSpecificationName(v SubstanceSpecificationName) SubstanceSpecificationOption {
	return func(r *SubstanceSpecification) {
		r.Name = append(r.Name, v)
	}
}

// WithSubstanceSpecificationMolecularWeight adds a MolecularWeight to the SubstanceSpecification.
func WithSubstanceSpecificationMolecularWeight(v SubstanceSpecificationStructureIsotopeMolecularWeight) SubstanceSpecificationOption {
	return func(r *SubstanceSpecification) {
		r.MolecularWeight = append(r.MolecularWeight, v)
	}
}

// WithSubstanceSpecificationRelationship adds a Relationship to the SubstanceSpecification.
func WithSubstanceSpecificationRelationship(v SubstanceSpecificationRelationship) SubstanceSpecificationOption {
	return func(r *SubstanceSpecification) {
		r.Relationship = append(r.Relationship, v)
	}
}

// WithSubstanceSpecificationNucleicAcid sets the NucleicAcid field.
func WithSubstanceSpecificationNucleicAcid(v Reference) SubstanceSpecificationOption {
	return func(r *SubstanceSpecification) {
		r.NucleicAcid = &v
	}
}

// WithSubstanceSpecificationPolymer sets the Polymer field.
func WithSubstanceSpecificationPolymer(v Reference) SubstanceSpecificationOption {
	return func(r *SubstanceSpecification) {
		r.Polymer = &v
	}
}

// WithSubstanceSpecificationProtein sets the Protein field.
func WithSubstanceSpecificationProtein(v Reference) SubstanceSpecificationOption {
	return func(r *SubstanceSpecification) {
		r.Protein = &v
	}
}

// WithSubstanceSpecificationSourceMaterial sets the SourceMaterial field.
func WithSubstanceSpecificationSourceMaterial(v Reference) SubstanceSpecificationOption {
	return func(r *SubstanceSpecification) {
		r.SourceMaterial = &v
	}
}
