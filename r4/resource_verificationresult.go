// Code generated by gofhir. DO NOT EDIT.
// Source: FHIR StructureDefinitions (consolidated resource)
// Package: r4

package r4

import (
	"bytes"
	"encoding/json"
	"encoding/xml"
	"fmt"
)

// =============================================================================
// VerificationResult Resource
// =============================================================================

// VerificationResult represents FHIR VerificationResult.
type VerificationResult struct {
	// FHIR resource type
	ResourceType string `json:"resourceType"`
	// Logical id of this artifact
	Id *string `json:"id,omitempty"`
	// Metadata about the resource
	Meta *Meta `json:"meta,omitempty"`
	// A set of rules under which this content was created
	ImplicitRules *string `json:"implicitRules,omitempty"`
	// Extension for ImplicitRules
	ImplicitRulesExt *Element `json:"_implicitRules,omitempty"`
	// Language of the resource content
	Language *string `json:"language,omitempty"`
	// Extension for Language
	LanguageExt *Element `json:"_language,omitempty"`
	// Text summary of the resource, for human interpretation
	Text *Narrative `json:"text,omitempty"`
	// Contained, inline Resources
	Contained []Resource `json:"contained,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// A resource that was validated
	Target []Reference `json:"target,omitempty"`
	// The fhirpath location(s) within the resource that was validated
	TargetLocation []string `json:"targetLocation,omitempty"`
	// Extension for TargetLocation
	TargetLocationExt []Element `json:"_targetLocation,omitempty"`
	// none | initial | periodic
	Need *CodeableConcept `json:"need,omitempty"`
	// attested | validated | in-process | req-revalid | val-fail | reval-fail
	Status *Status `json:"status,omitempty"`
	// Extension for Status
	StatusExt *Element `json:"_status,omitempty"`
	// When the validation status was updated
	StatusDate *string `json:"statusDate,omitempty"`
	// Extension for StatusDate
	StatusDateExt *Element `json:"_statusDate,omitempty"`
	// nothing | primary | multiple
	ValidationType *CodeableConcept `json:"validationType,omitempty"`
	// The primary process by which the target is validated (edit check; value set; primary source; multiple sources; standalone; in context)
	ValidationProcess []CodeableConcept `json:"validationProcess,omitempty"`
	// Frequency of revalidation
	Frequency *Timing `json:"frequency,omitempty"`
	// The date/time validation was last completed (including failed validations)
	LastPerformed *string `json:"lastPerformed,omitempty"`
	// Extension for LastPerformed
	LastPerformedExt *Element `json:"_lastPerformed,omitempty"`
	// The date when target is next validated, if appropriate
	NextScheduled *string `json:"nextScheduled,omitempty"`
	// Extension for NextScheduled
	NextScheduledExt *Element `json:"_nextScheduled,omitempty"`
	// fatal | warn | rec-only | none
	FailureAction *CodeableConcept `json:"failureAction,omitempty"`
	// Information about the primary source(s) involved in validation
	PrimarySource []VerificationResultPrimarySource `json:"primarySource,omitempty"`
	// Information about the entity attesting to information
	Attestation *VerificationResultAttestation `json:"attestation,omitempty"`
	// Information about the entity validating information
	Validator []VerificationResultValidator `json:"validator,omitempty"`
}

// GetResourceType returns the FHIR resource type.
func (r *VerificationResult) GetResourceType() string {
	return "VerificationResult"
}

// GetId returns the resource's logical ID.
func (r *VerificationResult) GetId() *string {
	return r.Id
}

// SetId sets the resource's logical ID.
func (r *VerificationResult) SetId(id string) {
	r.Id = &id
}

// GetMeta returns the resource's Meta element.
func (r *VerificationResult) GetMeta() *Meta {
	return r.Meta
}

// SetMeta sets the resource's Meta element.
func (r *VerificationResult) SetMeta(m *Meta) {
	r.Meta = m
}

// GetText returns the resource's narrative text.
func (r *VerificationResult) GetText() *Narrative {
	return r.Text
}

// SetText sets the resource's narrative text.
func (r *VerificationResult) SetText(t *Narrative) {
	r.Text = t
}

// GetContained returns the resource's contained resources.
func (r *VerificationResult) GetContained() []Resource {
	return r.Contained
}

// GetExtension returns the resource's extensions.
func (r *VerificationResult) GetExtension() []Extension {
	return r.Extension
}

// GetModifierExtension returns the resource's modifier extensions.
func (r *VerificationResult) GetModifierExtension() []Extension {
	return r.ModifierExtension
}

// MarshalJSON ensures resourceType is always included in JSON output.
// HTML escaping is disabled to preserve FHIR narrative XHTML content.
//
// Note: Use the package-level Marshal function instead of json.Marshal
// to ensure HTML in narrative text.div fields is not escaped.
func (r VerificationResult) MarshalJSON() ([]byte, error) {
	r.ResourceType = "VerificationResult"
	type Alias VerificationResult
	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	enc.SetEscapeHTML(false)
	if err := enc.Encode((Alias)(r)); err != nil {
		return nil, err
	}
	b := buf.Bytes()
	if len(b) > 0 && b[len(b)-1] == '\n' {
		b = b[:len(b)-1]
	}
	return b, nil
}

// UnmarshalJSON handles deserialization of polymorphic contained resources.
func (r *VerificationResult) UnmarshalJSON(data []byte) error {
	// Use an alias to avoid infinite recursion
	type Alias VerificationResult
	aux := &struct {
		Contained []json.RawMessage `json:"contained,omitempty"`
		*Alias
	}{
		Alias: (*Alias)(r),
	}

	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}

	// Unmarshal each contained resource using the dispatcher
	if len(aux.Contained) > 0 {
		r.Contained = make([]Resource, len(aux.Contained))
		for i, raw := range aux.Contained {
			resource, err := UnmarshalResource(raw)
			if err != nil {
				return fmt.Errorf("failed to unmarshal contained[%d]: %w", i, err)
			}
			r.Contained[i] = resource
		}
	}

	return nil
}

// MarshalXML serializes VerificationResult to FHIR-conformant XML.
func (r VerificationResult) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "VerificationResult"
		start.Name.Space = fhirNamespace
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	if err := xmlEncodePrimitiveString(e, "id", r.Id, nil); err != nil {
		return err
	}
	if r.Meta != nil {
		if err := r.Meta.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "meta"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "implicitRules", r.ImplicitRules, r.ImplicitRulesExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "language", r.Language, r.LanguageExt); err != nil {
		return err
	}
	if r.Text != nil {
		if err := r.Text.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "text"}}); err != nil {
			return err
		}
	}
	for _, c := range r.Contained {
		if c != nil {
			if err := xmlEncodeContainedResource(e, c); err != nil {
				return err
			}
		}
	}
	for _, item := range r.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range r.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Target {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "target"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveStringArray(e, "targetLocation", r.TargetLocation, r.TargetLocationExt); err != nil {
		return err
	}
	if r.Need != nil {
		if err := r.Need.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "need"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveCode(e, "status", r.Status, r.StatusExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "statusDate", r.StatusDate, r.StatusDateExt); err != nil {
		return err
	}
	if r.ValidationType != nil {
		if err := r.ValidationType.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "validationType"}}); err != nil {
			return err
		}
	}
	for _, item := range r.ValidationProcess {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "validationProcess"}}); err != nil {
			return err
		}
	}
	if r.Frequency != nil {
		if err := r.Frequency.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "frequency"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "lastPerformed", r.LastPerformed, r.LastPerformedExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "nextScheduled", r.NextScheduled, r.NextScheduledExt); err != nil {
		return err
	}
	if r.FailureAction != nil {
		if err := r.FailureAction.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "failureAction"}}); err != nil {
			return err
		}
	}
	for _, item := range r.PrimarySource {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "primarySource"}}); err != nil {
			return err
		}
	}
	if r.Attestation != nil {
		if err := r.Attestation.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "attestation"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Validator {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "validator"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes VerificationResult from FHIR-conformant XML.
func (r *VerificationResult) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "id":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Id = v
			case "meta":
				var v Meta
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Meta = &v
			case "implicitRules":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ImplicitRules = v
				r.ImplicitRulesExt = ext
			case "language":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Language = v
				r.LanguageExt = ext
			case "text":
				var v Narrative
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Text = &v
			case "contained":
				res, err := xmlDecodeContainedResource(d, t)
				if err != nil {
					return err
				}
				if res != nil {
					r.Contained = append(r.Contained, res)
				}
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "target":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Target = append(r.Target, v)
			case "targetLocation":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.TargetLocation = append(r.TargetLocation, *v)
				}
			case "need":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Need = &v
			case "status":
				v, ext, err := xmlDecodePrimitiveCode[Status](d, t)
				if err != nil {
					return err
				}
				r.Status = v
				r.StatusExt = ext
			case "statusDate":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.StatusDate = v
				r.StatusDateExt = ext
			case "validationType":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValidationType = &v
			case "validationProcess":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValidationProcess = append(r.ValidationProcess, v)
			case "frequency":
				var v Timing
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Frequency = &v
			case "lastPerformed":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.LastPerformed = v
				r.LastPerformedExt = ext
			case "nextScheduled":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.NextScheduled = v
				r.NextScheduledExt = ext
			case "failureAction":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.FailureAction = &v
			case "primarySource":
				var v VerificationResultPrimarySource
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.PrimarySource = append(r.PrimarySource, v)
			case "attestation":
				var v VerificationResultAttestation
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Attestation = &v
			case "validator":
				var v VerificationResultValidator
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Validator = append(r.Validator, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// VerificationResultAttestation represents the VerificationResult.attestation backbone element.
// Information about the entity attesting to information
type VerificationResultAttestation struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The individual or organization attesting to information
	Who *Reference `json:"who,omitempty"`
	// When the who is asserting on behalf of another (organization or individual)
	OnBehalfOf *Reference `json:"onBehalfOf,omitempty"`
	// The method by which attested information was submitted/retrieved
	CommunicationMethod *CodeableConcept `json:"communicationMethod,omitempty"`
	// The date the information was attested to
	Date *string `json:"date,omitempty"`
	// A digital identity certificate associated with the attestation source
	SourceIdentityCertificate *string `json:"sourceIdentityCertificate,omitempty"`
	// A digital identity certificate associated with the proxy entity submitting attested information on behalf of the attestation source
	ProxyIdentityCertificate *string `json:"proxyIdentityCertificate,omitempty"`
	// Proxy signature
	ProxySignature *Signature `json:"proxySignature,omitempty"`
	// Attester signature
	SourceSignature *Signature `json:"sourceSignature,omitempty"`
}

// MarshalXML serializes VerificationResultAttestation to FHIR-conformant XML.
func (b VerificationResultAttestation) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "VerificationResult.attestation"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.Who != nil {
		if err := b.Who.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "who"}}); err != nil {
			return err
		}
	}
	if b.OnBehalfOf != nil {
		if err := b.OnBehalfOf.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "onBehalfOf"}}); err != nil {
			return err
		}
	}
	if b.CommunicationMethod != nil {
		if err := b.CommunicationMethod.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "communicationMethod"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "date", b.Date, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "sourceIdentityCertificate", b.SourceIdentityCertificate, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "proxyIdentityCertificate", b.ProxyIdentityCertificate, nil); err != nil {
		return err
	}
	if b.ProxySignature != nil {
		if err := b.ProxySignature.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "proxySignature"}}); err != nil {
			return err
		}
	}
	if b.SourceSignature != nil {
		if err := b.SourceSignature.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "sourceSignature"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes VerificationResultAttestation from FHIR-conformant XML.
func (r *VerificationResultAttestation) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "who":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Who = &v
			case "onBehalfOf":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.OnBehalfOf = &v
			case "communicationMethod":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.CommunicationMethod = &v
			case "date":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Date = v
			case "sourceIdentityCertificate":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.SourceIdentityCertificate = v
			case "proxyIdentityCertificate":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ProxyIdentityCertificate = v
			case "proxySignature":
				var v Signature
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ProxySignature = &v
			case "sourceSignature":
				var v Signature
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.SourceSignature = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// VerificationResultPrimarySource represents the VerificationResult.primarySource backbone element.
// Information about the primary source(s) involved in validation
type VerificationResultPrimarySource struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Reference to the primary source
	Who *Reference `json:"who,omitempty"`
	// Type of primary source (License Board; Primary Education; Continuing Education; Postal Service; Relationship owner; Registration Authority; legal source; issuing source; authoritative source)
	Type []CodeableConcept `json:"type,omitempty"`
	// Method for exchanging information with the primary source
	CommunicationMethod []CodeableConcept `json:"communicationMethod,omitempty"`
	// successful | failed | unknown
	ValidationStatus *CodeableConcept `json:"validationStatus,omitempty"`
	// When the target was validated against the primary source
	ValidationDate *string `json:"validationDate,omitempty"`
	// yes | no | undetermined
	CanPushUpdates *CodeableConcept `json:"canPushUpdates,omitempty"`
	// specific | any | source
	PushTypeAvailable []CodeableConcept `json:"pushTypeAvailable,omitempty"`
}

// MarshalXML serializes VerificationResultPrimarySource to FHIR-conformant XML.
func (b VerificationResultPrimarySource) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "VerificationResult.primarySource"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.Who != nil {
		if err := b.Who.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "who"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Type {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
			return err
		}
	}
	for _, item := range b.CommunicationMethod {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "communicationMethod"}}); err != nil {
			return err
		}
	}
	if b.ValidationStatus != nil {
		if err := b.ValidationStatus.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "validationStatus"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "validationDate", b.ValidationDate, nil); err != nil {
		return err
	}
	if b.CanPushUpdates != nil {
		if err := b.CanPushUpdates.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "canPushUpdates"}}); err != nil {
			return err
		}
	}
	for _, item := range b.PushTypeAvailable {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "pushTypeAvailable"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes VerificationResultPrimarySource from FHIR-conformant XML.
func (r *VerificationResultPrimarySource) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "who":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Who = &v
			case "type":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Type = append(r.Type, v)
			case "communicationMethod":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.CommunicationMethod = append(r.CommunicationMethod, v)
			case "validationStatus":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValidationStatus = &v
			case "validationDate":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ValidationDate = v
			case "canPushUpdates":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.CanPushUpdates = &v
			case "pushTypeAvailable":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.PushTypeAvailable = append(r.PushTypeAvailable, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// VerificationResultValidator represents the VerificationResult.validator backbone element.
// Information about the entity validating information
type VerificationResultValidator struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Reference to the organization validating information
	Organization Reference `json:"organization,omitempty"`
	// A digital identity certificate associated with the validator
	IdentityCertificate *string `json:"identityCertificate,omitempty"`
	// Validator signature
	AttestationSignature *Signature `json:"attestationSignature,omitempty"`
}

// MarshalXML serializes VerificationResultValidator to FHIR-conformant XML.
func (b VerificationResultValidator) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "VerificationResult.validator"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := b.Organization.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "organization"}}); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "identityCertificate", b.IdentityCertificate, nil); err != nil {
		return err
	}
	if b.AttestationSignature != nil {
		if err := b.AttestationSignature.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "attestationSignature"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes VerificationResultValidator from FHIR-conformant XML.
func (r *VerificationResultValidator) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "organization":
				if err := r.Organization.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "identityCertificate":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.IdentityCertificate = v
			case "attestationSignature":
				var v Signature
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.AttestationSignature = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// =============================================================================
// VerificationResult - Fluent Builder
// =============================================================================

// VerificationResultBuilder provides a fluent API for constructing VerificationResult resources.
type VerificationResultBuilder struct {
	verificationResult *VerificationResult
}

// NewVerificationResultBuilder creates a new VerificationResultBuilder.
func NewVerificationResultBuilder() *VerificationResultBuilder {
	return &VerificationResultBuilder{
		verificationResult: &VerificationResult{},
	}
}

// Build returns the constructed VerificationResult resource.
func (b *VerificationResultBuilder) Build() *VerificationResult {
	return b.verificationResult
}

// SetId sets the Id field.
func (b *VerificationResultBuilder) SetId(v string) *VerificationResultBuilder {
	b.verificationResult.Id = &v
	return b
}

// SetMeta sets the Meta field.
func (b *VerificationResultBuilder) SetMeta(v Meta) *VerificationResultBuilder {
	b.verificationResult.Meta = &v
	return b
}

// SetImplicitRules sets the ImplicitRules field.
func (b *VerificationResultBuilder) SetImplicitRules(v string) *VerificationResultBuilder {
	b.verificationResult.ImplicitRules = &v
	return b
}

// SetLanguage sets the Language field.
func (b *VerificationResultBuilder) SetLanguage(v string) *VerificationResultBuilder {
	b.verificationResult.Language = &v
	return b
}

// SetText sets the Text field.
func (b *VerificationResultBuilder) SetText(v Narrative) *VerificationResultBuilder {
	b.verificationResult.Text = &v
	return b
}

// AddContained adds a Contained element.
func (b *VerificationResultBuilder) AddContained(v Resource) *VerificationResultBuilder {
	b.verificationResult.Contained = append(b.verificationResult.Contained, v)
	return b
}

// AddExtension adds a Extension element.
func (b *VerificationResultBuilder) AddExtension(v Extension) *VerificationResultBuilder {
	b.verificationResult.Extension = append(b.verificationResult.Extension, v)
	return b
}

// AddModifierExtension adds a ModifierExtension element.
func (b *VerificationResultBuilder) AddModifierExtension(v Extension) *VerificationResultBuilder {
	b.verificationResult.ModifierExtension = append(b.verificationResult.ModifierExtension, v)
	return b
}

// AddTarget adds a Target element.
func (b *VerificationResultBuilder) AddTarget(v Reference) *VerificationResultBuilder {
	b.verificationResult.Target = append(b.verificationResult.Target, v)
	return b
}

// AddTargetLocation adds a TargetLocation element.
func (b *VerificationResultBuilder) AddTargetLocation(v string) *VerificationResultBuilder {
	b.verificationResult.TargetLocation = append(b.verificationResult.TargetLocation, v)
	return b
}

// SetNeed sets the Need field.
func (b *VerificationResultBuilder) SetNeed(v CodeableConcept) *VerificationResultBuilder {
	b.verificationResult.Need = &v
	return b
}

// SetStatus sets the Status field.
func (b *VerificationResultBuilder) SetStatus(v Status) *VerificationResultBuilder {
	b.verificationResult.Status = &v
	return b
}

// SetStatusDate sets the StatusDate field.
func (b *VerificationResultBuilder) SetStatusDate(v string) *VerificationResultBuilder {
	b.verificationResult.StatusDate = &v
	return b
}

// SetValidationType sets the ValidationType field.
func (b *VerificationResultBuilder) SetValidationType(v CodeableConcept) *VerificationResultBuilder {
	b.verificationResult.ValidationType = &v
	return b
}

// AddValidationProcess adds a ValidationProcess element.
func (b *VerificationResultBuilder) AddValidationProcess(v CodeableConcept) *VerificationResultBuilder {
	b.verificationResult.ValidationProcess = append(b.verificationResult.ValidationProcess, v)
	return b
}

// SetFrequency sets the Frequency field.
func (b *VerificationResultBuilder) SetFrequency(v Timing) *VerificationResultBuilder {
	b.verificationResult.Frequency = &v
	return b
}

// SetLastPerformed sets the LastPerformed field.
func (b *VerificationResultBuilder) SetLastPerformed(v string) *VerificationResultBuilder {
	b.verificationResult.LastPerformed = &v
	return b
}

// SetNextScheduled sets the NextScheduled field.
func (b *VerificationResultBuilder) SetNextScheduled(v string) *VerificationResultBuilder {
	b.verificationResult.NextScheduled = &v
	return b
}

// SetFailureAction sets the FailureAction field.
func (b *VerificationResultBuilder) SetFailureAction(v CodeableConcept) *VerificationResultBuilder {
	b.verificationResult.FailureAction = &v
	return b
}

// AddPrimarySource adds a PrimarySource element.
func (b *VerificationResultBuilder) AddPrimarySource(v VerificationResultPrimarySource) *VerificationResultBuilder {
	b.verificationResult.PrimarySource = append(b.verificationResult.PrimarySource, v)
	return b
}

// SetAttestation sets the Attestation field.
func (b *VerificationResultBuilder) SetAttestation(v VerificationResultAttestation) *VerificationResultBuilder {
	b.verificationResult.Attestation = &v
	return b
}

// AddValidator adds a Validator element.
func (b *VerificationResultBuilder) AddValidator(v VerificationResultValidator) *VerificationResultBuilder {
	b.verificationResult.Validator = append(b.verificationResult.Validator, v)
	return b
}

// =============================================================================
// VerificationResult - Functional Options
// =============================================================================

// VerificationResultOption is a functional option for configuring a VerificationResult.
type VerificationResultOption func(*VerificationResult)

// NewVerificationResult creates a new VerificationResult with the given options.
func NewVerificationResult(opts ...VerificationResultOption) *VerificationResult {
	r := &VerificationResult{}
	for _, opt := range opts {
		opt(r)
	}
	return r
}

// WithVerificationResultId sets the Id field.
func WithVerificationResultId(v string) VerificationResultOption {
	return func(r *VerificationResult) {
		r.Id = &v
	}
}

// WithVerificationResultMeta sets the Meta field.
func WithVerificationResultMeta(v Meta) VerificationResultOption {
	return func(r *VerificationResult) {
		r.Meta = &v
	}
}

// WithVerificationResultImplicitRules sets the ImplicitRules field.
func WithVerificationResultImplicitRules(v string) VerificationResultOption {
	return func(r *VerificationResult) {
		r.ImplicitRules = &v
	}
}

// WithVerificationResultLanguage sets the Language field.
func WithVerificationResultLanguage(v string) VerificationResultOption {
	return func(r *VerificationResult) {
		r.Language = &v
	}
}

// WithVerificationResultText sets the Text field.
func WithVerificationResultText(v Narrative) VerificationResultOption {
	return func(r *VerificationResult) {
		r.Text = &v
	}
}

// WithVerificationResultContained adds a Contained to the VerificationResult.
func WithVerificationResultContained(v Resource) VerificationResultOption {
	return func(r *VerificationResult) {
		r.Contained = append(r.Contained, v)
	}
}

// WithVerificationResultExtension adds a Extension to the VerificationResult.
func WithVerificationResultExtension(v Extension) VerificationResultOption {
	return func(r *VerificationResult) {
		r.Extension = append(r.Extension, v)
	}
}

// WithVerificationResultModifierExtension adds a ModifierExtension to the VerificationResult.
func WithVerificationResultModifierExtension(v Extension) VerificationResultOption {
	return func(r *VerificationResult) {
		r.ModifierExtension = append(r.ModifierExtension, v)
	}
}

// WithVerificationResultTarget adds a Target to the VerificationResult.
func WithVerificationResultTarget(v Reference) VerificationResultOption {
	return func(r *VerificationResult) {
		r.Target = append(r.Target, v)
	}
}

// WithVerificationResultTargetLocation adds a TargetLocation to the VerificationResult.
func WithVerificationResultTargetLocation(v string) VerificationResultOption {
	return func(r *VerificationResult) {
		r.TargetLocation = append(r.TargetLocation, v)
	}
}

// WithVerificationResultNeed sets the Need field.
func WithVerificationResultNeed(v CodeableConcept) VerificationResultOption {
	return func(r *VerificationResult) {
		r.Need = &v
	}
}

// WithVerificationResultStatus sets the Status field.
func WithVerificationResultStatus(v Status) VerificationResultOption {
	return func(r *VerificationResult) {
		r.Status = &v
	}
}

// WithVerificationResultStatusDate sets the StatusDate field.
func WithVerificationResultStatusDate(v string) VerificationResultOption {
	return func(r *VerificationResult) {
		r.StatusDate = &v
	}
}

// WithVerificationResultValidationType sets the ValidationType field.
func WithVerificationResultValidationType(v CodeableConcept) VerificationResultOption {
	return func(r *VerificationResult) {
		r.ValidationType = &v
	}
}

// WithVerificationResultValidationProcess adds a ValidationProcess to the VerificationResult.
func WithVerificationResultValidationProcess(v CodeableConcept) VerificationResultOption {
	return func(r *VerificationResult) {
		r.ValidationProcess = append(r.ValidationProcess, v)
	}
}

// WithVerificationResultFrequency sets the Frequency field.
func WithVerificationResultFrequency(v Timing) VerificationResultOption {
	return func(r *VerificationResult) {
		r.Frequency = &v
	}
}

// WithVerificationResultLastPerformed sets the LastPerformed field.
func WithVerificationResultLastPerformed(v string) VerificationResultOption {
	return func(r *VerificationResult) {
		r.LastPerformed = &v
	}
}

// WithVerificationResultNextScheduled sets the NextScheduled field.
func WithVerificationResultNextScheduled(v string) VerificationResultOption {
	return func(r *VerificationResult) {
		r.NextScheduled = &v
	}
}

// WithVerificationResultFailureAction sets the FailureAction field.
func WithVerificationResultFailureAction(v CodeableConcept) VerificationResultOption {
	return func(r *VerificationResult) {
		r.FailureAction = &v
	}
}

// WithVerificationResultPrimarySource adds a PrimarySource to the VerificationResult.
func WithVerificationResultPrimarySource(v VerificationResultPrimarySource) VerificationResultOption {
	return func(r *VerificationResult) {
		r.PrimarySource = append(r.PrimarySource, v)
	}
}

// WithVerificationResultAttestation sets the Attestation field.
func WithVerificationResultAttestation(v VerificationResultAttestation) VerificationResultOption {
	return func(r *VerificationResult) {
		r.Attestation = &v
	}
}

// WithVerificationResultValidator adds a Validator to the VerificationResult.
func WithVerificationResultValidator(v VerificationResultValidator) VerificationResultOption {
	return func(r *VerificationResult) {
		r.Validator = append(r.Validator, v)
	}
}
