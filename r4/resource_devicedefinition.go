// Code generated by gofhir. DO NOT EDIT.
// Source: FHIR StructureDefinitions (consolidated resource)
// Package: r4

package r4

import (
	"bytes"
	"encoding/json"
	"encoding/xml"
	"fmt"
)

// =============================================================================
// DeviceDefinition Resource
// =============================================================================

// DeviceDefinition represents FHIR DeviceDefinition.
type DeviceDefinition struct {
	// FHIR resource type
	ResourceType string `json:"resourceType"`
	// Logical id of this artifact
	Id *string `json:"id,omitempty"`
	// Metadata about the resource
	Meta *Meta `json:"meta,omitempty"`
	// A set of rules under which this content was created
	ImplicitRules *string `json:"implicitRules,omitempty"`
	// Extension for ImplicitRules
	ImplicitRulesExt *Element `json:"_implicitRules,omitempty"`
	// Language of the resource content
	Language *string `json:"language,omitempty"`
	// Extension for Language
	LanguageExt *Element `json:"_language,omitempty"`
	// Text summary of the resource, for human interpretation
	Text *Narrative `json:"text,omitempty"`
	// Contained, inline Resources
	Contained []Resource `json:"contained,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Instance identifier
	Identifier []Identifier `json:"identifier,omitempty"`
	// Unique Device Identifier (UDI) Barcode string
	UdiDeviceIdentifier []DeviceDefinitionUdiDeviceIdentifier `json:"udiDeviceIdentifier,omitempty"`
	// Name of device manufacturer
	ManufacturerString *string `json:"manufacturerString,omitempty"`
	// Extension for ManufacturerString
	ManufacturerStringExt *Element `json:"_manufacturerString,omitempty"`
	// Name of device manufacturer
	ManufacturerReference *Reference `json:"manufacturerReference,omitempty"`
	// A name given to the device to identify it
	DeviceName []DeviceDefinitionDeviceName `json:"deviceName,omitempty"`
	// The model number for the device
	ModelNumber *string `json:"modelNumber,omitempty"`
	// Extension for ModelNumber
	ModelNumberExt *Element `json:"_modelNumber,omitempty"`
	// What kind of device or device system this is
	Type *CodeableConcept `json:"type,omitempty"`
	// The capabilities supported on a  device, the standards to which the device conforms for a particular purpose, and used for the communication
	Specialization []DeviceDefinitionSpecialization `json:"specialization,omitempty"`
	// Available versions
	Version []string `json:"version,omitempty"`
	// Extension for Version
	VersionExt []Element `json:"_version,omitempty"`
	// Safety characteristics of the device
	Safety []CodeableConcept `json:"safety,omitempty"`
	// Shelf Life and storage information
	ShelfLifeStorage []ProductShelfLife `json:"shelfLifeStorage,omitempty"`
	// Dimensions, color etc.
	PhysicalCharacteristics *ProdCharacteristic `json:"physicalCharacteristics,omitempty"`
	// Language code for the human-readable text strings produced by the device (all supported)
	LanguageCode []CodeableConcept `json:"languageCode,omitempty"`
	// Device capabilities
	Capability []DeviceDefinitionCapability `json:"capability,omitempty"`
	// The actual configuration settings of a device as it actually operates, e.g., regulation status, time properties
	Property []DeviceDefinitionProperty `json:"property,omitempty"`
	// Organization responsible for device
	Owner *Reference `json:"owner,omitempty"`
	// Details for human/organization for support
	Contact []ContactPoint `json:"contact,omitempty"`
	// Network address to contact device
	Url *string `json:"url,omitempty"`
	// Extension for Url
	UrlExt *Element `json:"_url,omitempty"`
	// Access to on-line information
	OnlineInformation *string `json:"onlineInformation,omitempty"`
	// Extension for OnlineInformation
	OnlineInformationExt *Element `json:"_onlineInformation,omitempty"`
	// Device notes and comments
	Note []Annotation `json:"note,omitempty"`
	// The quantity of the device present in the packaging (e.g. the number of devices present in a pack, or the number of devices in the same package of the medicinal product)
	Quantity *Quantity `json:"quantity,omitempty"`
	// The parent device it can be part of
	ParentDevice *Reference `json:"parentDevice,omitempty"`
	// A substance used to create the material(s) of which the device is made
	Material []DeviceDefinitionMaterial `json:"material,omitempty"`
}

// GetResourceType returns the FHIR resource type.
func (r *DeviceDefinition) GetResourceType() string {
	return "DeviceDefinition"
}

// GetId returns the resource's logical ID.
func (r *DeviceDefinition) GetId() *string {
	return r.Id
}

// SetId sets the resource's logical ID.
func (r *DeviceDefinition) SetId(id string) {
	r.Id = &id
}

// GetMeta returns the resource's Meta element.
func (r *DeviceDefinition) GetMeta() *Meta {
	return r.Meta
}

// SetMeta sets the resource's Meta element.
func (r *DeviceDefinition) SetMeta(m *Meta) {
	r.Meta = m
}

// GetText returns the resource's narrative text.
func (r *DeviceDefinition) GetText() *Narrative {
	return r.Text
}

// SetText sets the resource's narrative text.
func (r *DeviceDefinition) SetText(t *Narrative) {
	r.Text = t
}

// GetContained returns the resource's contained resources.
func (r *DeviceDefinition) GetContained() []Resource {
	return r.Contained
}

// GetExtension returns the resource's extensions.
func (r *DeviceDefinition) GetExtension() []Extension {
	return r.Extension
}

// GetModifierExtension returns the resource's modifier extensions.
func (r *DeviceDefinition) GetModifierExtension() []Extension {
	return r.ModifierExtension
}

// MarshalJSON ensures resourceType is always included in JSON output.
// HTML escaping is disabled to preserve FHIR narrative XHTML content.
//
// Note: Use the package-level Marshal function instead of json.Marshal
// to ensure HTML in narrative text.div fields is not escaped.
func (r DeviceDefinition) MarshalJSON() ([]byte, error) {
	r.ResourceType = "DeviceDefinition"
	type Alias DeviceDefinition
	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	enc.SetEscapeHTML(false)
	if err := enc.Encode((Alias)(r)); err != nil {
		return nil, err
	}
	b := buf.Bytes()
	if len(b) > 0 && b[len(b)-1] == '\n' {
		b = b[:len(b)-1]
	}
	return b, nil
}

// UnmarshalJSON handles deserialization of polymorphic contained resources.
func (r *DeviceDefinition) UnmarshalJSON(data []byte) error {
	// Use an alias to avoid infinite recursion
	type Alias DeviceDefinition
	aux := &struct {
		Contained []json.RawMessage `json:"contained,omitempty"`
		*Alias
	}{
		Alias: (*Alias)(r),
	}

	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}

	// Unmarshal each contained resource using the dispatcher
	if len(aux.Contained) > 0 {
		r.Contained = make([]Resource, len(aux.Contained))
		for i, raw := range aux.Contained {
			resource, err := UnmarshalResource(raw)
			if err != nil {
				return fmt.Errorf("failed to unmarshal contained[%d]: %w", i, err)
			}
			r.Contained[i] = resource
		}
	}

	return nil
}

// MarshalXML serializes DeviceDefinition to FHIR-conformant XML.
func (r DeviceDefinition) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "DeviceDefinition"
		start.Name.Space = fhirNamespace
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	if err := xmlEncodePrimitiveString(e, "id", r.Id, nil); err != nil {
		return err
	}
	if r.Meta != nil {
		if err := r.Meta.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "meta"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "implicitRules", r.ImplicitRules, r.ImplicitRulesExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "language", r.Language, r.LanguageExt); err != nil {
		return err
	}
	if r.Text != nil {
		if err := r.Text.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "text"}}); err != nil {
			return err
		}
	}
	for _, c := range r.Contained {
		if c != nil {
			if err := xmlEncodeContainedResource(e, c); err != nil {
				return err
			}
		}
	}
	for _, item := range r.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range r.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Identifier {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "identifier"}}); err != nil {
			return err
		}
	}
	for _, item := range r.UdiDeviceIdentifier {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "udiDeviceIdentifier"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "manufacturerString", r.ManufacturerString, nil); err != nil {
		return err
	}
	if r.ManufacturerReference != nil {
		if err := r.ManufacturerReference.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "manufacturerReference"}}); err != nil {
			return err
		}
	}
	for _, item := range r.DeviceName {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "deviceName"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "modelNumber", r.ModelNumber, r.ModelNumberExt); err != nil {
		return err
	}
	if r.Type != nil {
		if err := r.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Specialization {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "specialization"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveStringArray(e, "version", r.Version, r.VersionExt); err != nil {
		return err
	}
	for _, item := range r.Safety {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "safety"}}); err != nil {
			return err
		}
	}
	for _, item := range r.ShelfLifeStorage {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "shelfLifeStorage"}}); err != nil {
			return err
		}
	}
	if r.PhysicalCharacteristics != nil {
		if err := r.PhysicalCharacteristics.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "physicalCharacteristics"}}); err != nil {
			return err
		}
	}
	for _, item := range r.LanguageCode {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "languageCode"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Capability {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "capability"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Property {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "property"}}); err != nil {
			return err
		}
	}
	if r.Owner != nil {
		if err := r.Owner.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "owner"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Contact {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "contact"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "url", r.Url, r.UrlExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "onlineInformation", r.OnlineInformation, r.OnlineInformationExt); err != nil {
		return err
	}
	for _, item := range r.Note {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "note"}}); err != nil {
			return err
		}
	}
	if r.Quantity != nil {
		if err := r.Quantity.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "quantity"}}); err != nil {
			return err
		}
	}
	if r.ParentDevice != nil {
		if err := r.ParentDevice.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "parentDevice"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Material {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "material"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes DeviceDefinition from FHIR-conformant XML.
func (r *DeviceDefinition) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "id":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Id = v
			case "meta":
				var v Meta
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Meta = &v
			case "implicitRules":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ImplicitRules = v
				r.ImplicitRulesExt = ext
			case "language":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Language = v
				r.LanguageExt = ext
			case "text":
				var v Narrative
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Text = &v
			case "contained":
				res, err := xmlDecodeContainedResource(d, t)
				if err != nil {
					return err
				}
				if res != nil {
					r.Contained = append(r.Contained, res)
				}
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "identifier":
				var v Identifier
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Identifier = append(r.Identifier, v)
			case "udiDeviceIdentifier":
				var v DeviceDefinitionUdiDeviceIdentifier
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.UdiDeviceIdentifier = append(r.UdiDeviceIdentifier, v)
			case "manufacturerString":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ManufacturerString = v
				_ = ext
			case "manufacturerReference":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ManufacturerReference = &v
			case "deviceName":
				var v DeviceDefinitionDeviceName
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.DeviceName = append(r.DeviceName, v)
			case "modelNumber":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ModelNumber = v
				r.ModelNumberExt = ext
			case "type":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Type = &v
			case "specialization":
				var v DeviceDefinitionSpecialization
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Specialization = append(r.Specialization, v)
			case "version":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.Version = append(r.Version, *v)
				}
			case "safety":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Safety = append(r.Safety, v)
			case "shelfLifeStorage":
				var v ProductShelfLife
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ShelfLifeStorage = append(r.ShelfLifeStorage, v)
			case "physicalCharacteristics":
				var v ProdCharacteristic
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.PhysicalCharacteristics = &v
			case "languageCode":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.LanguageCode = append(r.LanguageCode, v)
			case "capability":
				var v DeviceDefinitionCapability
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Capability = append(r.Capability, v)
			case "property":
				var v DeviceDefinitionProperty
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Property = append(r.Property, v)
			case "owner":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Owner = &v
			case "contact":
				var v ContactPoint
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Contact = append(r.Contact, v)
			case "url":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Url = v
				r.UrlExt = ext
			case "onlineInformation":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.OnlineInformation = v
				r.OnlineInformationExt = ext
			case "note":
				var v Annotation
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Note = append(r.Note, v)
			case "quantity":
				var v Quantity
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Quantity = &v
			case "parentDevice":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ParentDevice = &v
			case "material":
				var v DeviceDefinitionMaterial
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Material = append(r.Material, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// DeviceDefinitionCapability represents the DeviceDefinition.capability backbone element.
// Device capabilities
type DeviceDefinitionCapability struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Type of capability
	Type CodeableConcept `json:"type,omitempty"`
	// Description of capability
	Description []CodeableConcept `json:"description,omitempty"`
}

// MarshalXML serializes DeviceDefinitionCapability to FHIR-conformant XML.
func (b DeviceDefinitionCapability) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "DeviceDefinition.capability"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
		return err
	}
	for _, item := range b.Description {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "description"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes DeviceDefinitionCapability from FHIR-conformant XML.
func (r *DeviceDefinitionCapability) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "type":
				if err := r.Type.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "description":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Description = append(r.Description, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// DeviceDefinitionDeviceName represents the DeviceDefinition.deviceName backbone element.
// A name given to the device to identify it
type DeviceDefinitionDeviceName struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The name of the device
	Name *string `json:"name,omitempty"`
	// udi-label-name | user-friendly-name | patient-reported-name | manufacturer-name | model-name | other
	Type *DeviceNameType `json:"type,omitempty"`
}

// MarshalXML serializes DeviceDefinitionDeviceName to FHIR-conformant XML.
func (b DeviceDefinitionDeviceName) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "DeviceDefinition.deviceName"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "name", b.Name, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveCode(e, "type", b.Type, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes DeviceDefinitionDeviceName from FHIR-conformant XML.
func (r *DeviceDefinitionDeviceName) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "name":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Name = v
			case "type":
				v, _, err := xmlDecodePrimitiveCode[DeviceNameType](d, t)
				if err != nil {
					return err
				}
				r.Type = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// DeviceDefinitionMaterial represents the DeviceDefinition.material backbone element.
// A substance used to create the material(s) of which the device is made
type DeviceDefinitionMaterial struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The substance
	Substance CodeableConcept `json:"substance,omitempty"`
	// Indicates an alternative material of the device
	Alternate *bool `json:"alternate,omitempty"`
	// Whether the substance is a known or suspected allergen
	AllergenicIndicator *bool `json:"allergenicIndicator,omitempty"`
}

// MarshalXML serializes DeviceDefinitionMaterial to FHIR-conformant XML.
func (b DeviceDefinitionMaterial) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "DeviceDefinition.material"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := b.Substance.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "substance"}}); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveBool(e, "alternate", b.Alternate, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveBool(e, "allergenicIndicator", b.AllergenicIndicator, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes DeviceDefinitionMaterial from FHIR-conformant XML.
func (r *DeviceDefinitionMaterial) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "substance":
				if err := r.Substance.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "alternate":
				v, _, err := xmlDecodePrimitiveBool(d, t)
				if err != nil {
					return err
				}
				r.Alternate = v
			case "allergenicIndicator":
				v, _, err := xmlDecodePrimitiveBool(d, t)
				if err != nil {
					return err
				}
				r.AllergenicIndicator = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// DeviceDefinitionProperty represents the DeviceDefinition.property backbone element.
// The actual configuration settings of a device as it actually operates, e.g., regulation status, time properties
type DeviceDefinitionProperty struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Code that specifies the property DeviceDefinitionPropetyCode (Extensible)
	Type CodeableConcept `json:"type,omitempty"`
	// Property value as a quantity
	ValueQuantity []Quantity `json:"valueQuantity,omitempty"`
	// Property value as a code, e.g., NTP4 (synced to NTP)
	ValueCode []CodeableConcept `json:"valueCode,omitempty"`
}

// MarshalXML serializes DeviceDefinitionProperty to FHIR-conformant XML.
func (b DeviceDefinitionProperty) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "DeviceDefinition.property"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
		return err
	}
	for _, item := range b.ValueQuantity {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueQuantity"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ValueCode {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueCode"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes DeviceDefinitionProperty from FHIR-conformant XML.
func (r *DeviceDefinitionProperty) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "type":
				if err := r.Type.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "valueQuantity":
				var v Quantity
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueQuantity = append(r.ValueQuantity, v)
			case "valueCode":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueCode = append(r.ValueCode, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// DeviceDefinitionSpecialization represents the DeviceDefinition.specialization backbone element.
// The capabilities supported on a  device, the standards to which the device conforms for a particular purpose, and used for the communication
type DeviceDefinitionSpecialization struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The standard that is used to operate and communicate
	SystemType *string `json:"systemType,omitempty"`
	// The version of the standard that is used to operate and communicate
	Version *string `json:"version,omitempty"`
}

// MarshalXML serializes DeviceDefinitionSpecialization to FHIR-conformant XML.
func (b DeviceDefinitionSpecialization) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "DeviceDefinition.specialization"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "systemType", b.SystemType, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "version", b.Version, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes DeviceDefinitionSpecialization from FHIR-conformant XML.
func (r *DeviceDefinitionSpecialization) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "systemType":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.SystemType = v
			case "version":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Version = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// DeviceDefinitionUdiDeviceIdentifier represents the DeviceDefinition.udiDeviceIdentifier backbone element.
// Unique Device Identifier (UDI) Barcode string
type DeviceDefinitionUdiDeviceIdentifier struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The identifier that is to be associated with every Device that references this DeviceDefintiion for the issuer and jurisdication porvided in the DeviceDefinition.udiDeviceIdentifier
	DeviceIdentifier *string `json:"deviceIdentifier,omitempty"`
	// The organization that assigns the identifier algorithm
	Issuer *string `json:"issuer,omitempty"`
	// The jurisdiction to which the deviceIdentifier applies
	Jurisdiction *string `json:"jurisdiction,omitempty"`
}

// MarshalXML serializes DeviceDefinitionUdiDeviceIdentifier to FHIR-conformant XML.
func (b DeviceDefinitionUdiDeviceIdentifier) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "DeviceDefinition.udiDeviceIdentifier"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "deviceIdentifier", b.DeviceIdentifier, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "issuer", b.Issuer, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "jurisdiction", b.Jurisdiction, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes DeviceDefinitionUdiDeviceIdentifier from FHIR-conformant XML.
func (r *DeviceDefinitionUdiDeviceIdentifier) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "deviceIdentifier":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.DeviceIdentifier = v
			case "issuer":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Issuer = v
			case "jurisdiction":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Jurisdiction = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// =============================================================================
// DeviceDefinition - Fluent Builder
// =============================================================================

// DeviceDefinitionBuilder provides a fluent API for constructing DeviceDefinition resources.
type DeviceDefinitionBuilder struct {
	deviceDefinition *DeviceDefinition
}

// NewDeviceDefinitionBuilder creates a new DeviceDefinitionBuilder.
func NewDeviceDefinitionBuilder() *DeviceDefinitionBuilder {
	return &DeviceDefinitionBuilder{
		deviceDefinition: &DeviceDefinition{},
	}
}

// Build returns the constructed DeviceDefinition resource.
func (b *DeviceDefinitionBuilder) Build() *DeviceDefinition {
	return b.deviceDefinition
}

// SetId sets the Id field.
func (b *DeviceDefinitionBuilder) SetId(v string) *DeviceDefinitionBuilder {
	b.deviceDefinition.Id = &v
	return b
}

// SetMeta sets the Meta field.
func (b *DeviceDefinitionBuilder) SetMeta(v Meta) *DeviceDefinitionBuilder {
	b.deviceDefinition.Meta = &v
	return b
}

// SetImplicitRules sets the ImplicitRules field.
func (b *DeviceDefinitionBuilder) SetImplicitRules(v string) *DeviceDefinitionBuilder {
	b.deviceDefinition.ImplicitRules = &v
	return b
}

// SetLanguage sets the Language field.
func (b *DeviceDefinitionBuilder) SetLanguage(v string) *DeviceDefinitionBuilder {
	b.deviceDefinition.Language = &v
	return b
}

// SetText sets the Text field.
func (b *DeviceDefinitionBuilder) SetText(v Narrative) *DeviceDefinitionBuilder {
	b.deviceDefinition.Text = &v
	return b
}

// AddContained adds a Contained element.
func (b *DeviceDefinitionBuilder) AddContained(v Resource) *DeviceDefinitionBuilder {
	b.deviceDefinition.Contained = append(b.deviceDefinition.Contained, v)
	return b
}

// AddExtension adds a Extension element.
func (b *DeviceDefinitionBuilder) AddExtension(v Extension) *DeviceDefinitionBuilder {
	b.deviceDefinition.Extension = append(b.deviceDefinition.Extension, v)
	return b
}

// AddModifierExtension adds a ModifierExtension element.
func (b *DeviceDefinitionBuilder) AddModifierExtension(v Extension) *DeviceDefinitionBuilder {
	b.deviceDefinition.ModifierExtension = append(b.deviceDefinition.ModifierExtension, v)
	return b
}

// AddIdentifier adds a Identifier element.
func (b *DeviceDefinitionBuilder) AddIdentifier(v Identifier) *DeviceDefinitionBuilder {
	b.deviceDefinition.Identifier = append(b.deviceDefinition.Identifier, v)
	return b
}

// AddUdiDeviceIdentifier adds a UdiDeviceIdentifier element.
func (b *DeviceDefinitionBuilder) AddUdiDeviceIdentifier(v DeviceDefinitionUdiDeviceIdentifier) *DeviceDefinitionBuilder {
	b.deviceDefinition.UdiDeviceIdentifier = append(b.deviceDefinition.UdiDeviceIdentifier, v)
	return b
}

// SetManufacturerString sets the ManufacturerString field.
func (b *DeviceDefinitionBuilder) SetManufacturerString(v string) *DeviceDefinitionBuilder {
	b.deviceDefinition.ManufacturerString = &v
	return b
}

// SetManufacturerStringExt sets the ManufacturerStringExt field.
func (b *DeviceDefinitionBuilder) SetManufacturerStringExt(v Element) *DeviceDefinitionBuilder {
	b.deviceDefinition.ManufacturerStringExt = &v
	return b
}

// SetManufacturerReference sets the ManufacturerReference field.
func (b *DeviceDefinitionBuilder) SetManufacturerReference(v Reference) *DeviceDefinitionBuilder {
	b.deviceDefinition.ManufacturerReference = &v
	return b
}

// AddDeviceName adds a DeviceName element.
func (b *DeviceDefinitionBuilder) AddDeviceName(v DeviceDefinitionDeviceName) *DeviceDefinitionBuilder {
	b.deviceDefinition.DeviceName = append(b.deviceDefinition.DeviceName, v)
	return b
}

// SetModelNumber sets the ModelNumber field.
func (b *DeviceDefinitionBuilder) SetModelNumber(v string) *DeviceDefinitionBuilder {
	b.deviceDefinition.ModelNumber = &v
	return b
}

// SetType sets the Type field.
func (b *DeviceDefinitionBuilder) SetType(v CodeableConcept) *DeviceDefinitionBuilder {
	b.deviceDefinition.Type = &v
	return b
}

// AddSpecialization adds a Specialization element.
func (b *DeviceDefinitionBuilder) AddSpecialization(v DeviceDefinitionSpecialization) *DeviceDefinitionBuilder {
	b.deviceDefinition.Specialization = append(b.deviceDefinition.Specialization, v)
	return b
}

// AddVersion adds a Version element.
func (b *DeviceDefinitionBuilder) AddVersion(v string) *DeviceDefinitionBuilder {
	b.deviceDefinition.Version = append(b.deviceDefinition.Version, v)
	return b
}

// AddSafety adds a Safety element.
func (b *DeviceDefinitionBuilder) AddSafety(v CodeableConcept) *DeviceDefinitionBuilder {
	b.deviceDefinition.Safety = append(b.deviceDefinition.Safety, v)
	return b
}

// AddShelfLifeStorage adds a ShelfLifeStorage element.
func (b *DeviceDefinitionBuilder) AddShelfLifeStorage(v ProductShelfLife) *DeviceDefinitionBuilder {
	b.deviceDefinition.ShelfLifeStorage = append(b.deviceDefinition.ShelfLifeStorage, v)
	return b
}

// SetPhysicalCharacteristics sets the PhysicalCharacteristics field.
func (b *DeviceDefinitionBuilder) SetPhysicalCharacteristics(v ProdCharacteristic) *DeviceDefinitionBuilder {
	b.deviceDefinition.PhysicalCharacteristics = &v
	return b
}

// AddLanguageCode adds a LanguageCode element.
func (b *DeviceDefinitionBuilder) AddLanguageCode(v CodeableConcept) *DeviceDefinitionBuilder {
	b.deviceDefinition.LanguageCode = append(b.deviceDefinition.LanguageCode, v)
	return b
}

// AddCapability adds a Capability element.
func (b *DeviceDefinitionBuilder) AddCapability(v DeviceDefinitionCapability) *DeviceDefinitionBuilder {
	b.deviceDefinition.Capability = append(b.deviceDefinition.Capability, v)
	return b
}

// AddProperty adds a Property element.
func (b *DeviceDefinitionBuilder) AddProperty(v DeviceDefinitionProperty) *DeviceDefinitionBuilder {
	b.deviceDefinition.Property = append(b.deviceDefinition.Property, v)
	return b
}

// SetOwner sets the Owner field.
func (b *DeviceDefinitionBuilder) SetOwner(v Reference) *DeviceDefinitionBuilder {
	b.deviceDefinition.Owner = &v
	return b
}

// AddContact adds a Contact element.
func (b *DeviceDefinitionBuilder) AddContact(v ContactPoint) *DeviceDefinitionBuilder {
	b.deviceDefinition.Contact = append(b.deviceDefinition.Contact, v)
	return b
}

// SetUrl sets the Url field.
func (b *DeviceDefinitionBuilder) SetUrl(v string) *DeviceDefinitionBuilder {
	b.deviceDefinition.Url = &v
	return b
}

// SetOnlineInformation sets the OnlineInformation field.
func (b *DeviceDefinitionBuilder) SetOnlineInformation(v string) *DeviceDefinitionBuilder {
	b.deviceDefinition.OnlineInformation = &v
	return b
}

// AddNote adds a Note element.
func (b *DeviceDefinitionBuilder) AddNote(v Annotation) *DeviceDefinitionBuilder {
	b.deviceDefinition.Note = append(b.deviceDefinition.Note, v)
	return b
}

// SetQuantity sets the Quantity field.
func (b *DeviceDefinitionBuilder) SetQuantity(v Quantity) *DeviceDefinitionBuilder {
	b.deviceDefinition.Quantity = &v
	return b
}

// SetParentDevice sets the ParentDevice field.
func (b *DeviceDefinitionBuilder) SetParentDevice(v Reference) *DeviceDefinitionBuilder {
	b.deviceDefinition.ParentDevice = &v
	return b
}

// AddMaterial adds a Material element.
func (b *DeviceDefinitionBuilder) AddMaterial(v DeviceDefinitionMaterial) *DeviceDefinitionBuilder {
	b.deviceDefinition.Material = append(b.deviceDefinition.Material, v)
	return b
}

// =============================================================================
// DeviceDefinition - Functional Options
// =============================================================================

// DeviceDefinitionOption is a functional option for configuring a DeviceDefinition.
type DeviceDefinitionOption func(*DeviceDefinition)

// NewDeviceDefinition creates a new DeviceDefinition with the given options.
func NewDeviceDefinition(opts ...DeviceDefinitionOption) *DeviceDefinition {
	r := &DeviceDefinition{}
	for _, opt := range opts {
		opt(r)
	}
	return r
}

// WithDeviceDefinitionId sets the Id field.
func WithDeviceDefinitionId(v string) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.Id = &v
	}
}

// WithDeviceDefinitionMeta sets the Meta field.
func WithDeviceDefinitionMeta(v Meta) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.Meta = &v
	}
}

// WithDeviceDefinitionImplicitRules sets the ImplicitRules field.
func WithDeviceDefinitionImplicitRules(v string) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.ImplicitRules = &v
	}
}

// WithDeviceDefinitionLanguage sets the Language field.
func WithDeviceDefinitionLanguage(v string) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.Language = &v
	}
}

// WithDeviceDefinitionText sets the Text field.
func WithDeviceDefinitionText(v Narrative) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.Text = &v
	}
}

// WithDeviceDefinitionContained adds a Contained to the DeviceDefinition.
func WithDeviceDefinitionContained(v Resource) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.Contained = append(r.Contained, v)
	}
}

// WithDeviceDefinitionExtension adds a Extension to the DeviceDefinition.
func WithDeviceDefinitionExtension(v Extension) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.Extension = append(r.Extension, v)
	}
}

// WithDeviceDefinitionModifierExtension adds a ModifierExtension to the DeviceDefinition.
func WithDeviceDefinitionModifierExtension(v Extension) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.ModifierExtension = append(r.ModifierExtension, v)
	}
}

// WithDeviceDefinitionIdentifier adds a Identifier to the DeviceDefinition.
func WithDeviceDefinitionIdentifier(v Identifier) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.Identifier = append(r.Identifier, v)
	}
}

// WithDeviceDefinitionUdiDeviceIdentifier adds a UdiDeviceIdentifier to the DeviceDefinition.
func WithDeviceDefinitionUdiDeviceIdentifier(v DeviceDefinitionUdiDeviceIdentifier) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.UdiDeviceIdentifier = append(r.UdiDeviceIdentifier, v)
	}
}

// WithDeviceDefinitionManufacturerString sets the ManufacturerString field.
func WithDeviceDefinitionManufacturerString(v string) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.ManufacturerString = &v
	}
}

// WithDeviceDefinitionManufacturerStringExt sets the ManufacturerStringExt field.
func WithDeviceDefinitionManufacturerStringExt(v Element) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.ManufacturerStringExt = &v
	}
}

// WithDeviceDefinitionManufacturerReference sets the ManufacturerReference field.
func WithDeviceDefinitionManufacturerReference(v Reference) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.ManufacturerReference = &v
	}
}

// WithDeviceDefinitionDeviceName adds a DeviceName to the DeviceDefinition.
func WithDeviceDefinitionDeviceName(v DeviceDefinitionDeviceName) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.DeviceName = append(r.DeviceName, v)
	}
}

// WithDeviceDefinitionModelNumber sets the ModelNumber field.
func WithDeviceDefinitionModelNumber(v string) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.ModelNumber = &v
	}
}

// WithDeviceDefinitionType sets the Type field.
func WithDeviceDefinitionType(v CodeableConcept) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.Type = &v
	}
}

// WithDeviceDefinitionSpecialization adds a Specialization to the DeviceDefinition.
func WithDeviceDefinitionSpecialization(v DeviceDefinitionSpecialization) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.Specialization = append(r.Specialization, v)
	}
}

// WithDeviceDefinitionVersion adds a Version to the DeviceDefinition.
func WithDeviceDefinitionVersion(v string) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.Version = append(r.Version, v)
	}
}

// WithDeviceDefinitionSafety adds a Safety to the DeviceDefinition.
func WithDeviceDefinitionSafety(v CodeableConcept) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.Safety = append(r.Safety, v)
	}
}

// WithDeviceDefinitionShelfLifeStorage adds a ShelfLifeStorage to the DeviceDefinition.
func WithDeviceDefinitionShelfLifeStorage(v ProductShelfLife) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.ShelfLifeStorage = append(r.ShelfLifeStorage, v)
	}
}

// WithDeviceDefinitionPhysicalCharacteristics sets the PhysicalCharacteristics field.
func WithDeviceDefinitionPhysicalCharacteristics(v ProdCharacteristic) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.PhysicalCharacteristics = &v
	}
}

// WithDeviceDefinitionLanguageCode adds a LanguageCode to the DeviceDefinition.
func WithDeviceDefinitionLanguageCode(v CodeableConcept) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.LanguageCode = append(r.LanguageCode, v)
	}
}

// WithDeviceDefinitionCapability adds a Capability to the DeviceDefinition.
func WithDeviceDefinitionCapability(v DeviceDefinitionCapability) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.Capability = append(r.Capability, v)
	}
}

// WithDeviceDefinitionProperty adds a Property to the DeviceDefinition.
func WithDeviceDefinitionProperty(v DeviceDefinitionProperty) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.Property = append(r.Property, v)
	}
}

// WithDeviceDefinitionOwner sets the Owner field.
func WithDeviceDefinitionOwner(v Reference) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.Owner = &v
	}
}

// WithDeviceDefinitionContact adds a Contact to the DeviceDefinition.
func WithDeviceDefinitionContact(v ContactPoint) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.Contact = append(r.Contact, v)
	}
}

// WithDeviceDefinitionUrl sets the Url field.
func WithDeviceDefinitionUrl(v string) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.Url = &v
	}
}

// WithDeviceDefinitionOnlineInformation sets the OnlineInformation field.
func WithDeviceDefinitionOnlineInformation(v string) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.OnlineInformation = &v
	}
}

// WithDeviceDefinitionNote adds a Note to the DeviceDefinition.
func WithDeviceDefinitionNote(v Annotation) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.Note = append(r.Note, v)
	}
}

// WithDeviceDefinitionQuantity sets the Quantity field.
func WithDeviceDefinitionQuantity(v Quantity) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.Quantity = &v
	}
}

// WithDeviceDefinitionParentDevice sets the ParentDevice field.
func WithDeviceDefinitionParentDevice(v Reference) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.ParentDevice = &v
	}
}

// WithDeviceDefinitionMaterial adds a Material to the DeviceDefinition.
func WithDeviceDefinitionMaterial(v DeviceDefinitionMaterial) DeviceDefinitionOption {
	return func(r *DeviceDefinition) {
		r.Material = append(r.Material, v)
	}
}
