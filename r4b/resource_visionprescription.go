// Code generated by gofhir. DO NOT EDIT.
// Source: FHIR StructureDefinitions (consolidated resource)
// Package: r4b

package r4b

import (
	"bytes"
	"encoding/json"
	"encoding/xml"
	"fmt"
)

// =============================================================================
// VisionPrescription Resource
// =============================================================================

// VisionPrescription represents FHIR VisionPrescription.
type VisionPrescription struct {
	// FHIR resource type
	ResourceType string `json:"resourceType"`
	// Logical id of this artifact
	Id *string `json:"id,omitempty"`
	// Metadata about the resource
	Meta *Meta `json:"meta,omitempty"`
	// A set of rules under which this content was created
	ImplicitRules *string `json:"implicitRules,omitempty"`
	// Extension for ImplicitRules
	ImplicitRulesExt *Element `json:"_implicitRules,omitempty"`
	// Language of the resource content
	Language *string `json:"language,omitempty"`
	// Extension for Language
	LanguageExt *Element `json:"_language,omitempty"`
	// Text summary of the resource, for human interpretation
	Text *Narrative `json:"text,omitempty"`
	// Contained, inline Resources
	Contained []Resource `json:"contained,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Business Identifier for vision prescription
	Identifier []Identifier `json:"identifier,omitempty"`
	// active | cancelled | draft | entered-in-error
	Status *FinancialResourceStatusCodes `json:"status,omitempty"`
	// Extension for Status
	StatusExt *Element `json:"_status,omitempty"`
	// Response creation date
	Created *string `json:"created,omitempty"`
	// Extension for Created
	CreatedExt *Element `json:"_created,omitempty"`
	// Who prescription is for
	Patient Reference `json:"patient"`
	// Created during encounter / admission / stay
	Encounter *Reference `json:"encounter,omitempty"`
	// When prescription was authorized
	DateWritten *string `json:"dateWritten,omitempty"`
	// Extension for DateWritten
	DateWrittenExt *Element `json:"_dateWritten,omitempty"`
	// Who authorized the vision prescription
	Prescriber Reference `json:"prescriber"`
	// Vision lens authorization
	LensSpecification []VisionPrescriptionLensSpecification `json:"lensSpecification,omitempty"`
}

// GetResourceType returns the FHIR resource type.
func (r *VisionPrescription) GetResourceType() string {
	return "VisionPrescription"
}

// GetId returns the resource's logical ID.
func (r *VisionPrescription) GetId() *string {
	return r.Id
}

// SetId sets the resource's logical ID.
func (r *VisionPrescription) SetId(id string) {
	r.Id = &id
}

// GetMeta returns the resource's Meta element.
func (r *VisionPrescription) GetMeta() *Meta {
	return r.Meta
}

// SetMeta sets the resource's Meta element.
func (r *VisionPrescription) SetMeta(m *Meta) {
	r.Meta = m
}

// GetText returns the resource's narrative text.
func (r *VisionPrescription) GetText() *Narrative {
	return r.Text
}

// SetText sets the resource's narrative text.
func (r *VisionPrescription) SetText(t *Narrative) {
	r.Text = t
}

// GetContained returns the resource's contained resources.
func (r *VisionPrescription) GetContained() []Resource {
	return r.Contained
}

// GetExtension returns the resource's extensions.
func (r *VisionPrescription) GetExtension() []Extension {
	return r.Extension
}

// GetModifierExtension returns the resource's modifier extensions.
func (r *VisionPrescription) GetModifierExtension() []Extension {
	return r.ModifierExtension
}

// MarshalJSON ensures resourceType is always included in JSON output.
// HTML escaping is disabled to preserve FHIR narrative XHTML content.
//
// Note: Use the package-level Marshal function instead of json.Marshal
// to ensure HTML in narrative text.div fields is not escaped.
func (r VisionPrescription) MarshalJSON() ([]byte, error) {
	r.ResourceType = "VisionPrescription"
	type Alias VisionPrescription
	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	enc.SetEscapeHTML(false)
	if err := enc.Encode((Alias)(r)); err != nil {
		return nil, err
	}
	b := buf.Bytes()
	if len(b) > 0 && b[len(b)-1] == '\n' {
		b = b[:len(b)-1]
	}
	return b, nil
}

// UnmarshalJSON handles deserialization of polymorphic contained resources.
func (r *VisionPrescription) UnmarshalJSON(data []byte) error {
	// Use an alias to avoid infinite recursion
	type Alias VisionPrescription
	aux := &struct {
		Contained []json.RawMessage `json:"contained,omitempty"`
		*Alias
	}{
		Alias: (*Alias)(r),
	}

	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}

	// Unmarshal each contained resource using the dispatcher
	if len(aux.Contained) > 0 {
		r.Contained = make([]Resource, len(aux.Contained))
		for i, raw := range aux.Contained {
			resource, err := UnmarshalResource(raw)
			if err != nil {
				return fmt.Errorf("failed to unmarshal contained[%d]: %w", i, err)
			}
			r.Contained[i] = resource
		}
	}

	return nil
}

// MarshalXML serializes VisionPrescription to FHIR-conformant XML.
func (r VisionPrescription) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "VisionPrescription"
		start.Name.Space = fhirNamespace
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	if err := xmlEncodePrimitiveString(e, "id", r.Id, nil); err != nil {
		return err
	}
	if r.Meta != nil {
		if err := r.Meta.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "meta"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "implicitRules", r.ImplicitRules, r.ImplicitRulesExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "language", r.Language, r.LanguageExt); err != nil {
		return err
	}
	if r.Text != nil {
		if err := r.Text.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "text"}}); err != nil {
			return err
		}
	}
	for _, c := range r.Contained {
		if c != nil {
			if err := xmlEncodeContainedResource(e, c); err != nil {
				return err
			}
		}
	}
	for _, item := range r.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range r.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Identifier {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "identifier"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveCode(e, "status", r.Status, r.StatusExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "created", r.Created, r.CreatedExt); err != nil {
		return err
	}
	if err := r.Patient.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "patient"}}); err != nil {
		return err
	}
	if r.Encounter != nil {
		if err := r.Encounter.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "encounter"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "dateWritten", r.DateWritten, r.DateWrittenExt); err != nil {
		return err
	}
	if err := r.Prescriber.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "prescriber"}}); err != nil {
		return err
	}
	for _, item := range r.LensSpecification {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "lensSpecification"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes VisionPrescription from FHIR-conformant XML.
func (r *VisionPrescription) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "id":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Id = v
			case "meta":
				var v Meta
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Meta = &v
			case "implicitRules":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ImplicitRules = v
				r.ImplicitRulesExt = ext
			case "language":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Language = v
				r.LanguageExt = ext
			case "text":
				var v Narrative
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Text = &v
			case "contained":
				res, err := xmlDecodeContainedResource(d, t)
				if err != nil {
					return err
				}
				if res != nil {
					r.Contained = append(r.Contained, res)
				}
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "identifier":
				var v Identifier
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Identifier = append(r.Identifier, v)
			case "status":
				v, ext, err := xmlDecodePrimitiveCode[FinancialResourceStatusCodes](d, t)
				if err != nil {
					return err
				}
				r.Status = v
				r.StatusExt = ext
			case "created":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Created = v
				r.CreatedExt = ext
			case "patient":
				if err := r.Patient.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "encounter":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Encounter = &v
			case "dateWritten":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.DateWritten = v
				r.DateWrittenExt = ext
			case "prescriber":
				if err := r.Prescriber.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "lensSpecification":
				var v VisionPrescriptionLensSpecification
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.LensSpecification = append(r.LensSpecification, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// VisionPrescriptionLensSpecification represents the VisionPrescription.lensSpecification backbone element.
// Vision lens authorization
type VisionPrescriptionLensSpecification struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Product to be supplied
	Product CodeableConcept `json:"product,omitempty"`
	// right | left
	Eye *VisionEyes `json:"eye,omitempty"`
	// Power of the lens
	Sphere *Decimal `json:"sphere,omitempty"`
	// Lens power for astigmatism
	Cylinder *Decimal `json:"cylinder,omitempty"`
	// Lens meridian which contain no power for astigmatism
	Axis *int `json:"axis,omitempty"`
	// Eye alignment compensation
	Prism []VisionPrescriptionLensSpecificationPrism `json:"prism,omitempty"`
	// Added power for multifocal levels
	Add *Decimal `json:"add,omitempty"`
	// Contact lens power
	Power *Decimal `json:"power,omitempty"`
	// Contact lens back curvature
	BackCurve *Decimal `json:"backCurve,omitempty"`
	// Contact lens diameter
	Diameter *Decimal `json:"diameter,omitempty"`
	// Lens wear duration
	Duration *Quantity `json:"duration,omitempty"`
	// Color required
	Color *string `json:"color,omitempty"`
	// Brand required
	Brand *string `json:"brand,omitempty"`
	// Notes for coatings
	Note []Annotation `json:"note,omitempty"`
}

// MarshalXML serializes VisionPrescriptionLensSpecification to FHIR-conformant XML.
func (b VisionPrescriptionLensSpecification) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "VisionPrescription.lensSpecification"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := b.Product.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "product"}}); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveCode(e, "eye", b.Eye, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveDecimal(e, "sphere", b.Sphere, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveDecimal(e, "cylinder", b.Cylinder, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveInt(e, "axis", b.Axis, nil); err != nil {
		return err
	}
	for _, item := range b.Prism {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "prism"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveDecimal(e, "add", b.Add, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveDecimal(e, "power", b.Power, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveDecimal(e, "backCurve", b.BackCurve, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveDecimal(e, "diameter", b.Diameter, nil); err != nil {
		return err
	}
	if b.Duration != nil {
		if err := b.Duration.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "duration"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "color", b.Color, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "brand", b.Brand, nil); err != nil {
		return err
	}
	for _, item := range b.Note {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "note"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes VisionPrescriptionLensSpecification from FHIR-conformant XML.
func (r *VisionPrescriptionLensSpecification) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "product":
				if err := r.Product.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "eye":
				v, _, err := xmlDecodePrimitiveCode[VisionEyes](d, t)
				if err != nil {
					return err
				}
				r.Eye = v
			case "sphere":
				v, _, err := xmlDecodePrimitiveDecimal(d, t)
				if err != nil {
					return err
				}
				r.Sphere = v
			case "cylinder":
				v, _, err := xmlDecodePrimitiveDecimal(d, t)
				if err != nil {
					return err
				}
				r.Cylinder = v
			case "axis":
				v, _, err := xmlDecodePrimitiveInt(d, t)
				if err != nil {
					return err
				}
				r.Axis = v
			case "prism":
				var v VisionPrescriptionLensSpecificationPrism
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Prism = append(r.Prism, v)
			case "add":
				v, _, err := xmlDecodePrimitiveDecimal(d, t)
				if err != nil {
					return err
				}
				r.Add = v
			case "power":
				v, _, err := xmlDecodePrimitiveDecimal(d, t)
				if err != nil {
					return err
				}
				r.Power = v
			case "backCurve":
				v, _, err := xmlDecodePrimitiveDecimal(d, t)
				if err != nil {
					return err
				}
				r.BackCurve = v
			case "diameter":
				v, _, err := xmlDecodePrimitiveDecimal(d, t)
				if err != nil {
					return err
				}
				r.Diameter = v
			case "duration":
				var v Quantity
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Duration = &v
			case "color":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Color = v
			case "brand":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Brand = v
			case "note":
				var v Annotation
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Note = append(r.Note, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// VisionPrescriptionLensSpecificationPrism represents the VisionPrescription.lensSpecification.prism backbone element.
// Eye alignment compensation
type VisionPrescriptionLensSpecificationPrism struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Amount of adjustment
	Amount *Decimal `json:"amount,omitempty"`
	// up | down | in | out
	Base *VisionBase `json:"base,omitempty"`
}

// MarshalXML serializes VisionPrescriptionLensSpecificationPrism to FHIR-conformant XML.
func (b VisionPrescriptionLensSpecificationPrism) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "VisionPrescription.lensSpecification.prism"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveDecimal(e, "amount", b.Amount, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveCode(e, "base", b.Base, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes VisionPrescriptionLensSpecificationPrism from FHIR-conformant XML.
func (r *VisionPrescriptionLensSpecificationPrism) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "amount":
				v, _, err := xmlDecodePrimitiveDecimal(d, t)
				if err != nil {
					return err
				}
				r.Amount = v
			case "base":
				v, _, err := xmlDecodePrimitiveCode[VisionBase](d, t)
				if err != nil {
					return err
				}
				r.Base = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// =============================================================================
// VisionPrescription - Fluent Builder
// =============================================================================

// VisionPrescriptionBuilder provides a fluent API for constructing VisionPrescription resources.
type VisionPrescriptionBuilder struct {
	visionPrescription *VisionPrescription
}

// NewVisionPrescriptionBuilder creates a new VisionPrescriptionBuilder.
func NewVisionPrescriptionBuilder() *VisionPrescriptionBuilder {
	return &VisionPrescriptionBuilder{
		visionPrescription: &VisionPrescription{},
	}
}

// Build returns the constructed VisionPrescription resource.
func (b *VisionPrescriptionBuilder) Build() *VisionPrescription {
	return b.visionPrescription
}

// SetId sets the Id field.
func (b *VisionPrescriptionBuilder) SetId(v string) *VisionPrescriptionBuilder {
	b.visionPrescription.Id = &v
	return b
}

// SetMeta sets the Meta field.
func (b *VisionPrescriptionBuilder) SetMeta(v Meta) *VisionPrescriptionBuilder {
	b.visionPrescription.Meta = &v
	return b
}

// SetImplicitRules sets the ImplicitRules field.
func (b *VisionPrescriptionBuilder) SetImplicitRules(v string) *VisionPrescriptionBuilder {
	b.visionPrescription.ImplicitRules = &v
	return b
}

// SetLanguage sets the Language field.
func (b *VisionPrescriptionBuilder) SetLanguage(v string) *VisionPrescriptionBuilder {
	b.visionPrescription.Language = &v
	return b
}

// SetText sets the Text field.
func (b *VisionPrescriptionBuilder) SetText(v Narrative) *VisionPrescriptionBuilder {
	b.visionPrescription.Text = &v
	return b
}

// AddContained adds a Contained element.
func (b *VisionPrescriptionBuilder) AddContained(v Resource) *VisionPrescriptionBuilder {
	b.visionPrescription.Contained = append(b.visionPrescription.Contained, v)
	return b
}

// AddExtension adds a Extension element.
func (b *VisionPrescriptionBuilder) AddExtension(v Extension) *VisionPrescriptionBuilder {
	b.visionPrescription.Extension = append(b.visionPrescription.Extension, v)
	return b
}

// AddModifierExtension adds a ModifierExtension element.
func (b *VisionPrescriptionBuilder) AddModifierExtension(v Extension) *VisionPrescriptionBuilder {
	b.visionPrescription.ModifierExtension = append(b.visionPrescription.ModifierExtension, v)
	return b
}

// AddIdentifier adds a Identifier element.
func (b *VisionPrescriptionBuilder) AddIdentifier(v Identifier) *VisionPrescriptionBuilder {
	b.visionPrescription.Identifier = append(b.visionPrescription.Identifier, v)
	return b
}

// SetStatus sets the Status field.
func (b *VisionPrescriptionBuilder) SetStatus(v FinancialResourceStatusCodes) *VisionPrescriptionBuilder {
	b.visionPrescription.Status = &v
	return b
}

// SetCreated sets the Created field.
func (b *VisionPrescriptionBuilder) SetCreated(v string) *VisionPrescriptionBuilder {
	b.visionPrescription.Created = &v
	return b
}

// SetPatient sets the Patient field.
func (b *VisionPrescriptionBuilder) SetPatient(v Reference) *VisionPrescriptionBuilder {
	b.visionPrescription.Patient = v
	return b
}

// SetEncounter sets the Encounter field.
func (b *VisionPrescriptionBuilder) SetEncounter(v Reference) *VisionPrescriptionBuilder {
	b.visionPrescription.Encounter = &v
	return b
}

// SetDateWritten sets the DateWritten field.
func (b *VisionPrescriptionBuilder) SetDateWritten(v string) *VisionPrescriptionBuilder {
	b.visionPrescription.DateWritten = &v
	return b
}

// SetPrescriber sets the Prescriber field.
func (b *VisionPrescriptionBuilder) SetPrescriber(v Reference) *VisionPrescriptionBuilder {
	b.visionPrescription.Prescriber = v
	return b
}

// AddLensSpecification adds a LensSpecification element.
func (b *VisionPrescriptionBuilder) AddLensSpecification(v VisionPrescriptionLensSpecification) *VisionPrescriptionBuilder {
	b.visionPrescription.LensSpecification = append(b.visionPrescription.LensSpecification, v)
	return b
}

// =============================================================================
// VisionPrescription - Functional Options
// =============================================================================

// VisionPrescriptionOption is a functional option for configuring a VisionPrescription.
type VisionPrescriptionOption func(*VisionPrescription)

// NewVisionPrescription creates a new VisionPrescription with the given options.
func NewVisionPrescription(opts ...VisionPrescriptionOption) *VisionPrescription {
	r := &VisionPrescription{}
	for _, opt := range opts {
		opt(r)
	}
	return r
}

// WithVisionPrescriptionId sets the Id field.
func WithVisionPrescriptionId(v string) VisionPrescriptionOption {
	return func(r *VisionPrescription) {
		r.Id = &v
	}
}

// WithVisionPrescriptionMeta sets the Meta field.
func WithVisionPrescriptionMeta(v Meta) VisionPrescriptionOption {
	return func(r *VisionPrescription) {
		r.Meta = &v
	}
}

// WithVisionPrescriptionImplicitRules sets the ImplicitRules field.
func WithVisionPrescriptionImplicitRules(v string) VisionPrescriptionOption {
	return func(r *VisionPrescription) {
		r.ImplicitRules = &v
	}
}

// WithVisionPrescriptionLanguage sets the Language field.
func WithVisionPrescriptionLanguage(v string) VisionPrescriptionOption {
	return func(r *VisionPrescription) {
		r.Language = &v
	}
}

// WithVisionPrescriptionText sets the Text field.
func WithVisionPrescriptionText(v Narrative) VisionPrescriptionOption {
	return func(r *VisionPrescription) {
		r.Text = &v
	}
}

// WithVisionPrescriptionContained adds a Contained to the VisionPrescription.
func WithVisionPrescriptionContained(v Resource) VisionPrescriptionOption {
	return func(r *VisionPrescription) {
		r.Contained = append(r.Contained, v)
	}
}

// WithVisionPrescriptionExtension adds a Extension to the VisionPrescription.
func WithVisionPrescriptionExtension(v Extension) VisionPrescriptionOption {
	return func(r *VisionPrescription) {
		r.Extension = append(r.Extension, v)
	}
}

// WithVisionPrescriptionModifierExtension adds a ModifierExtension to the VisionPrescription.
func WithVisionPrescriptionModifierExtension(v Extension) VisionPrescriptionOption {
	return func(r *VisionPrescription) {
		r.ModifierExtension = append(r.ModifierExtension, v)
	}
}

// WithVisionPrescriptionIdentifier adds a Identifier to the VisionPrescription.
func WithVisionPrescriptionIdentifier(v Identifier) VisionPrescriptionOption {
	return func(r *VisionPrescription) {
		r.Identifier = append(r.Identifier, v)
	}
}

// WithVisionPrescriptionStatus sets the Status field.
func WithVisionPrescriptionStatus(v FinancialResourceStatusCodes) VisionPrescriptionOption {
	return func(r *VisionPrescription) {
		r.Status = &v
	}
}

// WithVisionPrescriptionCreated sets the Created field.
func WithVisionPrescriptionCreated(v string) VisionPrescriptionOption {
	return func(r *VisionPrescription) {
		r.Created = &v
	}
}

// WithVisionPrescriptionPatient sets the Patient field.
func WithVisionPrescriptionPatient(v Reference) VisionPrescriptionOption {
	return func(r *VisionPrescription) {
		r.Patient = v
	}
}

// WithVisionPrescriptionEncounter sets the Encounter field.
func WithVisionPrescriptionEncounter(v Reference) VisionPrescriptionOption {
	return func(r *VisionPrescription) {
		r.Encounter = &v
	}
}

// WithVisionPrescriptionDateWritten sets the DateWritten field.
func WithVisionPrescriptionDateWritten(v string) VisionPrescriptionOption {
	return func(r *VisionPrescription) {
		r.DateWritten = &v
	}
}

// WithVisionPrescriptionPrescriber sets the Prescriber field.
func WithVisionPrescriptionPrescriber(v Reference) VisionPrescriptionOption {
	return func(r *VisionPrescription) {
		r.Prescriber = v
	}
}

// WithVisionPrescriptionLensSpecification adds a LensSpecification to the VisionPrescription.
func WithVisionPrescriptionLensSpecification(v VisionPrescriptionLensSpecification) VisionPrescriptionOption {
	return func(r *VisionPrescription) {
		r.LensSpecification = append(r.LensSpecification, v)
	}
}
