// Code generated by gofhir. DO NOT EDIT.
// Source: FHIR StructureDefinitions (consolidated resource)
// Package: r4b

package r4b

import (
	"bytes"
	"encoding/json"
	"encoding/xml"
	"fmt"
)

// =============================================================================
// MedicationKnowledge Resource
// =============================================================================

// MedicationKnowledge represents FHIR MedicationKnowledge.
type MedicationKnowledge struct {
	// FHIR resource type
	ResourceType string `json:"resourceType"`
	// Logical id of this artifact
	Id *string `json:"id,omitempty"`
	// Metadata about the resource
	Meta *Meta `json:"meta,omitempty"`
	// A set of rules under which this content was created
	ImplicitRules *string `json:"implicitRules,omitempty"`
	// Extension for ImplicitRules
	ImplicitRulesExt *Element `json:"_implicitRules,omitempty"`
	// Language of the resource content
	Language *string `json:"language,omitempty"`
	// Extension for Language
	LanguageExt *Element `json:"_language,omitempty"`
	// Text summary of the resource, for human interpretation
	Text *Narrative `json:"text,omitempty"`
	// Contained, inline Resources
	Contained []Resource `json:"contained,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Code that identifies this medication
	Code *CodeableConcept `json:"code,omitempty"`
	// active | inactive | entered-in-error
	Status *MedicationKnowledgeStatusCodes `json:"status,omitempty"`
	// Extension for Status
	StatusExt *Element `json:"_status,omitempty"`
	// Manufacturer of the item
	Manufacturer *Reference `json:"manufacturer,omitempty"`
	// powder | tablets | capsule +
	DoseForm *CodeableConcept `json:"doseForm,omitempty"`
	// Amount of drug in package
	Amount *Quantity `json:"amount,omitempty"`
	// Additional names for a medication
	Synonym []string `json:"synonym,omitempty"`
	// Extension for Synonym
	SynonymExt []Element `json:"_synonym,omitempty"`
	// Associated or related medication information
	RelatedMedicationKnowledge []MedicationKnowledgeRelatedMedicationKnowledge `json:"relatedMedicationKnowledge,omitempty"`
	// A medication resource that is associated with this medication
	AssociatedMedication []Reference `json:"associatedMedication,omitempty"`
	// Category of the medication or product
	ProductType []CodeableConcept `json:"productType,omitempty"`
	// Associated documentation about the medication
	Monograph []MedicationKnowledgeMonograph `json:"monograph,omitempty"`
	// Active or inactive ingredient
	Ingredient []MedicationKnowledgeIngredient `json:"ingredient,omitempty"`
	// The instructions for preparing the medication
	PreparationInstruction *string `json:"preparationInstruction,omitempty"`
	// Extension for PreparationInstruction
	PreparationInstructionExt *Element `json:"_preparationInstruction,omitempty"`
	// The intended or approved route of administration
	IntendedRoute []CodeableConcept `json:"intendedRoute,omitempty"`
	// The pricing of the medication
	Cost []MedicationKnowledgeCost `json:"cost,omitempty"`
	// Program under which a medication is reviewed
	MonitoringProgram []MedicationKnowledgeMonitoringProgram `json:"monitoringProgram,omitempty"`
	// Guidelines for administration of the medication
	AdministrationGuidelines []MedicationKnowledgeAdministrationGuidelines `json:"administrationGuidelines,omitempty"`
	// Categorization of the medication within a formulary or classification system
	MedicineClassification []MedicationKnowledgeMedicineClassification `json:"medicineClassification,omitempty"`
	// Details about packaged medications
	Packaging *MedicationKnowledgePackaging `json:"packaging,omitempty"`
	// Specifies descriptive properties of the medicine
	DrugCharacteristic []MedicationKnowledgeDrugCharacteristic `json:"drugCharacteristic,omitempty"`
	// Potential clinical issue with or between medication(s)
	Contraindication []Reference `json:"contraindication,omitempty"`
	// Regulatory information about a medication
	Regulatory []MedicationKnowledgeRegulatory `json:"regulatory,omitempty"`
	// The time course of drug absorption, distribution, metabolism and excretion of a medication from the body
	Kinetics []MedicationKnowledgeKinetics `json:"kinetics,omitempty"`
}

// GetResourceType returns the FHIR resource type.
func (r *MedicationKnowledge) GetResourceType() string {
	return "MedicationKnowledge"
}

// GetId returns the resource's logical ID.
func (r *MedicationKnowledge) GetId() *string {
	return r.Id
}

// SetId sets the resource's logical ID.
func (r *MedicationKnowledge) SetId(id string) {
	r.Id = &id
}

// GetMeta returns the resource's Meta element.
func (r *MedicationKnowledge) GetMeta() *Meta {
	return r.Meta
}

// SetMeta sets the resource's Meta element.
func (r *MedicationKnowledge) SetMeta(m *Meta) {
	r.Meta = m
}

// GetText returns the resource's narrative text.
func (r *MedicationKnowledge) GetText() *Narrative {
	return r.Text
}

// SetText sets the resource's narrative text.
func (r *MedicationKnowledge) SetText(t *Narrative) {
	r.Text = t
}

// GetContained returns the resource's contained resources.
func (r *MedicationKnowledge) GetContained() []Resource {
	return r.Contained
}

// GetExtension returns the resource's extensions.
func (r *MedicationKnowledge) GetExtension() []Extension {
	return r.Extension
}

// GetModifierExtension returns the resource's modifier extensions.
func (r *MedicationKnowledge) GetModifierExtension() []Extension {
	return r.ModifierExtension
}

// MarshalJSON ensures resourceType is always included in JSON output.
// HTML escaping is disabled to preserve FHIR narrative XHTML content.
//
// Note: Use the package-level Marshal function instead of json.Marshal
// to ensure HTML in narrative text.div fields is not escaped.
func (r MedicationKnowledge) MarshalJSON() ([]byte, error) {
	r.ResourceType = "MedicationKnowledge"
	type Alias MedicationKnowledge
	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	enc.SetEscapeHTML(false)
	if err := enc.Encode((Alias)(r)); err != nil {
		return nil, err
	}
	b := buf.Bytes()
	if len(b) > 0 && b[len(b)-1] == '\n' {
		b = b[:len(b)-1]
	}
	return b, nil
}

// UnmarshalJSON handles deserialization of polymorphic contained resources.
func (r *MedicationKnowledge) UnmarshalJSON(data []byte) error {
	// Use an alias to avoid infinite recursion
	type Alias MedicationKnowledge
	aux := &struct {
		Contained []json.RawMessage `json:"contained,omitempty"`
		*Alias
	}{
		Alias: (*Alias)(r),
	}

	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}

	// Unmarshal each contained resource using the dispatcher
	if len(aux.Contained) > 0 {
		r.Contained = make([]Resource, len(aux.Contained))
		for i, raw := range aux.Contained {
			resource, err := UnmarshalResource(raw)
			if err != nil {
				return fmt.Errorf("failed to unmarshal contained[%d]: %w", i, err)
			}
			r.Contained[i] = resource
		}
	}

	return nil
}

// MarshalXML serializes MedicationKnowledge to FHIR-conformant XML.
func (r MedicationKnowledge) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MedicationKnowledge"
		start.Name.Space = fhirNamespace
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	if err := xmlEncodePrimitiveString(e, "id", r.Id, nil); err != nil {
		return err
	}
	if r.Meta != nil {
		if err := r.Meta.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "meta"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "implicitRules", r.ImplicitRules, r.ImplicitRulesExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "language", r.Language, r.LanguageExt); err != nil {
		return err
	}
	if r.Text != nil {
		if err := r.Text.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "text"}}); err != nil {
			return err
		}
	}
	for _, c := range r.Contained {
		if c != nil {
			if err := xmlEncodeContainedResource(e, c); err != nil {
				return err
			}
		}
	}
	for _, item := range r.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range r.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if r.Code != nil {
		if err := r.Code.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "code"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveCode(e, "status", r.Status, r.StatusExt); err != nil {
		return err
	}
	if r.Manufacturer != nil {
		if err := r.Manufacturer.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "manufacturer"}}); err != nil {
			return err
		}
	}
	if r.DoseForm != nil {
		if err := r.DoseForm.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "doseForm"}}); err != nil {
			return err
		}
	}
	if r.Amount != nil {
		if err := r.Amount.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "amount"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveStringArray(e, "synonym", r.Synonym, r.SynonymExt); err != nil {
		return err
	}
	for _, item := range r.RelatedMedicationKnowledge {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "relatedMedicationKnowledge"}}); err != nil {
			return err
		}
	}
	for _, item := range r.AssociatedMedication {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "associatedMedication"}}); err != nil {
			return err
		}
	}
	for _, item := range r.ProductType {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "productType"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Monograph {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "monograph"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Ingredient {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "ingredient"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "preparationInstruction", r.PreparationInstruction, r.PreparationInstructionExt); err != nil {
		return err
	}
	for _, item := range r.IntendedRoute {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "intendedRoute"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Cost {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "cost"}}); err != nil {
			return err
		}
	}
	for _, item := range r.MonitoringProgram {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "monitoringProgram"}}); err != nil {
			return err
		}
	}
	for _, item := range r.AdministrationGuidelines {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "administrationGuidelines"}}); err != nil {
			return err
		}
	}
	for _, item := range r.MedicineClassification {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "medicineClassification"}}); err != nil {
			return err
		}
	}
	if r.Packaging != nil {
		if err := r.Packaging.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "packaging"}}); err != nil {
			return err
		}
	}
	for _, item := range r.DrugCharacteristic {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "drugCharacteristic"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Contraindication {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "contraindication"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Regulatory {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "regulatory"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Kinetics {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "kinetics"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MedicationKnowledge from FHIR-conformant XML.
func (r *MedicationKnowledge) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "id":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Id = v
			case "meta":
				var v Meta
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Meta = &v
			case "implicitRules":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ImplicitRules = v
				r.ImplicitRulesExt = ext
			case "language":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Language = v
				r.LanguageExt = ext
			case "text":
				var v Narrative
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Text = &v
			case "contained":
				res, err := xmlDecodeContainedResource(d, t)
				if err != nil {
					return err
				}
				if res != nil {
					r.Contained = append(r.Contained, res)
				}
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "code":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Code = &v
			case "status":
				v, ext, err := xmlDecodePrimitiveCode[MedicationKnowledgeStatusCodes](d, t)
				if err != nil {
					return err
				}
				r.Status = v
				r.StatusExt = ext
			case "manufacturer":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Manufacturer = &v
			case "doseForm":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.DoseForm = &v
			case "amount":
				var v Quantity
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Amount = &v
			case "synonym":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.Synonym = append(r.Synonym, *v)
				}
			case "relatedMedicationKnowledge":
				var v MedicationKnowledgeRelatedMedicationKnowledge
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.RelatedMedicationKnowledge = append(r.RelatedMedicationKnowledge, v)
			case "associatedMedication":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.AssociatedMedication = append(r.AssociatedMedication, v)
			case "productType":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ProductType = append(r.ProductType, v)
			case "monograph":
				var v MedicationKnowledgeMonograph
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Monograph = append(r.Monograph, v)
			case "ingredient":
				var v MedicationKnowledgeIngredient
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Ingredient = append(r.Ingredient, v)
			case "preparationInstruction":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.PreparationInstruction = v
				r.PreparationInstructionExt = ext
			case "intendedRoute":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.IntendedRoute = append(r.IntendedRoute, v)
			case "cost":
				var v MedicationKnowledgeCost
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Cost = append(r.Cost, v)
			case "monitoringProgram":
				var v MedicationKnowledgeMonitoringProgram
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.MonitoringProgram = append(r.MonitoringProgram, v)
			case "administrationGuidelines":
				var v MedicationKnowledgeAdministrationGuidelines
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.AdministrationGuidelines = append(r.AdministrationGuidelines, v)
			case "medicineClassification":
				var v MedicationKnowledgeMedicineClassification
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.MedicineClassification = append(r.MedicineClassification, v)
			case "packaging":
				var v MedicationKnowledgePackaging
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Packaging = &v
			case "drugCharacteristic":
				var v MedicationKnowledgeDrugCharacteristic
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.DrugCharacteristic = append(r.DrugCharacteristic, v)
			case "contraindication":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Contraindication = append(r.Contraindication, v)
			case "regulatory":
				var v MedicationKnowledgeRegulatory
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Regulatory = append(r.Regulatory, v)
			case "kinetics":
				var v MedicationKnowledgeKinetics
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Kinetics = append(r.Kinetics, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MedicationKnowledgeAdministrationGuidelines represents the MedicationKnowledge.administrationGuidelines backbone element.
// Guidelines for administration of the medication
type MedicationKnowledgeAdministrationGuidelines struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Dosage for the medication for the specific guidelines
	Dosage []MedicationKnowledgeAdministrationGuidelinesDosage `json:"dosage,omitempty"`
	// Indication for use that apply to the specific administration guidelines
	IndicationCodeableConcept *CodeableConcept `json:"indicationCodeableConcept,omitempty"`
	// Indication for use that apply to the specific administration guidelines
	IndicationReference *Reference `json:"indicationReference,omitempty"`
	// Characteristics of the patient that are relevant to the administration guidelines
	PatientCharacteristics []MedicationKnowledgeAdministrationGuidelinesPatientCharacteristics `json:"patientCharacteristics,omitempty"`
}

// MarshalXML serializes MedicationKnowledgeAdministrationGuidelines to FHIR-conformant XML.
func (b MedicationKnowledgeAdministrationGuidelines) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MedicationKnowledge.administrationGuidelines"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Dosage {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "dosage"}}); err != nil {
			return err
		}
	}
	if b.IndicationCodeableConcept != nil {
		if err := b.IndicationCodeableConcept.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "indicationCodeableConcept"}}); err != nil {
			return err
		}
	}
	if b.IndicationReference != nil {
		if err := b.IndicationReference.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "indicationReference"}}); err != nil {
			return err
		}
	}
	for _, item := range b.PatientCharacteristics {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "patientCharacteristics"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MedicationKnowledgeAdministrationGuidelines from FHIR-conformant XML.
func (r *MedicationKnowledgeAdministrationGuidelines) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "dosage":
				var v MedicationKnowledgeAdministrationGuidelinesDosage
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Dosage = append(r.Dosage, v)
			case "indicationCodeableConcept":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.IndicationCodeableConcept = &v
			case "indicationReference":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.IndicationReference = &v
			case "patientCharacteristics":
				var v MedicationKnowledgeAdministrationGuidelinesPatientCharacteristics
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.PatientCharacteristics = append(r.PatientCharacteristics, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MedicationKnowledgeAdministrationGuidelinesDosage represents the MedicationKnowledge.administrationGuidelines.dosage backbone element.
// Dosage for the medication for the specific guidelines
type MedicationKnowledgeAdministrationGuidelinesDosage struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Type of dosage
	Type CodeableConcept `json:"type,omitempty"`
	// Dosage for the medication for the specific guidelines
	Dosage []Dosage `json:"dosage,omitempty"`
}

// MarshalXML serializes MedicationKnowledgeAdministrationGuidelinesDosage to FHIR-conformant XML.
func (b MedicationKnowledgeAdministrationGuidelinesDosage) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MedicationKnowledge.administrationGuidelines.dosage"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
		return err
	}
	for _, item := range b.Dosage {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "dosage"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MedicationKnowledgeAdministrationGuidelinesDosage from FHIR-conformant XML.
func (r *MedicationKnowledgeAdministrationGuidelinesDosage) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "type":
				if err := r.Type.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "dosage":
				var v Dosage
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Dosage = append(r.Dosage, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MedicationKnowledgeAdministrationGuidelinesPatientCharacteristics represents the MedicationKnowledge.administrationGuidelines.patientCharacteristics backbone element.
// Characteristics of the patient that are relevant to the administration guidelines
type MedicationKnowledgeAdministrationGuidelinesPatientCharacteristics struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Specific characteristic that is relevant to the administration guideline
	CharacteristicCodeableConcept *CodeableConcept `json:"characteristicCodeableConcept,omitempty"`
	// Specific characteristic that is relevant to the administration guideline
	CharacteristicQuantity *Quantity `json:"characteristicQuantity,omitempty"`
	// The specific characteristic
	Value []string `json:"value,omitempty"`
}

// MarshalXML serializes MedicationKnowledgeAdministrationGuidelinesPatientCharacteristics to FHIR-conformant XML.
func (b MedicationKnowledgeAdministrationGuidelinesPatientCharacteristics) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MedicationKnowledge.administrationGuidelines.patientCharacteristics"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.CharacteristicCodeableConcept != nil {
		if err := b.CharacteristicCodeableConcept.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "characteristicCodeableConcept"}}); err != nil {
			return err
		}
	}
	if b.CharacteristicQuantity != nil {
		if err := b.CharacteristicQuantity.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "characteristicQuantity"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveStringArray(e, "value", b.Value, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MedicationKnowledgeAdministrationGuidelinesPatientCharacteristics from FHIR-conformant XML.
func (r *MedicationKnowledgeAdministrationGuidelinesPatientCharacteristics) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "characteristicCodeableConcept":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.CharacteristicCodeableConcept = &v
			case "characteristicQuantity":
				var v Quantity
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.CharacteristicQuantity = &v
			case "value":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.Value = append(r.Value, *v)
				}
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MedicationKnowledgeCost represents the MedicationKnowledge.cost backbone element.
// The pricing of the medication
type MedicationKnowledgeCost struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The category of the cost information
	Type CodeableConcept `json:"type,omitempty"`
	// The source or owner for the price information
	Source *string `json:"source,omitempty"`
	// The price of the medication
	Cost Money `json:"cost,omitempty"`
}

// MarshalXML serializes MedicationKnowledgeCost to FHIR-conformant XML.
func (b MedicationKnowledgeCost) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MedicationKnowledge.cost"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "source", b.Source, nil); err != nil {
		return err
	}
	if err := b.Cost.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "cost"}}); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MedicationKnowledgeCost from FHIR-conformant XML.
func (r *MedicationKnowledgeCost) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "type":
				if err := r.Type.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "source":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Source = v
			case "cost":
				if err := r.Cost.UnmarshalXML(d, t); err != nil {
					return err
				}
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MedicationKnowledgeDrugCharacteristic represents the MedicationKnowledge.drugCharacteristic backbone element.
// Specifies descriptive properties of the medicine
type MedicationKnowledgeDrugCharacteristic struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Code specifying the type of characteristic of medication
	Type *CodeableConcept `json:"type,omitempty"`
	// Description of the characteristic
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`
	// Description of the characteristic
	ValueString *string `json:"valueString,omitempty"`
	// Extension for ValueString
	ValueStringExt *Element `json:"_valueString,omitempty"`
	// Description of the characteristic
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`
	// Description of the characteristic
	ValueBase64Binary *string `json:"valueBase64Binary,omitempty"`
	// Extension for ValueBase64Binary
	ValueBase64BinaryExt *Element `json:"_valueBase64Binary,omitempty"`
}

// MarshalXML serializes MedicationKnowledgeDrugCharacteristic to FHIR-conformant XML.
func (b MedicationKnowledgeDrugCharacteristic) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MedicationKnowledge.drugCharacteristic"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.Type != nil {
		if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
			return err
		}
	}
	if b.ValueCodeableConcept != nil {
		if err := b.ValueCodeableConcept.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueCodeableConcept"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "valueString", b.ValueString, nil); err != nil {
		return err
	}
	if b.ValueQuantity != nil {
		if err := b.ValueQuantity.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueQuantity"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "valueBase64Binary", b.ValueBase64Binary, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MedicationKnowledgeDrugCharacteristic from FHIR-conformant XML.
func (r *MedicationKnowledgeDrugCharacteristic) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "type":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Type = &v
			case "valueCodeableConcept":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueCodeableConcept = &v
			case "valueString":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ValueString = v
			case "valueQuantity":
				var v Quantity
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueQuantity = &v
			case "valueBase64Binary":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ValueBase64Binary = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MedicationKnowledgeIngredient represents the MedicationKnowledge.ingredient backbone element.
// Active or inactive ingredient
type MedicationKnowledgeIngredient struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Medication(s) or substance(s) contained in the medication
	ItemCodeableConcept *CodeableConcept `json:"itemCodeableConcept,omitempty"`
	// Medication(s) or substance(s) contained in the medication
	ItemReference *Reference `json:"itemReference,omitempty"`
	// Active ingredient indicator
	IsActive *bool `json:"isActive,omitempty"`
	// Quantity of ingredient present
	Strength *Ratio `json:"strength,omitempty"`
}

// MarshalXML serializes MedicationKnowledgeIngredient to FHIR-conformant XML.
func (b MedicationKnowledgeIngredient) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MedicationKnowledge.ingredient"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.ItemCodeableConcept != nil {
		if err := b.ItemCodeableConcept.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "itemCodeableConcept"}}); err != nil {
			return err
		}
	}
	if b.ItemReference != nil {
		if err := b.ItemReference.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "itemReference"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveBool(e, "isActive", b.IsActive, nil); err != nil {
		return err
	}
	if b.Strength != nil {
		if err := b.Strength.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "strength"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MedicationKnowledgeIngredient from FHIR-conformant XML.
func (r *MedicationKnowledgeIngredient) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "itemCodeableConcept":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ItemCodeableConcept = &v
			case "itemReference":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ItemReference = &v
			case "isActive":
				v, _, err := xmlDecodePrimitiveBool(d, t)
				if err != nil {
					return err
				}
				r.IsActive = v
			case "strength":
				var v Ratio
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Strength = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MedicationKnowledgeKinetics represents the MedicationKnowledge.kinetics backbone element.
// The time course of drug absorption, distribution, metabolism and excretion of a medication from the body
type MedicationKnowledgeKinetics struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The drug concentration measured at certain discrete points in time
	AreaUnderCurve []Quantity `json:"areaUnderCurve,omitempty"`
	// The median lethal dose of a drug
	LethalDose50 []Quantity `json:"lethalDose50,omitempty"`
	// Time required for concentration in the body to decrease by half
	HalfLifePeriod *Duration `json:"halfLifePeriod,omitempty"`
}

// MarshalXML serializes MedicationKnowledgeKinetics to FHIR-conformant XML.
func (b MedicationKnowledgeKinetics) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MedicationKnowledge.kinetics"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.AreaUnderCurve {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "areaUnderCurve"}}); err != nil {
			return err
		}
	}
	for _, item := range b.LethalDose50 {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "lethalDose50"}}); err != nil {
			return err
		}
	}
	if b.HalfLifePeriod != nil {
		if err := b.HalfLifePeriod.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "halfLifePeriod"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MedicationKnowledgeKinetics from FHIR-conformant XML.
func (r *MedicationKnowledgeKinetics) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "areaUnderCurve":
				var v Quantity
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.AreaUnderCurve = append(r.AreaUnderCurve, v)
			case "lethalDose50":
				var v Quantity
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.LethalDose50 = append(r.LethalDose50, v)
			case "halfLifePeriod":
				var v Duration
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.HalfLifePeriod = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MedicationKnowledgeMedicineClassification represents the MedicationKnowledge.medicineClassification backbone element.
// Categorization of the medication within a formulary or classification system
type MedicationKnowledgeMedicineClassification struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The type of category for the medication (for example, therapeutic classification, therapeutic sub-classification)
	Type CodeableConcept `json:"type,omitempty"`
	// Specific category assigned to the medication
	Classification []CodeableConcept `json:"classification,omitempty"`
}

// MarshalXML serializes MedicationKnowledgeMedicineClassification to FHIR-conformant XML.
func (b MedicationKnowledgeMedicineClassification) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MedicationKnowledge.medicineClassification"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
		return err
	}
	for _, item := range b.Classification {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "classification"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MedicationKnowledgeMedicineClassification from FHIR-conformant XML.
func (r *MedicationKnowledgeMedicineClassification) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "type":
				if err := r.Type.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "classification":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Classification = append(r.Classification, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MedicationKnowledgeMonitoringProgram represents the MedicationKnowledge.monitoringProgram backbone element.
// Program under which a medication is reviewed
type MedicationKnowledgeMonitoringProgram struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Type of program under which the medication is monitored
	Type *CodeableConcept `json:"type,omitempty"`
	// Name of the reviewing program
	Name *string `json:"name,omitempty"`
}

// MarshalXML serializes MedicationKnowledgeMonitoringProgram to FHIR-conformant XML.
func (b MedicationKnowledgeMonitoringProgram) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MedicationKnowledge.monitoringProgram"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.Type != nil {
		if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "name", b.Name, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MedicationKnowledgeMonitoringProgram from FHIR-conformant XML.
func (r *MedicationKnowledgeMonitoringProgram) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "type":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Type = &v
			case "name":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Name = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MedicationKnowledgeMonograph represents the MedicationKnowledge.monograph backbone element.
// Associated documentation about the medication
type MedicationKnowledgeMonograph struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The category of medication document
	Type *CodeableConcept `json:"type,omitempty"`
	// Associated documentation about the medication
	Source *Reference `json:"source,omitempty"`
}

// MarshalXML serializes MedicationKnowledgeMonograph to FHIR-conformant XML.
func (b MedicationKnowledgeMonograph) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MedicationKnowledge.monograph"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.Type != nil {
		if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
			return err
		}
	}
	if b.Source != nil {
		if err := b.Source.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "source"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MedicationKnowledgeMonograph from FHIR-conformant XML.
func (r *MedicationKnowledgeMonograph) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "type":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Type = &v
			case "source":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Source = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MedicationKnowledgePackaging represents the MedicationKnowledge.packaging backbone element.
// Details about packaged medications
type MedicationKnowledgePackaging struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// A code that defines the specific type of packaging that the medication can be found in
	Type *CodeableConcept `json:"type,omitempty"`
	// The number of product units the package would contain if fully loaded
	Quantity *Quantity `json:"quantity,omitempty"`
}

// MarshalXML serializes MedicationKnowledgePackaging to FHIR-conformant XML.
func (b MedicationKnowledgePackaging) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MedicationKnowledge.packaging"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.Type != nil {
		if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
			return err
		}
	}
	if b.Quantity != nil {
		if err := b.Quantity.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "quantity"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MedicationKnowledgePackaging from FHIR-conformant XML.
func (r *MedicationKnowledgePackaging) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "type":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Type = &v
			case "quantity":
				var v Quantity
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Quantity = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MedicationKnowledgeRegulatory represents the MedicationKnowledge.regulatory backbone element.
// Regulatory information about a medication
type MedicationKnowledgeRegulatory struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Specifies the authority of the regulation
	RegulatoryAuthority Reference `json:"regulatoryAuthority,omitempty"`
	// Specifies if changes are allowed when dispensing a medication from a regulatory perspective
	Substitution []MedicationKnowledgeRegulatorySubstitution `json:"substitution,omitempty"`
	// Specifies the schedule of a medication in jurisdiction
	Schedule []MedicationKnowledgeRegulatorySchedule `json:"schedule,omitempty"`
	// The maximum number of units of the medication that can be dispensed in a period
	MaxDispense *MedicationKnowledgeRegulatoryMaxDispense `json:"maxDispense,omitempty"`
}

// MarshalXML serializes MedicationKnowledgeRegulatory to FHIR-conformant XML.
func (b MedicationKnowledgeRegulatory) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MedicationKnowledge.regulatory"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := b.RegulatoryAuthority.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "regulatoryAuthority"}}); err != nil {
		return err
	}
	for _, item := range b.Substitution {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "substitution"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Schedule {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "schedule"}}); err != nil {
			return err
		}
	}
	if b.MaxDispense != nil {
		if err := b.MaxDispense.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "maxDispense"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MedicationKnowledgeRegulatory from FHIR-conformant XML.
func (r *MedicationKnowledgeRegulatory) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "regulatoryAuthority":
				if err := r.RegulatoryAuthority.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "substitution":
				var v MedicationKnowledgeRegulatorySubstitution
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Substitution = append(r.Substitution, v)
			case "schedule":
				var v MedicationKnowledgeRegulatorySchedule
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Schedule = append(r.Schedule, v)
			case "maxDispense":
				var v MedicationKnowledgeRegulatoryMaxDispense
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.MaxDispense = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MedicationKnowledgeRegulatoryMaxDispense represents the MedicationKnowledge.regulatory.maxDispense backbone element.
// The maximum number of units of the medication that can be dispensed in a period
type MedicationKnowledgeRegulatoryMaxDispense struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The maximum number of units of the medication that can be dispensed
	Quantity Quantity `json:"quantity,omitempty"`
	// The period that applies to the maximum number of units
	Period *Duration `json:"period,omitempty"`
}

// MarshalXML serializes MedicationKnowledgeRegulatoryMaxDispense to FHIR-conformant XML.
func (b MedicationKnowledgeRegulatoryMaxDispense) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MedicationKnowledge.regulatory.maxDispense"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := b.Quantity.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "quantity"}}); err != nil {
		return err
	}
	if b.Period != nil {
		if err := b.Period.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "period"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MedicationKnowledgeRegulatoryMaxDispense from FHIR-conformant XML.
func (r *MedicationKnowledgeRegulatoryMaxDispense) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "quantity":
				if err := r.Quantity.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "period":
				var v Duration
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Period = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MedicationKnowledgeRegulatorySchedule represents the MedicationKnowledge.regulatory.schedule backbone element.
// Specifies the schedule of a medication in jurisdiction
type MedicationKnowledgeRegulatorySchedule struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Specifies the specific drug schedule
	Schedule CodeableConcept `json:"schedule,omitempty"`
}

// MarshalXML serializes MedicationKnowledgeRegulatorySchedule to FHIR-conformant XML.
func (b MedicationKnowledgeRegulatorySchedule) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MedicationKnowledge.regulatory.schedule"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := b.Schedule.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "schedule"}}); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MedicationKnowledgeRegulatorySchedule from FHIR-conformant XML.
func (r *MedicationKnowledgeRegulatorySchedule) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "schedule":
				if err := r.Schedule.UnmarshalXML(d, t); err != nil {
					return err
				}
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MedicationKnowledgeRegulatorySubstitution represents the MedicationKnowledge.regulatory.substitution backbone element.
// Specifies if changes are allowed when dispensing a medication from a regulatory perspective
type MedicationKnowledgeRegulatorySubstitution struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Specifies the type of substitution allowed
	Type CodeableConcept `json:"type,omitempty"`
	// Specifies if regulation allows for changes in the medication when dispensing
	Allowed *bool `json:"allowed,omitempty"`
}

// MarshalXML serializes MedicationKnowledgeRegulatorySubstitution to FHIR-conformant XML.
func (b MedicationKnowledgeRegulatorySubstitution) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MedicationKnowledge.regulatory.substitution"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveBool(e, "allowed", b.Allowed, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MedicationKnowledgeRegulatorySubstitution from FHIR-conformant XML.
func (r *MedicationKnowledgeRegulatorySubstitution) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "type":
				if err := r.Type.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "allowed":
				v, _, err := xmlDecodePrimitiveBool(d, t)
				if err != nil {
					return err
				}
				r.Allowed = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MedicationKnowledgeRelatedMedicationKnowledge represents the MedicationKnowledge.relatedMedicationKnowledge backbone element.
// Associated or related medication information
type MedicationKnowledgeRelatedMedicationKnowledge struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Category of medicationKnowledge
	Type CodeableConcept `json:"type,omitempty"`
	// Associated documentation about the associated medication knowledge
	Reference []Reference `json:"reference,omitempty"`
}

// MarshalXML serializes MedicationKnowledgeRelatedMedicationKnowledge to FHIR-conformant XML.
func (b MedicationKnowledgeRelatedMedicationKnowledge) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MedicationKnowledge.relatedMedicationKnowledge"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
		return err
	}
	for _, item := range b.Reference {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "reference"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MedicationKnowledgeRelatedMedicationKnowledge from FHIR-conformant XML.
func (r *MedicationKnowledgeRelatedMedicationKnowledge) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "type":
				if err := r.Type.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "reference":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Reference = append(r.Reference, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// =============================================================================
// MedicationKnowledge - Fluent Builder
// =============================================================================

// MedicationKnowledgeBuilder provides a fluent API for constructing MedicationKnowledge resources.
type MedicationKnowledgeBuilder struct {
	medicationKnowledge *MedicationKnowledge
}

// NewMedicationKnowledgeBuilder creates a new MedicationKnowledgeBuilder.
func NewMedicationKnowledgeBuilder() *MedicationKnowledgeBuilder {
	return &MedicationKnowledgeBuilder{
		medicationKnowledge: &MedicationKnowledge{},
	}
}

// Build returns the constructed MedicationKnowledge resource.
func (b *MedicationKnowledgeBuilder) Build() *MedicationKnowledge {
	return b.medicationKnowledge
}

// SetId sets the Id field.
func (b *MedicationKnowledgeBuilder) SetId(v string) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.Id = &v
	return b
}

// SetMeta sets the Meta field.
func (b *MedicationKnowledgeBuilder) SetMeta(v Meta) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.Meta = &v
	return b
}

// SetImplicitRules sets the ImplicitRules field.
func (b *MedicationKnowledgeBuilder) SetImplicitRules(v string) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.ImplicitRules = &v
	return b
}

// SetLanguage sets the Language field.
func (b *MedicationKnowledgeBuilder) SetLanguage(v string) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.Language = &v
	return b
}

// SetText sets the Text field.
func (b *MedicationKnowledgeBuilder) SetText(v Narrative) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.Text = &v
	return b
}

// AddContained adds a Contained element.
func (b *MedicationKnowledgeBuilder) AddContained(v Resource) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.Contained = append(b.medicationKnowledge.Contained, v)
	return b
}

// AddExtension adds a Extension element.
func (b *MedicationKnowledgeBuilder) AddExtension(v Extension) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.Extension = append(b.medicationKnowledge.Extension, v)
	return b
}

// AddModifierExtension adds a ModifierExtension element.
func (b *MedicationKnowledgeBuilder) AddModifierExtension(v Extension) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.ModifierExtension = append(b.medicationKnowledge.ModifierExtension, v)
	return b
}

// SetCode sets the Code field.
func (b *MedicationKnowledgeBuilder) SetCode(v CodeableConcept) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.Code = &v
	return b
}

// SetStatus sets the Status field.
func (b *MedicationKnowledgeBuilder) SetStatus(v MedicationKnowledgeStatusCodes) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.Status = &v
	return b
}

// SetManufacturer sets the Manufacturer field.
func (b *MedicationKnowledgeBuilder) SetManufacturer(v Reference) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.Manufacturer = &v
	return b
}

// SetDoseForm sets the DoseForm field.
func (b *MedicationKnowledgeBuilder) SetDoseForm(v CodeableConcept) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.DoseForm = &v
	return b
}

// SetAmount sets the Amount field.
func (b *MedicationKnowledgeBuilder) SetAmount(v Quantity) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.Amount = &v
	return b
}

// AddSynonym adds a Synonym element.
func (b *MedicationKnowledgeBuilder) AddSynonym(v string) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.Synonym = append(b.medicationKnowledge.Synonym, v)
	return b
}

// AddRelatedMedicationKnowledge adds a RelatedMedicationKnowledge element.
func (b *MedicationKnowledgeBuilder) AddRelatedMedicationKnowledge(v MedicationKnowledgeRelatedMedicationKnowledge) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.RelatedMedicationKnowledge = append(b.medicationKnowledge.RelatedMedicationKnowledge, v)
	return b
}

// AddAssociatedMedication adds a AssociatedMedication element.
func (b *MedicationKnowledgeBuilder) AddAssociatedMedication(v Reference) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.AssociatedMedication = append(b.medicationKnowledge.AssociatedMedication, v)
	return b
}

// AddProductType adds a ProductType element.
func (b *MedicationKnowledgeBuilder) AddProductType(v CodeableConcept) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.ProductType = append(b.medicationKnowledge.ProductType, v)
	return b
}

// AddMonograph adds a Monograph element.
func (b *MedicationKnowledgeBuilder) AddMonograph(v MedicationKnowledgeMonograph) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.Monograph = append(b.medicationKnowledge.Monograph, v)
	return b
}

// AddIngredient adds a Ingredient element.
func (b *MedicationKnowledgeBuilder) AddIngredient(v MedicationKnowledgeIngredient) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.Ingredient = append(b.medicationKnowledge.Ingredient, v)
	return b
}

// SetPreparationInstruction sets the PreparationInstruction field.
func (b *MedicationKnowledgeBuilder) SetPreparationInstruction(v string) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.PreparationInstruction = &v
	return b
}

// AddIntendedRoute adds a IntendedRoute element.
func (b *MedicationKnowledgeBuilder) AddIntendedRoute(v CodeableConcept) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.IntendedRoute = append(b.medicationKnowledge.IntendedRoute, v)
	return b
}

// AddCost adds a Cost element.
func (b *MedicationKnowledgeBuilder) AddCost(v MedicationKnowledgeCost) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.Cost = append(b.medicationKnowledge.Cost, v)
	return b
}

// AddMonitoringProgram adds a MonitoringProgram element.
func (b *MedicationKnowledgeBuilder) AddMonitoringProgram(v MedicationKnowledgeMonitoringProgram) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.MonitoringProgram = append(b.medicationKnowledge.MonitoringProgram, v)
	return b
}

// AddAdministrationGuidelines adds a AdministrationGuidelines element.
func (b *MedicationKnowledgeBuilder) AddAdministrationGuidelines(v MedicationKnowledgeAdministrationGuidelines) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.AdministrationGuidelines = append(b.medicationKnowledge.AdministrationGuidelines, v)
	return b
}

// AddMedicineClassification adds a MedicineClassification element.
func (b *MedicationKnowledgeBuilder) AddMedicineClassification(v MedicationKnowledgeMedicineClassification) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.MedicineClassification = append(b.medicationKnowledge.MedicineClassification, v)
	return b
}

// SetPackaging sets the Packaging field.
func (b *MedicationKnowledgeBuilder) SetPackaging(v MedicationKnowledgePackaging) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.Packaging = &v
	return b
}

// AddDrugCharacteristic adds a DrugCharacteristic element.
func (b *MedicationKnowledgeBuilder) AddDrugCharacteristic(v MedicationKnowledgeDrugCharacteristic) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.DrugCharacteristic = append(b.medicationKnowledge.DrugCharacteristic, v)
	return b
}

// AddContraindication adds a Contraindication element.
func (b *MedicationKnowledgeBuilder) AddContraindication(v Reference) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.Contraindication = append(b.medicationKnowledge.Contraindication, v)
	return b
}

// AddRegulatory adds a Regulatory element.
func (b *MedicationKnowledgeBuilder) AddRegulatory(v MedicationKnowledgeRegulatory) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.Regulatory = append(b.medicationKnowledge.Regulatory, v)
	return b
}

// AddKinetics adds a Kinetics element.
func (b *MedicationKnowledgeBuilder) AddKinetics(v MedicationKnowledgeKinetics) *MedicationKnowledgeBuilder {
	b.medicationKnowledge.Kinetics = append(b.medicationKnowledge.Kinetics, v)
	return b
}

// =============================================================================
// MedicationKnowledge - Functional Options
// =============================================================================

// MedicationKnowledgeOption is a functional option for configuring a MedicationKnowledge.
type MedicationKnowledgeOption func(*MedicationKnowledge)

// NewMedicationKnowledge creates a new MedicationKnowledge with the given options.
func NewMedicationKnowledge(opts ...MedicationKnowledgeOption) *MedicationKnowledge {
	r := &MedicationKnowledge{}
	for _, opt := range opts {
		opt(r)
	}
	return r
}

// WithMedicationKnowledgeId sets the Id field.
func WithMedicationKnowledgeId(v string) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.Id = &v
	}
}

// WithMedicationKnowledgeMeta sets the Meta field.
func WithMedicationKnowledgeMeta(v Meta) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.Meta = &v
	}
}

// WithMedicationKnowledgeImplicitRules sets the ImplicitRules field.
func WithMedicationKnowledgeImplicitRules(v string) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.ImplicitRules = &v
	}
}

// WithMedicationKnowledgeLanguage sets the Language field.
func WithMedicationKnowledgeLanguage(v string) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.Language = &v
	}
}

// WithMedicationKnowledgeText sets the Text field.
func WithMedicationKnowledgeText(v Narrative) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.Text = &v
	}
}

// WithMedicationKnowledgeContained adds a Contained to the MedicationKnowledge.
func WithMedicationKnowledgeContained(v Resource) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.Contained = append(r.Contained, v)
	}
}

// WithMedicationKnowledgeExtension adds a Extension to the MedicationKnowledge.
func WithMedicationKnowledgeExtension(v Extension) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.Extension = append(r.Extension, v)
	}
}

// WithMedicationKnowledgeModifierExtension adds a ModifierExtension to the MedicationKnowledge.
func WithMedicationKnowledgeModifierExtension(v Extension) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.ModifierExtension = append(r.ModifierExtension, v)
	}
}

// WithMedicationKnowledgeCode sets the Code field.
func WithMedicationKnowledgeCode(v CodeableConcept) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.Code = &v
	}
}

// WithMedicationKnowledgeStatus sets the Status field.
func WithMedicationKnowledgeStatus(v MedicationKnowledgeStatusCodes) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.Status = &v
	}
}

// WithMedicationKnowledgeManufacturer sets the Manufacturer field.
func WithMedicationKnowledgeManufacturer(v Reference) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.Manufacturer = &v
	}
}

// WithMedicationKnowledgeDoseForm sets the DoseForm field.
func WithMedicationKnowledgeDoseForm(v CodeableConcept) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.DoseForm = &v
	}
}

// WithMedicationKnowledgeAmount sets the Amount field.
func WithMedicationKnowledgeAmount(v Quantity) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.Amount = &v
	}
}

// WithMedicationKnowledgeSynonym adds a Synonym to the MedicationKnowledge.
func WithMedicationKnowledgeSynonym(v string) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.Synonym = append(r.Synonym, v)
	}
}

// WithMedicationKnowledgeRelatedMedicationKnowledge adds a RelatedMedicationKnowledge to the MedicationKnowledge.
func WithMedicationKnowledgeRelatedMedicationKnowledge(v MedicationKnowledgeRelatedMedicationKnowledge) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.RelatedMedicationKnowledge = append(r.RelatedMedicationKnowledge, v)
	}
}

// WithMedicationKnowledgeAssociatedMedication adds a AssociatedMedication to the MedicationKnowledge.
func WithMedicationKnowledgeAssociatedMedication(v Reference) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.AssociatedMedication = append(r.AssociatedMedication, v)
	}
}

// WithMedicationKnowledgeProductType adds a ProductType to the MedicationKnowledge.
func WithMedicationKnowledgeProductType(v CodeableConcept) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.ProductType = append(r.ProductType, v)
	}
}

// WithMedicationKnowledgeMonograph adds a Monograph to the MedicationKnowledge.
func WithMedicationKnowledgeMonograph(v MedicationKnowledgeMonograph) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.Monograph = append(r.Monograph, v)
	}
}

// WithMedicationKnowledgeIngredient adds a Ingredient to the MedicationKnowledge.
func WithMedicationKnowledgeIngredient(v MedicationKnowledgeIngredient) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.Ingredient = append(r.Ingredient, v)
	}
}

// WithMedicationKnowledgePreparationInstruction sets the PreparationInstruction field.
func WithMedicationKnowledgePreparationInstruction(v string) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.PreparationInstruction = &v
	}
}

// WithMedicationKnowledgeIntendedRoute adds a IntendedRoute to the MedicationKnowledge.
func WithMedicationKnowledgeIntendedRoute(v CodeableConcept) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.IntendedRoute = append(r.IntendedRoute, v)
	}
}

// WithMedicationKnowledgeCost adds a Cost to the MedicationKnowledge.
func WithMedicationKnowledgeCost(v MedicationKnowledgeCost) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.Cost = append(r.Cost, v)
	}
}

// WithMedicationKnowledgeMonitoringProgram adds a MonitoringProgram to the MedicationKnowledge.
func WithMedicationKnowledgeMonitoringProgram(v MedicationKnowledgeMonitoringProgram) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.MonitoringProgram = append(r.MonitoringProgram, v)
	}
}

// WithMedicationKnowledgeAdministrationGuidelines adds a AdministrationGuidelines to the MedicationKnowledge.
func WithMedicationKnowledgeAdministrationGuidelines(v MedicationKnowledgeAdministrationGuidelines) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.AdministrationGuidelines = append(r.AdministrationGuidelines, v)
	}
}

// WithMedicationKnowledgeMedicineClassification adds a MedicineClassification to the MedicationKnowledge.
func WithMedicationKnowledgeMedicineClassification(v MedicationKnowledgeMedicineClassification) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.MedicineClassification = append(r.MedicineClassification, v)
	}
}

// WithMedicationKnowledgePackaging sets the Packaging field.
func WithMedicationKnowledgePackaging(v MedicationKnowledgePackaging) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.Packaging = &v
	}
}

// WithMedicationKnowledgeDrugCharacteristic adds a DrugCharacteristic to the MedicationKnowledge.
func WithMedicationKnowledgeDrugCharacteristic(v MedicationKnowledgeDrugCharacteristic) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.DrugCharacteristic = append(r.DrugCharacteristic, v)
	}
}

// WithMedicationKnowledgeContraindication adds a Contraindication to the MedicationKnowledge.
func WithMedicationKnowledgeContraindication(v Reference) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.Contraindication = append(r.Contraindication, v)
	}
}

// WithMedicationKnowledgeRegulatory adds a Regulatory to the MedicationKnowledge.
func WithMedicationKnowledgeRegulatory(v MedicationKnowledgeRegulatory) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.Regulatory = append(r.Regulatory, v)
	}
}

// WithMedicationKnowledgeKinetics adds a Kinetics to the MedicationKnowledge.
func WithMedicationKnowledgeKinetics(v MedicationKnowledgeKinetics) MedicationKnowledgeOption {
	return func(r *MedicationKnowledge) {
		r.Kinetics = append(r.Kinetics, v)
	}
}
