// Code generated by gofhir. DO NOT EDIT.
// Source: FHIR StructureDefinitions (consolidated resource)
// Package: r4b

package r4b

import (
	"bytes"
	"encoding/json"
	"encoding/xml"
	"fmt"
)

// =============================================================================
// Bundle Resource
// =============================================================================

// Bundle represents FHIR Bundle.
type Bundle struct {
	// FHIR resource type
	ResourceType string `json:"resourceType"`
	// Logical id of this artifact
	Id *string `json:"id,omitempty"`
	// Metadata about the resource
	Meta *Meta `json:"meta,omitempty"`
	// A set of rules under which this content was created
	ImplicitRules *string `json:"implicitRules,omitempty"`
	// Extension for ImplicitRules
	ImplicitRulesExt *Element `json:"_implicitRules,omitempty"`
	// Language of the resource content
	Language *string `json:"language,omitempty"`
	// Extension for Language
	LanguageExt *Element `json:"_language,omitempty"`
	// Persistent identifier for the bundle
	Identifier *Identifier `json:"identifier,omitempty"`
	// document | message | transaction | transaction-response | batch | batch-response | history | searchset | collection
	Type *BundleType `json:"type,omitempty"`
	// Extension for Type
	TypeExt *Element `json:"_type,omitempty"`
	// When the bundle was assembled
	Timestamp *string `json:"timestamp,omitempty"`
	// Extension for Timestamp
	TimestampExt *Element `json:"_timestamp,omitempty"`
	// If search, the total number of matches
	Total *uint32 `json:"total,omitempty"`
	// Extension for Total
	TotalExt *Element `json:"_total,omitempty"`
	// Links related to this Bundle
	Link []BundleLink `json:"link,omitempty"`
	// Entry in the bundle - will have a resource or information
	Entry []BundleEntry `json:"entry,omitempty"`
	// Digital Signature
	Signature *Signature `json:"signature,omitempty"`
}

// GetResourceType returns the FHIR resource type.
func (r *Bundle) GetResourceType() string {
	return "Bundle"
}

// GetId returns the resource's logical ID.
func (r *Bundle) GetId() *string {
	return r.Id
}

// SetId sets the resource's logical ID.
func (r *Bundle) SetId(id string) {
	r.Id = &id
}

// GetMeta returns the resource's Meta element.
func (r *Bundle) GetMeta() *Meta {
	return r.Meta
}

// SetMeta sets the resource's Meta element.
func (r *Bundle) SetMeta(m *Meta) {
	r.Meta = m
}

// MarshalJSON ensures resourceType is always included in JSON output.
// HTML escaping is disabled to preserve FHIR narrative XHTML content.
//
// Note: Use the package-level Marshal function instead of json.Marshal
// to ensure HTML in narrative text.div fields is not escaped.
func (r Bundle) MarshalJSON() ([]byte, error) {
	r.ResourceType = "Bundle"
	type Alias Bundle
	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	enc.SetEscapeHTML(false)
	if err := enc.Encode((Alias)(r)); err != nil {
		return nil, err
	}
	b := buf.Bytes()
	if len(b) > 0 && b[len(b)-1] == '\n' {
		b = b[:len(b)-1]
	}
	return b, nil
}

// MarshalXML serializes Bundle to FHIR-conformant XML.
func (r Bundle) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Bundle"
		start.Name.Space = fhirNamespace
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	if err := xmlEncodePrimitiveString(e, "id", r.Id, nil); err != nil {
		return err
	}
	if r.Meta != nil {
		if err := r.Meta.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "meta"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "implicitRules", r.ImplicitRules, r.ImplicitRulesExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "language", r.Language, r.LanguageExt); err != nil {
		return err
	}
	if r.Identifier != nil {
		if err := r.Identifier.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "identifier"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveCode(e, "type", r.Type, r.TypeExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "timestamp", r.Timestamp, r.TimestampExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveUint32(e, "total", r.Total, r.TotalExt); err != nil {
		return err
	}
	for _, item := range r.Link {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "link"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Entry {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "entry"}}); err != nil {
			return err
		}
	}
	if r.Signature != nil {
		if err := r.Signature.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "signature"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes Bundle from FHIR-conformant XML.
func (r *Bundle) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "id":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Id = v
			case "meta":
				var v Meta
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Meta = &v
			case "implicitRules":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ImplicitRules = v
				r.ImplicitRulesExt = ext
			case "language":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Language = v
				r.LanguageExt = ext
			case "identifier":
				var v Identifier
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Identifier = &v
			case "type":
				v, ext, err := xmlDecodePrimitiveCode[BundleType](d, t)
				if err != nil {
					return err
				}
				r.Type = v
				r.TypeExt = ext
			case "timestamp":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Timestamp = v
				r.TimestampExt = ext
			case "total":
				v, ext, err := xmlDecodePrimitiveUint32(d, t)
				if err != nil {
					return err
				}
				r.Total = v
				r.TotalExt = ext
			case "link":
				var v BundleLink
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Link = append(r.Link, v)
			case "entry":
				var v BundleEntry
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Entry = append(r.Entry, v)
			case "signature":
				var v Signature
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Signature = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// BundleEntry represents the Bundle.entry backbone element.
// Entry in the bundle - will have a resource or information
type BundleEntry struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Links related to this entry
	Link []BundleLink `json:"link,omitempty"`
	// URI for resource (Absolute URL server address or URI for UUID/OID)
	FullUrl *string `json:"fullUrl,omitempty"`
	// A resource in the bundle
	Resource Resource `json:"resource,omitempty"`
	// Search related information
	Search *BundleEntrySearch `json:"search,omitempty"`
	// Additional execution information (transaction/batch/history)
	Request *BundleEntryRequest `json:"request,omitempty"`
	// Results of execution (transaction/batch/history)
	Response *BundleEntryResponse `json:"response,omitempty"`
}

// UnmarshalJSON handles deserialization of polymorphic resource field.
func (b *BundleEntry) UnmarshalJSON(data []byte) error {
	// Use an alias to avoid infinite recursion
	type Alias BundleEntry
	aux := &struct {
		Resource json.RawMessage `json:"resource,omitempty"`
		*Alias
	}{
		Alias: (*Alias)(b),
	}

	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}

	// Unmarshal the resource field using the dispatcher
	if len(aux.Resource) > 0 {
		resource, err := UnmarshalResource(aux.Resource)
		if err != nil {
			return fmt.Errorf("failed to unmarshal resource: %w", err)
		}
		b.Resource = resource
	}

	return nil
}

// MarshalXML serializes BundleEntry to FHIR-conformant XML.
func (b BundleEntry) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Bundle.entry"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Link {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "link"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "fullUrl", b.FullUrl, nil); err != nil {
		return err
	}
	if b.Resource != nil {
		if err := xmlEncodeInlineResource(e, b.Resource); err != nil {
			return err
		}
	}
	if b.Search != nil {
		if err := b.Search.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "search"}}); err != nil {
			return err
		}
	}
	if b.Request != nil {
		if err := b.Request.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "request"}}); err != nil {
			return err
		}
	}
	if b.Response != nil {
		if err := b.Response.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "response"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes BundleEntry from FHIR-conformant XML.
func (r *BundleEntry) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "link":
				var v BundleLink
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Link = append(r.Link, v)
			case "fullUrl":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.FullUrl = v
			case "search":
				var v BundleEntrySearch
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Search = &v
			case "request":
				var v BundleEntryRequest
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Request = &v
			case "response":
				var v BundleEntryResponse
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Response = &v
			default:
				if IsKnownResourceType(t.Name.Local) {
					res, err := xmlDecodeInlineResource(d, t)
					if err != nil {
						return err
					}
					r.Resource = res
				} else {
					if err := d.Skip(); err != nil {
						return err
					}
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// BundleEntryRequest represents the Bundle.entry.request backbone element.
// Additional execution information (transaction/batch/history)
type BundleEntryRequest struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// GET | HEAD | POST | PUT | DELETE | PATCH
	Method *HTTPVerb `json:"method,omitempty"`
	// URL for HTTP equivalent of this entry
	Url *string `json:"url,omitempty"`
	// For managing cache currency
	IfNoneMatch *string `json:"ifNoneMatch,omitempty"`
	// For managing cache currency
	IfModifiedSince *string `json:"ifModifiedSince,omitempty"`
	// For managing update contention
	IfMatch *string `json:"ifMatch,omitempty"`
	// For conditional creates
	IfNoneExist *string `json:"ifNoneExist,omitempty"`
}

// MarshalXML serializes BundleEntryRequest to FHIR-conformant XML.
func (b BundleEntryRequest) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Bundle.entry.request"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveCode(e, "method", b.Method, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "url", b.Url, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "ifNoneMatch", b.IfNoneMatch, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "ifModifiedSince", b.IfModifiedSince, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "ifMatch", b.IfMatch, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "ifNoneExist", b.IfNoneExist, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes BundleEntryRequest from FHIR-conformant XML.
func (r *BundleEntryRequest) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "method":
				v, _, err := xmlDecodePrimitiveCode[HTTPVerb](d, t)
				if err != nil {
					return err
				}
				r.Method = v
			case "url":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Url = v
			case "ifNoneMatch":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.IfNoneMatch = v
			case "ifModifiedSince":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.IfModifiedSince = v
			case "ifMatch":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.IfMatch = v
			case "ifNoneExist":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.IfNoneExist = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// BundleEntryResponse represents the Bundle.entry.response backbone element.
// Results of execution (transaction/batch/history)
type BundleEntryResponse struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Status response code (text optional)
	Status *string `json:"status,omitempty"`
	// The location (if the operation returns a location)
	Location *string `json:"location,omitempty"`
	// The Etag for the resource (if relevant)
	Etag *string `json:"etag,omitempty"`
	// Server's date time modified
	LastModified *string `json:"lastModified,omitempty"`
	// OperationOutcome with hints and warnings (for batch/transaction)
	Outcome Resource `json:"outcome,omitempty"`
}

// UnmarshalJSON handles deserialization of polymorphic resource field.
func (b *BundleEntryResponse) UnmarshalJSON(data []byte) error {
	// Use an alias to avoid infinite recursion
	type Alias BundleEntryResponse
	aux := &struct {
		Outcome json.RawMessage `json:"outcome,omitempty"`
		*Alias
	}{
		Alias: (*Alias)(b),
	}

	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}

	// Unmarshal the resource field using the dispatcher
	if len(aux.Outcome) > 0 {
		resource, err := UnmarshalResource(aux.Outcome)
		if err != nil {
			return fmt.Errorf("failed to unmarshal outcome: %w", err)
		}
		b.Outcome = resource
	}

	return nil
}

// MarshalXML serializes BundleEntryResponse to FHIR-conformant XML.
func (b BundleEntryResponse) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Bundle.entry.response"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "status", b.Status, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "location", b.Location, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "etag", b.Etag, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "lastModified", b.LastModified, nil); err != nil {
		return err
	}
	if b.Outcome != nil {
		if err := xmlEncodeInlineResource(e, b.Outcome); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes BundleEntryResponse from FHIR-conformant XML.
func (r *BundleEntryResponse) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "status":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Status = v
			case "location":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Location = v
			case "etag":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Etag = v
			case "lastModified":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.LastModified = v
			default:
				if IsKnownResourceType(t.Name.Local) {
					res, err := xmlDecodeInlineResource(d, t)
					if err != nil {
						return err
					}
					r.Outcome = res
				} else {
					if err := d.Skip(); err != nil {
						return err
					}
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// BundleEntrySearch represents the Bundle.entry.search backbone element.
// Search related information
type BundleEntrySearch struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// match | include | outcome - why this is in the result set
	Mode *SearchEntryMode `json:"mode,omitempty"`
	// Search ranking (between 0 and 1)
	Score *Decimal `json:"score,omitempty"`
}

// MarshalXML serializes BundleEntrySearch to FHIR-conformant XML.
func (b BundleEntrySearch) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Bundle.entry.search"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveCode(e, "mode", b.Mode, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveDecimal(e, "score", b.Score, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes BundleEntrySearch from FHIR-conformant XML.
func (r *BundleEntrySearch) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "mode":
				v, _, err := xmlDecodePrimitiveCode[SearchEntryMode](d, t)
				if err != nil {
					return err
				}
				r.Mode = v
			case "score":
				v, _, err := xmlDecodePrimitiveDecimal(d, t)
				if err != nil {
					return err
				}
				r.Score = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// BundleLink represents the Bundle.link backbone element.
// Links related to this Bundle
type BundleLink struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// See http://www.iana.org/assignments/link-relations/link-relations.xhtml#link-relations-1
	Relation *string `json:"relation,omitempty"`
	// Reference details for the link
	Url *string `json:"url,omitempty"`
}

// MarshalXML serializes BundleLink to FHIR-conformant XML.
func (b BundleLink) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Bundle.link"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "relation", b.Relation, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "url", b.Url, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes BundleLink from FHIR-conformant XML.
func (r *BundleLink) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "relation":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Relation = v
			case "url":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Url = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// =============================================================================
// Bundle - Fluent Builder
// =============================================================================

// BundleBuilder provides a fluent API for constructing Bundle resources.
type BundleBuilder struct {
	bundle *Bundle
}

// NewBundleBuilder creates a new BundleBuilder.
func NewBundleBuilder() *BundleBuilder {
	return &BundleBuilder{
		bundle: &Bundle{},
	}
}

// Build returns the constructed Bundle resource.
func (b *BundleBuilder) Build() *Bundle {
	return b.bundle
}

// SetId sets the Id field.
func (b *BundleBuilder) SetId(v string) *BundleBuilder {
	b.bundle.Id = &v
	return b
}

// SetMeta sets the Meta field.
func (b *BundleBuilder) SetMeta(v Meta) *BundleBuilder {
	b.bundle.Meta = &v
	return b
}

// SetImplicitRules sets the ImplicitRules field.
func (b *BundleBuilder) SetImplicitRules(v string) *BundleBuilder {
	b.bundle.ImplicitRules = &v
	return b
}

// SetLanguage sets the Language field.
func (b *BundleBuilder) SetLanguage(v string) *BundleBuilder {
	b.bundle.Language = &v
	return b
}

// SetIdentifier sets the Identifier field.
func (b *BundleBuilder) SetIdentifier(v Identifier) *BundleBuilder {
	b.bundle.Identifier = &v
	return b
}

// SetType sets the Type field.
func (b *BundleBuilder) SetType(v BundleType) *BundleBuilder {
	b.bundle.Type = &v
	return b
}

// SetTimestamp sets the Timestamp field.
func (b *BundleBuilder) SetTimestamp(v string) *BundleBuilder {
	b.bundle.Timestamp = &v
	return b
}

// SetTotal sets the Total field.
func (b *BundleBuilder) SetTotal(v uint32) *BundleBuilder {
	b.bundle.Total = &v
	return b
}

// AddLink adds a Link element.
func (b *BundleBuilder) AddLink(v BundleLink) *BundleBuilder {
	b.bundle.Link = append(b.bundle.Link, v)
	return b
}

// AddEntry adds a Entry element.
func (b *BundleBuilder) AddEntry(v BundleEntry) *BundleBuilder {
	b.bundle.Entry = append(b.bundle.Entry, v)
	return b
}

// SetSignature sets the Signature field.
func (b *BundleBuilder) SetSignature(v Signature) *BundleBuilder {
	b.bundle.Signature = &v
	return b
}

// =============================================================================
// Bundle - Functional Options
// =============================================================================

// BundleOption is a functional option for configuring a Bundle.
type BundleOption func(*Bundle)

// NewBundle creates a new Bundle with the given options.
func NewBundle(opts ...BundleOption) *Bundle {
	r := &Bundle{}
	for _, opt := range opts {
		opt(r)
	}
	return r
}

// WithBundleId sets the Id field.
func WithBundleId(v string) BundleOption {
	return func(r *Bundle) {
		r.Id = &v
	}
}

// WithBundleMeta sets the Meta field.
func WithBundleMeta(v Meta) BundleOption {
	return func(r *Bundle) {
		r.Meta = &v
	}
}

// WithBundleImplicitRules sets the ImplicitRules field.
func WithBundleImplicitRules(v string) BundleOption {
	return func(r *Bundle) {
		r.ImplicitRules = &v
	}
}

// WithBundleLanguage sets the Language field.
func WithBundleLanguage(v string) BundleOption {
	return func(r *Bundle) {
		r.Language = &v
	}
}

// WithBundleIdentifier sets the Identifier field.
func WithBundleIdentifier(v Identifier) BundleOption {
	return func(r *Bundle) {
		r.Identifier = &v
	}
}

// WithBundleType sets the Type field.
func WithBundleType(v BundleType) BundleOption {
	return func(r *Bundle) {
		r.Type = &v
	}
}

// WithBundleTimestamp sets the Timestamp field.
func WithBundleTimestamp(v string) BundleOption {
	return func(r *Bundle) {
		r.Timestamp = &v
	}
}

// WithBundleTotal sets the Total field.
func WithBundleTotal(v uint32) BundleOption {
	return func(r *Bundle) {
		r.Total = &v
	}
}

// WithBundleLink adds a Link to the Bundle.
func WithBundleLink(v BundleLink) BundleOption {
	return func(r *Bundle) {
		r.Link = append(r.Link, v)
	}
}

// WithBundleEntry adds a Entry to the Bundle.
func WithBundleEntry(v BundleEntry) BundleOption {
	return func(r *Bundle) {
		r.Entry = append(r.Entry, v)
	}
}

// WithBundleSignature sets the Signature field.
func WithBundleSignature(v Signature) BundleOption {
	return func(r *Bundle) {
		r.Signature = &v
	}
}
