// Code generated by gofhir. DO NOT EDIT.
// Source: FHIR StructureDefinitions (consolidated datatypes)
// Package: r4b

package r4b

import (
	"encoding/xml"
)

// =============================================================================
// Datatype Struct Definitions
// =============================================================================

// Element represents FHIR Element.
type Element struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
}

// BackboneElement represents FHIR BackboneElement.
type BackboneElement struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// Address represents FHIR Address.
type Address struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// home | work | temp | old | billing - purpose of this address
	Use *AddressUse `json:"use,omitempty"`
	// Extension for Use
	UseExt *Element `json:"_use,omitempty"`
	// postal | physical | both
	Type *AddressType `json:"type,omitempty"`
	// Extension for Type
	TypeExt *Element `json:"_type,omitempty"`
	// Text representation of the address
	Text *string `json:"text,omitempty"`
	// Extension for Text
	TextExt *Element `json:"_text,omitempty"`
	// Street name, number, direction & P.O. Box etc.
	Line []string `json:"line,omitempty"`
	// Extension for Line
	LineExt []Element `json:"_line,omitempty"`
	// Name of city, town etc.
	City *string `json:"city,omitempty"`
	// Extension for City
	CityExt *Element `json:"_city,omitempty"`
	// District name (aka county)
	District *string `json:"district,omitempty"`
	// Extension for District
	DistrictExt *Element `json:"_district,omitempty"`
	// Sub-unit of country (abbreviations ok)
	State *string `json:"state,omitempty"`
	// Extension for State
	StateExt *Element `json:"_state,omitempty"`
	// Postal code for area
	PostalCode *string `json:"postalCode,omitempty"`
	// Extension for PostalCode
	PostalCodeExt *Element `json:"_postalCode,omitempty"`
	// Country (e.g. can be ISO 3166 2 or 3 letter code)
	Country *string `json:"country,omitempty"`
	// Extension for Country
	CountryExt *Element `json:"_country,omitempty"`
	// Time period when address was/is in use
	Period *Period `json:"period,omitempty"`
}

// Age represents FHIR Age.
type Age struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Numerical value (with implicit precision)
	Value *Decimal `json:"value,omitempty"`
	// Extension for Value
	ValueExt *Element `json:"_value,omitempty"`
	// < | <= | >= | > - how to understand the value
	Comparator *QuantityComparator `json:"comparator,omitempty"`
	// Extension for Comparator
	ComparatorExt *Element `json:"_comparator,omitempty"`
	// Unit representation
	Unit *string `json:"unit,omitempty"`
	// Extension for Unit
	UnitExt *Element `json:"_unit,omitempty"`
	// System that defines coded unit form
	System *string `json:"system,omitempty"`
	// Extension for System
	SystemExt *Element `json:"_system,omitempty"`
	// Coded form of the unit
	Code *string `json:"code,omitempty"`
	// Extension for Code
	CodeExt *Element `json:"_code,omitempty"`
}

// Annotation represents FHIR Annotation.
type Annotation struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Individual responsible for the annotation
	AuthorReference *Reference `json:"authorReference,omitempty"`
	// Individual responsible for the annotation
	AuthorString *string `json:"authorString,omitempty"`
	// Extension for AuthorString
	AuthorStringExt *Element `json:"_authorString,omitempty"`
	// When the annotation was made
	Time *string `json:"time,omitempty"`
	// Extension for Time
	TimeExt *Element `json:"_time,omitempty"`
	// The annotation  - text content (as markdown)
	Text *string `json:"text,omitempty"`
	// Extension for Text
	TextExt *Element `json:"_text,omitempty"`
}

// Attachment represents FHIR Attachment.
type Attachment struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Mime type of the content, with charset etc.
	ContentType *string `json:"contentType,omitempty"`
	// Extension for ContentType
	ContentTypeExt *Element `json:"_contentType,omitempty"`
	// Human language of the content (BCP-47)
	Language *string `json:"language,omitempty"`
	// Extension for Language
	LanguageExt *Element `json:"_language,omitempty"`
	// Data inline, base64ed
	Data *string `json:"data,omitempty"`
	// Extension for Data
	DataExt *Element `json:"_data,omitempty"`
	// Uri where the data can be found
	Url *string `json:"url,omitempty"`
	// Extension for Url
	UrlExt *Element `json:"_url,omitempty"`
	// Number of bytes of content (if url provided)
	Size *uint32 `json:"size,omitempty"`
	// Extension for Size
	SizeExt *Element `json:"_size,omitempty"`
	// Hash of the data (sha-1, base64ed)
	Hash *string `json:"hash,omitempty"`
	// Extension for Hash
	HashExt *Element `json:"_hash,omitempty"`
	// Label to display in place of the data
	Title *string `json:"title,omitempty"`
	// Extension for Title
	TitleExt *Element `json:"_title,omitempty"`
	// Date attachment was first created
	Creation *string `json:"creation,omitempty"`
	// Extension for Creation
	CreationExt *Element `json:"_creation,omitempty"`
}

// CodeableConcept represents FHIR CodeableConcept.
type CodeableConcept struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Code defined by a terminology system
	Coding []Coding `json:"coding,omitempty"`
	// Plain text representation of the concept
	Text *string `json:"text,omitempty"`
	// Extension for Text
	TextExt *Element `json:"_text,omitempty"`
}

// CodeableReference represents FHIR CodeableReference.
type CodeableReference struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Reference to a concept (by class)
	Concept *CodeableConcept `json:"concept,omitempty"`
	// Reference to a resource (by instance)
	Reference *Reference `json:"reference,omitempty"`
}

// Coding represents FHIR Coding.
type Coding struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Identity of the terminology system
	System *string `json:"system,omitempty"`
	// Extension for System
	SystemExt *Element `json:"_system,omitempty"`
	// Version of the system - if relevant
	Version *string `json:"version,omitempty"`
	// Extension for Version
	VersionExt *Element `json:"_version,omitempty"`
	// Symbol in syntax defined by the system
	Code *string `json:"code,omitempty"`
	// Extension for Code
	CodeExt *Element `json:"_code,omitempty"`
	// Representation defined by the system
	Display *string `json:"display,omitempty"`
	// Extension for Display
	DisplayExt *Element `json:"_display,omitempty"`
	// If this coding was chosen directly by the user
	UserSelected *bool `json:"userSelected,omitempty"`
	// Extension for UserSelected
	UserSelectedExt *Element `json:"_userSelected,omitempty"`
}

// ContactDetail represents FHIR ContactDetail.
type ContactDetail struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Name of an individual to contact
	Name *string `json:"name,omitempty"`
	// Extension for Name
	NameExt *Element `json:"_name,omitempty"`
	// Contact details for individual or organization
	Telecom []ContactPoint `json:"telecom,omitempty"`
}

// ContactPoint represents FHIR ContactPoint.
type ContactPoint struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// phone | fax | email | pager | url | sms | other
	System *ContactPointSystem `json:"system,omitempty"`
	// Extension for System
	SystemExt *Element `json:"_system,omitempty"`
	// The actual contact point details
	Value *string `json:"value,omitempty"`
	// Extension for Value
	ValueExt *Element `json:"_value,omitempty"`
	// home | work | temp | old | mobile - purpose of this contact point
	Use *ContactPointUse `json:"use,omitempty"`
	// Extension for Use
	UseExt *Element `json:"_use,omitempty"`
	// Specify preferred order of use (1 = highest)
	Rank *uint32 `json:"rank,omitempty"`
	// Extension for Rank
	RankExt *Element `json:"_rank,omitempty"`
	// Time period when the contact point was/is in use
	Period *Period `json:"period,omitempty"`
}

// Contributor represents FHIR Contributor.
type Contributor struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// author | editor | reviewer | endorser
	Type *ContributorType `json:"type,omitempty"`
	// Extension for Type
	TypeExt *Element `json:"_type,omitempty"`
	// Who contributed the content
	Name *string `json:"name,omitempty"`
	// Extension for Name
	NameExt *Element `json:"_name,omitempty"`
	// Contact details of the contributor
	Contact []ContactDetail `json:"contact,omitempty"`
}

// Count represents FHIR Count.
type Count struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Numerical value (with implicit precision)
	Value *Decimal `json:"value,omitempty"`
	// Extension for Value
	ValueExt *Element `json:"_value,omitempty"`
	// < | <= | >= | > - how to understand the value
	Comparator *QuantityComparator `json:"comparator,omitempty"`
	// Extension for Comparator
	ComparatorExt *Element `json:"_comparator,omitempty"`
	// Unit representation
	Unit *string `json:"unit,omitempty"`
	// Extension for Unit
	UnitExt *Element `json:"_unit,omitempty"`
	// System that defines coded unit form
	System *string `json:"system,omitempty"`
	// Extension for System
	SystemExt *Element `json:"_system,omitempty"`
	// Coded form of the unit
	Code *string `json:"code,omitempty"`
	// Extension for Code
	CodeExt *Element `json:"_code,omitempty"`
}

// DataRequirement represents FHIR DataRequirement.
type DataRequirement struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// The type of the required data
	Type *string `json:"type,omitempty"`
	// Extension for Type
	TypeExt *Element `json:"_type,omitempty"`
	// The profile of the required data
	Profile []string `json:"profile,omitempty"`
	// Extension for Profile
	ProfileExt []Element `json:"_profile,omitempty"`
	// E.g. Patient, Practitioner, RelatedPerson, Organization, Location, Device
	SubjectCodeableConcept *CodeableConcept `json:"subjectCodeableConcept,omitempty"`
	// E.g. Patient, Practitioner, RelatedPerson, Organization, Location, Device
	SubjectReference *Reference `json:"subjectReference,omitempty"`
	// Indicates specific structure elements that are referenced by the knowledge module
	MustSupport []string `json:"mustSupport,omitempty"`
	// Extension for MustSupport
	MustSupportExt []Element `json:"_mustSupport,omitempty"`
	// What codes are expected
	CodeFilter []DataRequirementCodeFilter `json:"codeFilter,omitempty"`
	// What dates/date ranges are expected
	DateFilter []DataRequirementDateFilter `json:"dateFilter,omitempty"`
	// Number of results
	Limit *uint32 `json:"limit,omitempty"`
	// Extension for Limit
	LimitExt *Element `json:"_limit,omitempty"`
	// Order of the results
	Sort []DataRequirementSort `json:"sort,omitempty"`
}

// Distance represents FHIR Distance.
type Distance struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Numerical value (with implicit precision)
	Value *Decimal `json:"value,omitempty"`
	// Extension for Value
	ValueExt *Element `json:"_value,omitempty"`
	// < | <= | >= | > - how to understand the value
	Comparator *QuantityComparator `json:"comparator,omitempty"`
	// Extension for Comparator
	ComparatorExt *Element `json:"_comparator,omitempty"`
	// Unit representation
	Unit *string `json:"unit,omitempty"`
	// Extension for Unit
	UnitExt *Element `json:"_unit,omitempty"`
	// System that defines coded unit form
	System *string `json:"system,omitempty"`
	// Extension for System
	SystemExt *Element `json:"_system,omitempty"`
	// Coded form of the unit
	Code *string `json:"code,omitempty"`
	// Extension for Code
	CodeExt *Element `json:"_code,omitempty"`
}

// Dosage represents FHIR Dosage.
type Dosage struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The order of the dosage instructions
	Sequence *int `json:"sequence,omitempty"`
	// Extension for Sequence
	SequenceExt *Element `json:"_sequence,omitempty"`
	// Free text dosage instructions e.g. SIG
	Text *string `json:"text,omitempty"`
	// Extension for Text
	TextExt *Element `json:"_text,omitempty"`
	// Supplemental instruction or warnings to the patient - e.g. "with meals", "may cause drowsiness"
	AdditionalInstruction []CodeableConcept `json:"additionalInstruction,omitempty"`
	// Patient or consumer oriented instructions
	PatientInstruction *string `json:"patientInstruction,omitempty"`
	// Extension for PatientInstruction
	PatientInstructionExt *Element `json:"_patientInstruction,omitempty"`
	// When medication should be administered
	Timing *Timing `json:"timing,omitempty"`
	// Take "as needed" (for x)
	AsNeededBoolean *bool `json:"asNeededBoolean,omitempty"`
	// Extension for AsNeededBoolean
	AsNeededBooleanExt *Element `json:"_asNeededBoolean,omitempty"`
	// Take "as needed" (for x)
	AsNeededCodeableConcept *CodeableConcept `json:"asNeededCodeableConcept,omitempty"`
	// Body site to administer to
	Site *CodeableConcept `json:"site,omitempty"`
	// How drug should enter body
	Route *CodeableConcept `json:"route,omitempty"`
	// Technique for administering medication
	Method *CodeableConcept `json:"method,omitempty"`
	// Amount of medication administered
	DoseAndRate []DosageDoseAndRate `json:"doseAndRate,omitempty"`
	// Upper limit on medication per unit of time
	MaxDosePerPeriod *Ratio `json:"maxDosePerPeriod,omitempty"`
	// Upper limit on medication per administration
	MaxDosePerAdministration *Quantity `json:"maxDosePerAdministration,omitempty"`
	// Upper limit on medication per lifetime of the patient
	MaxDosePerLifetime *Quantity `json:"maxDosePerLifetime,omitempty"`
}

// Duration represents FHIR Duration.
type Duration struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Numerical value (with implicit precision)
	Value *Decimal `json:"value,omitempty"`
	// Extension for Value
	ValueExt *Element `json:"_value,omitempty"`
	// < | <= | >= | > - how to understand the value
	Comparator *QuantityComparator `json:"comparator,omitempty"`
	// Extension for Comparator
	ComparatorExt *Element `json:"_comparator,omitempty"`
	// Unit representation
	Unit *string `json:"unit,omitempty"`
	// Extension for Unit
	UnitExt *Element `json:"_unit,omitempty"`
	// System that defines coded unit form
	System *string `json:"system,omitempty"`
	// Extension for System
	SystemExt *Element `json:"_system,omitempty"`
	// Coded form of the unit
	Code *string `json:"code,omitempty"`
	// Extension for Code
	CodeExt *Element `json:"_code,omitempty"`
}

// ElementDefinition represents FHIR ElementDefinition.
type ElementDefinition struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Path of the element in the hierarchy of elements
	Path *string `json:"path,omitempty"`
	// Extension for Path
	PathExt *Element `json:"_path,omitempty"`
	// xmlAttr | xmlText | typeAttr | cdaText | xhtml
	Representation []PropertyRepresentation `json:"representation,omitempty"`
	// Extension for Representation
	RepresentationExt []Element `json:"_representation,omitempty"`
	// Name for this particular element (in a set of slices)
	SliceName *string `json:"sliceName,omitempty"`
	// Extension for SliceName
	SliceNameExt *Element `json:"_sliceName,omitempty"`
	// If this slice definition constrains an inherited slice definition (or not)
	SliceIsConstraining *bool `json:"sliceIsConstraining,omitempty"`
	// Extension for SliceIsConstraining
	SliceIsConstrainingExt *Element `json:"_sliceIsConstraining,omitempty"`
	// Name for element to display with or prompt for element
	Label *string `json:"label,omitempty"`
	// Extension for Label
	LabelExt *Element `json:"_label,omitempty"`
	// Corresponding codes in terminologies
	Code []Coding `json:"code,omitempty"`
	// This element is sliced - slices follow
	Slicing *ElementDefinitionSlicing `json:"slicing,omitempty"`
	// Concise definition for space-constrained presentation
	Short *string `json:"short,omitempty"`
	// Extension for Short
	ShortExt *Element `json:"_short,omitempty"`
	// Full formal definition as narrative text
	Definition *string `json:"definition,omitempty"`
	// Extension for Definition
	DefinitionExt *Element `json:"_definition,omitempty"`
	// Comments about the use of this element
	Comment *string `json:"comment,omitempty"`
	// Extension for Comment
	CommentExt *Element `json:"_comment,omitempty"`
	// Why this resource has been created
	Requirements *string `json:"requirements,omitempty"`
	// Extension for Requirements
	RequirementsExt *Element `json:"_requirements,omitempty"`
	// Other names
	Alias []string `json:"alias,omitempty"`
	// Extension for Alias
	AliasExt []Element `json:"_alias,omitempty"`
	// Minimum Cardinality
	Min *uint32 `json:"min,omitempty"`
	// Extension for Min
	MinExt *Element `json:"_min,omitempty"`
	// Maximum Cardinality (a number or *)
	Max *string `json:"max,omitempty"`
	// Extension for Max
	MaxExt *Element `json:"_max,omitempty"`
	// Base definition information for tools
	Base *ElementDefinitionBase `json:"base,omitempty"`
	// Reference to definition of content for the element
	ContentReference *string `json:"contentReference,omitempty"`
	// Extension for ContentReference
	ContentReferenceExt *Element `json:"_contentReference,omitempty"`
	// Data type and Profile for this element
	Type []ElementDefinitionType `json:"type,omitempty"`
	// Specified value if missing from instance
	DefaultValueBase64Binary *string `json:"defaultValueBase64Binary,omitempty"`
	// Extension for DefaultValueBase64Binary
	DefaultValueBase64BinaryExt *Element `json:"_defaultValueBase64Binary,omitempty"`
	// Specified value if missing from instance
	DefaultValueBoolean *bool `json:"defaultValueBoolean,omitempty"`
	// Extension for DefaultValueBoolean
	DefaultValueBooleanExt *Element `json:"_defaultValueBoolean,omitempty"`
	// Specified value if missing from instance
	DefaultValueCanonical *string `json:"defaultValueCanonical,omitempty"`
	// Extension for DefaultValueCanonical
	DefaultValueCanonicalExt *Element `json:"_defaultValueCanonical,omitempty"`
	// Specified value if missing from instance
	DefaultValueCode *string `json:"defaultValueCode,omitempty"`
	// Extension for DefaultValueCode
	DefaultValueCodeExt *Element `json:"_defaultValueCode,omitempty"`
	// Specified value if missing from instance
	DefaultValueDate *string `json:"defaultValueDate,omitempty"`
	// Extension for DefaultValueDate
	DefaultValueDateExt *Element `json:"_defaultValueDate,omitempty"`
	// Specified value if missing from instance
	DefaultValueDateTime *string `json:"defaultValueDateTime,omitempty"`
	// Extension for DefaultValueDateTime
	DefaultValueDateTimeExt *Element `json:"_defaultValueDateTime,omitempty"`
	// Specified value if missing from instance
	DefaultValueDecimal *Decimal `json:"defaultValueDecimal,omitempty"`
	// Extension for DefaultValueDecimal
	DefaultValueDecimalExt *Element `json:"_defaultValueDecimal,omitempty"`
	// Specified value if missing from instance
	DefaultValueId *string `json:"defaultValueId,omitempty"`
	// Extension for DefaultValueId
	DefaultValueIdExt *Element `json:"_defaultValueId,omitempty"`
	// Specified value if missing from instance
	DefaultValueInstant *string `json:"defaultValueInstant,omitempty"`
	// Extension for DefaultValueInstant
	DefaultValueInstantExt *Element `json:"_defaultValueInstant,omitempty"`
	// Specified value if missing from instance
	DefaultValueInteger *int `json:"defaultValueInteger,omitempty"`
	// Extension for DefaultValueInteger
	DefaultValueIntegerExt *Element `json:"_defaultValueInteger,omitempty"`
	// Specified value if missing from instance
	DefaultValueMarkdown *string `json:"defaultValueMarkdown,omitempty"`
	// Extension for DefaultValueMarkdown
	DefaultValueMarkdownExt *Element `json:"_defaultValueMarkdown,omitempty"`
	// Specified value if missing from instance
	DefaultValueOid *string `json:"defaultValueOid,omitempty"`
	// Extension for DefaultValueOid
	DefaultValueOidExt *Element `json:"_defaultValueOid,omitempty"`
	// Specified value if missing from instance
	DefaultValuePositiveInt *uint32 `json:"defaultValuePositiveInt,omitempty"`
	// Extension for DefaultValuePositiveInt
	DefaultValuePositiveIntExt *Element `json:"_defaultValuePositiveInt,omitempty"`
	// Specified value if missing from instance
	DefaultValueString *string `json:"defaultValueString,omitempty"`
	// Extension for DefaultValueString
	DefaultValueStringExt *Element `json:"_defaultValueString,omitempty"`
	// Specified value if missing from instance
	DefaultValueTime *string `json:"defaultValueTime,omitempty"`
	// Extension for DefaultValueTime
	DefaultValueTimeExt *Element `json:"_defaultValueTime,omitempty"`
	// Specified value if missing from instance
	DefaultValueUnsignedInt *uint32 `json:"defaultValueUnsignedInt,omitempty"`
	// Extension for DefaultValueUnsignedInt
	DefaultValueUnsignedIntExt *Element `json:"_defaultValueUnsignedInt,omitempty"`
	// Specified value if missing from instance
	DefaultValueUri *string `json:"defaultValueUri,omitempty"`
	// Extension for DefaultValueUri
	DefaultValueUriExt *Element `json:"_defaultValueUri,omitempty"`
	// Specified value if missing from instance
	DefaultValueUrl *string `json:"defaultValueUrl,omitempty"`
	// Extension for DefaultValueUrl
	DefaultValueUrlExt *Element `json:"_defaultValueUrl,omitempty"`
	// Specified value if missing from instance
	DefaultValueUuid *string `json:"defaultValueUuid,omitempty"`
	// Extension for DefaultValueUuid
	DefaultValueUuidExt *Element `json:"_defaultValueUuid,omitempty"`
	// Specified value if missing from instance
	DefaultValueAddress *Address `json:"defaultValueAddress,omitempty"`
	// Specified value if missing from instance
	DefaultValueAge *Age `json:"defaultValueAge,omitempty"`
	// Specified value if missing from instance
	DefaultValueAnnotation *Annotation `json:"defaultValueAnnotation,omitempty"`
	// Specified value if missing from instance
	DefaultValueAttachment *Attachment `json:"defaultValueAttachment,omitempty"`
	// Specified value if missing from instance
	DefaultValueCodeableConcept *CodeableConcept `json:"defaultValueCodeableConcept,omitempty"`
	// Specified value if missing from instance
	DefaultValueCodeableReference *CodeableReference `json:"defaultValueCodeableReference,omitempty"`
	// Specified value if missing from instance
	DefaultValueCoding *Coding `json:"defaultValueCoding,omitempty"`
	// Specified value if missing from instance
	DefaultValueContactPoint *ContactPoint `json:"defaultValueContactPoint,omitempty"`
	// Specified value if missing from instance
	DefaultValueCount *Count `json:"defaultValueCount,omitempty"`
	// Specified value if missing from instance
	DefaultValueDistance *Distance `json:"defaultValueDistance,omitempty"`
	// Specified value if missing from instance
	DefaultValueDuration *Duration `json:"defaultValueDuration,omitempty"`
	// Specified value if missing from instance
	DefaultValueHumanName *HumanName `json:"defaultValueHumanName,omitempty"`
	// Specified value if missing from instance
	DefaultValueIdentifier *Identifier `json:"defaultValueIdentifier,omitempty"`
	// Specified value if missing from instance
	DefaultValueMoney *Money `json:"defaultValueMoney,omitempty"`
	// Specified value if missing from instance
	DefaultValuePeriod *Period `json:"defaultValuePeriod,omitempty"`
	// Specified value if missing from instance
	DefaultValueQuantity *Quantity `json:"defaultValueQuantity,omitempty"`
	// Specified value if missing from instance
	DefaultValueRange *Range `json:"defaultValueRange,omitempty"`
	// Specified value if missing from instance
	DefaultValueRatio *Ratio `json:"defaultValueRatio,omitempty"`
	// Specified value if missing from instance
	DefaultValueRatioRange *RatioRange `json:"defaultValueRatioRange,omitempty"`
	// Specified value if missing from instance
	DefaultValueReference *Reference `json:"defaultValueReference,omitempty"`
	// Specified value if missing from instance
	DefaultValueSampledData *SampledData `json:"defaultValueSampledData,omitempty"`
	// Specified value if missing from instance
	DefaultValueSignature *Signature `json:"defaultValueSignature,omitempty"`
	// Specified value if missing from instance
	DefaultValueTiming *Timing `json:"defaultValueTiming,omitempty"`
	// Specified value if missing from instance
	DefaultValueContactDetail *ContactDetail `json:"defaultValueContactDetail,omitempty"`
	// Specified value if missing from instance
	DefaultValueContributor *Contributor `json:"defaultValueContributor,omitempty"`
	// Specified value if missing from instance
	DefaultValueDataRequirement *DataRequirement `json:"defaultValueDataRequirement,omitempty"`
	// Specified value if missing from instance
	DefaultValueExpression *Expression `json:"defaultValueExpression,omitempty"`
	// Specified value if missing from instance
	DefaultValueParameterDefinition *ParameterDefinition `json:"defaultValueParameterDefinition,omitempty"`
	// Specified value if missing from instance
	DefaultValueRelatedArtifact *RelatedArtifact `json:"defaultValueRelatedArtifact,omitempty"`
	// Specified value if missing from instance
	DefaultValueTriggerDefinition *TriggerDefinition `json:"defaultValueTriggerDefinition,omitempty"`
	// Specified value if missing from instance
	DefaultValueUsageContext *UsageContext `json:"defaultValueUsageContext,omitempty"`
	// Specified value if missing from instance
	DefaultValueDosage *Dosage `json:"defaultValueDosage,omitempty"`
	// Implicit meaning when this element is missing
	MeaningWhenMissing *string `json:"meaningWhenMissing,omitempty"`
	// Extension for MeaningWhenMissing
	MeaningWhenMissingExt *Element `json:"_meaningWhenMissing,omitempty"`
	// What the order of the elements means
	OrderMeaning *string `json:"orderMeaning,omitempty"`
	// Extension for OrderMeaning
	OrderMeaningExt *Element `json:"_orderMeaning,omitempty"`
	// Value must be exactly this
	FixedBase64Binary *string `json:"fixedBase64Binary,omitempty"`
	// Extension for FixedBase64Binary
	FixedBase64BinaryExt *Element `json:"_fixedBase64Binary,omitempty"`
	// Value must be exactly this
	FixedBoolean *bool `json:"fixedBoolean,omitempty"`
	// Extension for FixedBoolean
	FixedBooleanExt *Element `json:"_fixedBoolean,omitempty"`
	// Value must be exactly this
	FixedCanonical *string `json:"fixedCanonical,omitempty"`
	// Extension for FixedCanonical
	FixedCanonicalExt *Element `json:"_fixedCanonical,omitempty"`
	// Value must be exactly this
	FixedCode *string `json:"fixedCode,omitempty"`
	// Extension for FixedCode
	FixedCodeExt *Element `json:"_fixedCode,omitempty"`
	// Value must be exactly this
	FixedDate *string `json:"fixedDate,omitempty"`
	// Extension for FixedDate
	FixedDateExt *Element `json:"_fixedDate,omitempty"`
	// Value must be exactly this
	FixedDateTime *string `json:"fixedDateTime,omitempty"`
	// Extension for FixedDateTime
	FixedDateTimeExt *Element `json:"_fixedDateTime,omitempty"`
	// Value must be exactly this
	FixedDecimal *Decimal `json:"fixedDecimal,omitempty"`
	// Extension for FixedDecimal
	FixedDecimalExt *Element `json:"_fixedDecimal,omitempty"`
	// Value must be exactly this
	FixedId *string `json:"fixedId,omitempty"`
	// Extension for FixedId
	FixedIdExt *Element `json:"_fixedId,omitempty"`
	// Value must be exactly this
	FixedInstant *string `json:"fixedInstant,omitempty"`
	// Extension for FixedInstant
	FixedInstantExt *Element `json:"_fixedInstant,omitempty"`
	// Value must be exactly this
	FixedInteger *int `json:"fixedInteger,omitempty"`
	// Extension for FixedInteger
	FixedIntegerExt *Element `json:"_fixedInteger,omitempty"`
	// Value must be exactly this
	FixedMarkdown *string `json:"fixedMarkdown,omitempty"`
	// Extension for FixedMarkdown
	FixedMarkdownExt *Element `json:"_fixedMarkdown,omitempty"`
	// Value must be exactly this
	FixedOid *string `json:"fixedOid,omitempty"`
	// Extension for FixedOid
	FixedOidExt *Element `json:"_fixedOid,omitempty"`
	// Value must be exactly this
	FixedPositiveInt *uint32 `json:"fixedPositiveInt,omitempty"`
	// Extension for FixedPositiveInt
	FixedPositiveIntExt *Element `json:"_fixedPositiveInt,omitempty"`
	// Value must be exactly this
	FixedString *string `json:"fixedString,omitempty"`
	// Extension for FixedString
	FixedStringExt *Element `json:"_fixedString,omitempty"`
	// Value must be exactly this
	FixedTime *string `json:"fixedTime,omitempty"`
	// Extension for FixedTime
	FixedTimeExt *Element `json:"_fixedTime,omitempty"`
	// Value must be exactly this
	FixedUnsignedInt *uint32 `json:"fixedUnsignedInt,omitempty"`
	// Extension for FixedUnsignedInt
	FixedUnsignedIntExt *Element `json:"_fixedUnsignedInt,omitempty"`
	// Value must be exactly this
	FixedUri *string `json:"fixedUri,omitempty"`
	// Extension for FixedUri
	FixedUriExt *Element `json:"_fixedUri,omitempty"`
	// Value must be exactly this
	FixedUrl *string `json:"fixedUrl,omitempty"`
	// Extension for FixedUrl
	FixedUrlExt *Element `json:"_fixedUrl,omitempty"`
	// Value must be exactly this
	FixedUuid *string `json:"fixedUuid,omitempty"`
	// Extension for FixedUuid
	FixedUuidExt *Element `json:"_fixedUuid,omitempty"`
	// Value must be exactly this
	FixedAddress *Address `json:"fixedAddress,omitempty"`
	// Value must be exactly this
	FixedAge *Age `json:"fixedAge,omitempty"`
	// Value must be exactly this
	FixedAnnotation *Annotation `json:"fixedAnnotation,omitempty"`
	// Value must be exactly this
	FixedAttachment *Attachment `json:"fixedAttachment,omitempty"`
	// Value must be exactly this
	FixedCodeableConcept *CodeableConcept `json:"fixedCodeableConcept,omitempty"`
	// Value must be exactly this
	FixedCodeableReference *CodeableReference `json:"fixedCodeableReference,omitempty"`
	// Value must be exactly this
	FixedCoding *Coding `json:"fixedCoding,omitempty"`
	// Value must be exactly this
	FixedContactPoint *ContactPoint `json:"fixedContactPoint,omitempty"`
	// Value must be exactly this
	FixedCount *Count `json:"fixedCount,omitempty"`
	// Value must be exactly this
	FixedDistance *Distance `json:"fixedDistance,omitempty"`
	// Value must be exactly this
	FixedDuration *Duration `json:"fixedDuration,omitempty"`
	// Value must be exactly this
	FixedHumanName *HumanName `json:"fixedHumanName,omitempty"`
	// Value must be exactly this
	FixedIdentifier *Identifier `json:"fixedIdentifier,omitempty"`
	// Value must be exactly this
	FixedMoney *Money `json:"fixedMoney,omitempty"`
	// Value must be exactly this
	FixedPeriod *Period `json:"fixedPeriod,omitempty"`
	// Value must be exactly this
	FixedQuantity *Quantity `json:"fixedQuantity,omitempty"`
	// Value must be exactly this
	FixedRange *Range `json:"fixedRange,omitempty"`
	// Value must be exactly this
	FixedRatio *Ratio `json:"fixedRatio,omitempty"`
	// Value must be exactly this
	FixedRatioRange *RatioRange `json:"fixedRatioRange,omitempty"`
	// Value must be exactly this
	FixedReference *Reference `json:"fixedReference,omitempty"`
	// Value must be exactly this
	FixedSampledData *SampledData `json:"fixedSampledData,omitempty"`
	// Value must be exactly this
	FixedSignature *Signature `json:"fixedSignature,omitempty"`
	// Value must be exactly this
	FixedTiming *Timing `json:"fixedTiming,omitempty"`
	// Value must be exactly this
	FixedContactDetail *ContactDetail `json:"fixedContactDetail,omitempty"`
	// Value must be exactly this
	FixedContributor *Contributor `json:"fixedContributor,omitempty"`
	// Value must be exactly this
	FixedDataRequirement *DataRequirement `json:"fixedDataRequirement,omitempty"`
	// Value must be exactly this
	FixedExpression *Expression `json:"fixedExpression,omitempty"`
	// Value must be exactly this
	FixedParameterDefinition *ParameterDefinition `json:"fixedParameterDefinition,omitempty"`
	// Value must be exactly this
	FixedRelatedArtifact *RelatedArtifact `json:"fixedRelatedArtifact,omitempty"`
	// Value must be exactly this
	FixedTriggerDefinition *TriggerDefinition `json:"fixedTriggerDefinition,omitempty"`
	// Value must be exactly this
	FixedUsageContext *UsageContext `json:"fixedUsageContext,omitempty"`
	// Value must be exactly this
	FixedDosage *Dosage `json:"fixedDosage,omitempty"`
	// Value must have at least these property values
	PatternBase64Binary *string `json:"patternBase64Binary,omitempty"`
	// Extension for PatternBase64Binary
	PatternBase64BinaryExt *Element `json:"_patternBase64Binary,omitempty"`
	// Value must have at least these property values
	PatternBoolean *bool `json:"patternBoolean,omitempty"`
	// Extension for PatternBoolean
	PatternBooleanExt *Element `json:"_patternBoolean,omitempty"`
	// Value must have at least these property values
	PatternCanonical *string `json:"patternCanonical,omitempty"`
	// Extension for PatternCanonical
	PatternCanonicalExt *Element `json:"_patternCanonical,omitempty"`
	// Value must have at least these property values
	PatternCode *string `json:"patternCode,omitempty"`
	// Extension for PatternCode
	PatternCodeExt *Element `json:"_patternCode,omitempty"`
	// Value must have at least these property values
	PatternDate *string `json:"patternDate,omitempty"`
	// Extension for PatternDate
	PatternDateExt *Element `json:"_patternDate,omitempty"`
	// Value must have at least these property values
	PatternDateTime *string `json:"patternDateTime,omitempty"`
	// Extension for PatternDateTime
	PatternDateTimeExt *Element `json:"_patternDateTime,omitempty"`
	// Value must have at least these property values
	PatternDecimal *Decimal `json:"patternDecimal,omitempty"`
	// Extension for PatternDecimal
	PatternDecimalExt *Element `json:"_patternDecimal,omitempty"`
	// Value must have at least these property values
	PatternId *string `json:"patternId,omitempty"`
	// Extension for PatternId
	PatternIdExt *Element `json:"_patternId,omitempty"`
	// Value must have at least these property values
	PatternInstant *string `json:"patternInstant,omitempty"`
	// Extension for PatternInstant
	PatternInstantExt *Element `json:"_patternInstant,omitempty"`
	// Value must have at least these property values
	PatternInteger *int `json:"patternInteger,omitempty"`
	// Extension for PatternInteger
	PatternIntegerExt *Element `json:"_patternInteger,omitempty"`
	// Value must have at least these property values
	PatternMarkdown *string `json:"patternMarkdown,omitempty"`
	// Extension for PatternMarkdown
	PatternMarkdownExt *Element `json:"_patternMarkdown,omitempty"`
	// Value must have at least these property values
	PatternOid *string `json:"patternOid,omitempty"`
	// Extension for PatternOid
	PatternOidExt *Element `json:"_patternOid,omitempty"`
	// Value must have at least these property values
	PatternPositiveInt *uint32 `json:"patternPositiveInt,omitempty"`
	// Extension for PatternPositiveInt
	PatternPositiveIntExt *Element `json:"_patternPositiveInt,omitempty"`
	// Value must have at least these property values
	PatternString *string `json:"patternString,omitempty"`
	// Extension for PatternString
	PatternStringExt *Element `json:"_patternString,omitempty"`
	// Value must have at least these property values
	PatternTime *string `json:"patternTime,omitempty"`
	// Extension for PatternTime
	PatternTimeExt *Element `json:"_patternTime,omitempty"`
	// Value must have at least these property values
	PatternUnsignedInt *uint32 `json:"patternUnsignedInt,omitempty"`
	// Extension for PatternUnsignedInt
	PatternUnsignedIntExt *Element `json:"_patternUnsignedInt,omitempty"`
	// Value must have at least these property values
	PatternUri *string `json:"patternUri,omitempty"`
	// Extension for PatternUri
	PatternUriExt *Element `json:"_patternUri,omitempty"`
	// Value must have at least these property values
	PatternUrl *string `json:"patternUrl,omitempty"`
	// Extension for PatternUrl
	PatternUrlExt *Element `json:"_patternUrl,omitempty"`
	// Value must have at least these property values
	PatternUuid *string `json:"patternUuid,omitempty"`
	// Extension for PatternUuid
	PatternUuidExt *Element `json:"_patternUuid,omitempty"`
	// Value must have at least these property values
	PatternAddress *Address `json:"patternAddress,omitempty"`
	// Value must have at least these property values
	PatternAge *Age `json:"patternAge,omitempty"`
	// Value must have at least these property values
	PatternAnnotation *Annotation `json:"patternAnnotation,omitempty"`
	// Value must have at least these property values
	PatternAttachment *Attachment `json:"patternAttachment,omitempty"`
	// Value must have at least these property values
	PatternCodeableConcept *CodeableConcept `json:"patternCodeableConcept,omitempty"`
	// Value must have at least these property values
	PatternCodeableReference *CodeableReference `json:"patternCodeableReference,omitempty"`
	// Value must have at least these property values
	PatternCoding *Coding `json:"patternCoding,omitempty"`
	// Value must have at least these property values
	PatternContactPoint *ContactPoint `json:"patternContactPoint,omitempty"`
	// Value must have at least these property values
	PatternCount *Count `json:"patternCount,omitempty"`
	// Value must have at least these property values
	PatternDistance *Distance `json:"patternDistance,omitempty"`
	// Value must have at least these property values
	PatternDuration *Duration `json:"patternDuration,omitempty"`
	// Value must have at least these property values
	PatternHumanName *HumanName `json:"patternHumanName,omitempty"`
	// Value must have at least these property values
	PatternIdentifier *Identifier `json:"patternIdentifier,omitempty"`
	// Value must have at least these property values
	PatternMoney *Money `json:"patternMoney,omitempty"`
	// Value must have at least these property values
	PatternPeriod *Period `json:"patternPeriod,omitempty"`
	// Value must have at least these property values
	PatternQuantity *Quantity `json:"patternQuantity,omitempty"`
	// Value must have at least these property values
	PatternRange *Range `json:"patternRange,omitempty"`
	// Value must have at least these property values
	PatternRatio *Ratio `json:"patternRatio,omitempty"`
	// Value must have at least these property values
	PatternRatioRange *RatioRange `json:"patternRatioRange,omitempty"`
	// Value must have at least these property values
	PatternReference *Reference `json:"patternReference,omitempty"`
	// Value must have at least these property values
	PatternSampledData *SampledData `json:"patternSampledData,omitempty"`
	// Value must have at least these property values
	PatternSignature *Signature `json:"patternSignature,omitempty"`
	// Value must have at least these property values
	PatternTiming *Timing `json:"patternTiming,omitempty"`
	// Value must have at least these property values
	PatternContactDetail *ContactDetail `json:"patternContactDetail,omitempty"`
	// Value must have at least these property values
	PatternContributor *Contributor `json:"patternContributor,omitempty"`
	// Value must have at least these property values
	PatternDataRequirement *DataRequirement `json:"patternDataRequirement,omitempty"`
	// Value must have at least these property values
	PatternExpression *Expression `json:"patternExpression,omitempty"`
	// Value must have at least these property values
	PatternParameterDefinition *ParameterDefinition `json:"patternParameterDefinition,omitempty"`
	// Value must have at least these property values
	PatternRelatedArtifact *RelatedArtifact `json:"patternRelatedArtifact,omitempty"`
	// Value must have at least these property values
	PatternTriggerDefinition *TriggerDefinition `json:"patternTriggerDefinition,omitempty"`
	// Value must have at least these property values
	PatternUsageContext *UsageContext `json:"patternUsageContext,omitempty"`
	// Value must have at least these property values
	PatternDosage *Dosage `json:"patternDosage,omitempty"`
	// Example value (as defined for type)
	Example []ElementDefinitionExample `json:"example,omitempty"`
	// Minimum Allowed Value (for some types)
	MinValueDate *string `json:"minValueDate,omitempty"`
	// Extension for MinValueDate
	MinValueDateExt *Element `json:"_minValueDate,omitempty"`
	// Minimum Allowed Value (for some types)
	MinValueDateTime *string `json:"minValueDateTime,omitempty"`
	// Extension for MinValueDateTime
	MinValueDateTimeExt *Element `json:"_minValueDateTime,omitempty"`
	// Minimum Allowed Value (for some types)
	MinValueInstant *string `json:"minValueInstant,omitempty"`
	// Extension for MinValueInstant
	MinValueInstantExt *Element `json:"_minValueInstant,omitempty"`
	// Minimum Allowed Value (for some types)
	MinValueTime *string `json:"minValueTime,omitempty"`
	// Extension for MinValueTime
	MinValueTimeExt *Element `json:"_minValueTime,omitempty"`
	// Minimum Allowed Value (for some types)
	MinValueDecimal *Decimal `json:"minValueDecimal,omitempty"`
	// Extension for MinValueDecimal
	MinValueDecimalExt *Element `json:"_minValueDecimal,omitempty"`
	// Minimum Allowed Value (for some types)
	MinValueInteger *int `json:"minValueInteger,omitempty"`
	// Extension for MinValueInteger
	MinValueIntegerExt *Element `json:"_minValueInteger,omitempty"`
	// Minimum Allowed Value (for some types)
	MinValuePositiveInt *uint32 `json:"minValuePositiveInt,omitempty"`
	// Extension for MinValuePositiveInt
	MinValuePositiveIntExt *Element `json:"_minValuePositiveInt,omitempty"`
	// Minimum Allowed Value (for some types)
	MinValueUnsignedInt *uint32 `json:"minValueUnsignedInt,omitempty"`
	// Extension for MinValueUnsignedInt
	MinValueUnsignedIntExt *Element `json:"_minValueUnsignedInt,omitempty"`
	// Minimum Allowed Value (for some types)
	MinValueQuantity *Quantity `json:"minValueQuantity,omitempty"`
	// Maximum Allowed Value (for some types)
	MaxValueDate *string `json:"maxValueDate,omitempty"`
	// Extension for MaxValueDate
	MaxValueDateExt *Element `json:"_maxValueDate,omitempty"`
	// Maximum Allowed Value (for some types)
	MaxValueDateTime *string `json:"maxValueDateTime,omitempty"`
	// Extension for MaxValueDateTime
	MaxValueDateTimeExt *Element `json:"_maxValueDateTime,omitempty"`
	// Maximum Allowed Value (for some types)
	MaxValueInstant *string `json:"maxValueInstant,omitempty"`
	// Extension for MaxValueInstant
	MaxValueInstantExt *Element `json:"_maxValueInstant,omitempty"`
	// Maximum Allowed Value (for some types)
	MaxValueTime *string `json:"maxValueTime,omitempty"`
	// Extension for MaxValueTime
	MaxValueTimeExt *Element `json:"_maxValueTime,omitempty"`
	// Maximum Allowed Value (for some types)
	MaxValueDecimal *Decimal `json:"maxValueDecimal,omitempty"`
	// Extension for MaxValueDecimal
	MaxValueDecimalExt *Element `json:"_maxValueDecimal,omitempty"`
	// Maximum Allowed Value (for some types)
	MaxValueInteger *int `json:"maxValueInteger,omitempty"`
	// Extension for MaxValueInteger
	MaxValueIntegerExt *Element `json:"_maxValueInteger,omitempty"`
	// Maximum Allowed Value (for some types)
	MaxValuePositiveInt *uint32 `json:"maxValuePositiveInt,omitempty"`
	// Extension for MaxValuePositiveInt
	MaxValuePositiveIntExt *Element `json:"_maxValuePositiveInt,omitempty"`
	// Maximum Allowed Value (for some types)
	MaxValueUnsignedInt *uint32 `json:"maxValueUnsignedInt,omitempty"`
	// Extension for MaxValueUnsignedInt
	MaxValueUnsignedIntExt *Element `json:"_maxValueUnsignedInt,omitempty"`
	// Maximum Allowed Value (for some types)
	MaxValueQuantity *Quantity `json:"maxValueQuantity,omitempty"`
	// Max length for strings
	MaxLength *int `json:"maxLength,omitempty"`
	// Extension for MaxLength
	MaxLengthExt *Element `json:"_maxLength,omitempty"`
	// Reference to invariant about presence
	Condition []string `json:"condition,omitempty"`
	// Extension for Condition
	ConditionExt []Element `json:"_condition,omitempty"`
	// Condition that must evaluate to true
	Constraint []ElementDefinitionConstraint `json:"constraint,omitempty"`
	// If the element must be supported
	MustSupport *bool `json:"mustSupport,omitempty"`
	// Extension for MustSupport
	MustSupportExt *Element `json:"_mustSupport,omitempty"`
	// If this modifies the meaning of other elements
	IsModifier *bool `json:"isModifier,omitempty"`
	// Extension for IsModifier
	IsModifierExt *Element `json:"_isModifier,omitempty"`
	// Reason that this element is marked as a modifier
	IsModifierReason *string `json:"isModifierReason,omitempty"`
	// Extension for IsModifierReason
	IsModifierReasonExt *Element `json:"_isModifierReason,omitempty"`
	// Include when _summary = true?
	IsSummary *bool `json:"isSummary,omitempty"`
	// Extension for IsSummary
	IsSummaryExt *Element `json:"_isSummary,omitempty"`
	// ValueSet details if this is coded
	Binding *ElementDefinitionBinding `json:"binding,omitempty"`
	// Map element to another set of definitions
	Mapping []ElementDefinitionMapping `json:"mapping,omitempty"`
}

// Expression represents FHIR Expression.
type Expression struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Natural language description of the condition
	Description *string `json:"description,omitempty"`
	// Extension for Description
	DescriptionExt *Element `json:"_description,omitempty"`
	// Short name assigned to expression for reuse
	Name *string `json:"name,omitempty"`
	// Extension for Name
	NameExt *Element `json:"_name,omitempty"`
	// text/cql | text/fhirpath | application/x-fhir-query | text/cql-identifier | text/cql-expression | etc.
	Language *string `json:"language,omitempty"`
	// Extension for Language
	LanguageExt *Element `json:"_language,omitempty"`
	// Expression in specified language
	Expression *string `json:"expression,omitempty"`
	// Extension for Expression
	ExpressionExt *Element `json:"_expression,omitempty"`
	// Where the expression is found
	Reference *string `json:"reference,omitempty"`
	// Extension for Reference
	ReferenceExt *Element `json:"_reference,omitempty"`
}

// Extension represents FHIR Extension.
type Extension struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// identifies the meaning of the extension
	Url string `json:"url"`
	// Value of extension
	ValueBase64Binary *string `json:"valueBase64Binary,omitempty"`
	// Extension for ValueBase64Binary
	ValueBase64BinaryExt *Element `json:"_valueBase64Binary,omitempty"`
	// Value of extension
	ValueBoolean *bool `json:"valueBoolean,omitempty"`
	// Extension for ValueBoolean
	ValueBooleanExt *Element `json:"_valueBoolean,omitempty"`
	// Value of extension
	ValueCanonical *string `json:"valueCanonical,omitempty"`
	// Extension for ValueCanonical
	ValueCanonicalExt *Element `json:"_valueCanonical,omitempty"`
	// Value of extension
	ValueCode *string `json:"valueCode,omitempty"`
	// Extension for ValueCode
	ValueCodeExt *Element `json:"_valueCode,omitempty"`
	// Value of extension
	ValueDate *string `json:"valueDate,omitempty"`
	// Extension for ValueDate
	ValueDateExt *Element `json:"_valueDate,omitempty"`
	// Value of extension
	ValueDateTime *string `json:"valueDateTime,omitempty"`
	// Extension for ValueDateTime
	ValueDateTimeExt *Element `json:"_valueDateTime,omitempty"`
	// Value of extension
	ValueDecimal *Decimal `json:"valueDecimal,omitempty"`
	// Extension for ValueDecimal
	ValueDecimalExt *Element `json:"_valueDecimal,omitempty"`
	// Value of extension
	ValueId *string `json:"valueId,omitempty"`
	// Extension for ValueId
	ValueIdExt *Element `json:"_valueId,omitempty"`
	// Value of extension
	ValueInstant *string `json:"valueInstant,omitempty"`
	// Extension for ValueInstant
	ValueInstantExt *Element `json:"_valueInstant,omitempty"`
	// Value of extension
	ValueInteger *int `json:"valueInteger,omitempty"`
	// Extension for ValueInteger
	ValueIntegerExt *Element `json:"_valueInteger,omitempty"`
	// Value of extension
	ValueMarkdown *string `json:"valueMarkdown,omitempty"`
	// Extension for ValueMarkdown
	ValueMarkdownExt *Element `json:"_valueMarkdown,omitempty"`
	// Value of extension
	ValueOid *string `json:"valueOid,omitempty"`
	// Extension for ValueOid
	ValueOidExt *Element `json:"_valueOid,omitempty"`
	// Value of extension
	ValuePositiveInt *uint32 `json:"valuePositiveInt,omitempty"`
	// Extension for ValuePositiveInt
	ValuePositiveIntExt *Element `json:"_valuePositiveInt,omitempty"`
	// Value of extension
	ValueString *string `json:"valueString,omitempty"`
	// Extension for ValueString
	ValueStringExt *Element `json:"_valueString,omitempty"`
	// Value of extension
	ValueTime *string `json:"valueTime,omitempty"`
	// Extension for ValueTime
	ValueTimeExt *Element `json:"_valueTime,omitempty"`
	// Value of extension
	ValueUnsignedInt *uint32 `json:"valueUnsignedInt,omitempty"`
	// Extension for ValueUnsignedInt
	ValueUnsignedIntExt *Element `json:"_valueUnsignedInt,omitempty"`
	// Value of extension
	ValueUri *string `json:"valueUri,omitempty"`
	// Extension for ValueUri
	ValueUriExt *Element `json:"_valueUri,omitempty"`
	// Value of extension
	ValueUrl *string `json:"valueUrl,omitempty"`
	// Extension for ValueUrl
	ValueUrlExt *Element `json:"_valueUrl,omitempty"`
	// Value of extension
	ValueUuid *string `json:"valueUuid,omitempty"`
	// Extension for ValueUuid
	ValueUuidExt *Element `json:"_valueUuid,omitempty"`
	// Value of extension
	ValueAddress *Address `json:"valueAddress,omitempty"`
	// Value of extension
	ValueAge *Age `json:"valueAge,omitempty"`
	// Value of extension
	ValueAnnotation *Annotation `json:"valueAnnotation,omitempty"`
	// Value of extension
	ValueAttachment *Attachment `json:"valueAttachment,omitempty"`
	// Value of extension
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`
	// Value of extension
	ValueCodeableReference *CodeableReference `json:"valueCodeableReference,omitempty"`
	// Value of extension
	ValueCoding *Coding `json:"valueCoding,omitempty"`
	// Value of extension
	ValueContactPoint *ContactPoint `json:"valueContactPoint,omitempty"`
	// Value of extension
	ValueCount *Count `json:"valueCount,omitempty"`
	// Value of extension
	ValueDistance *Distance `json:"valueDistance,omitempty"`
	// Value of extension
	ValueDuration *Duration `json:"valueDuration,omitempty"`
	// Value of extension
	ValueHumanName *HumanName `json:"valueHumanName,omitempty"`
	// Value of extension
	ValueIdentifier *Identifier `json:"valueIdentifier,omitempty"`
	// Value of extension
	ValueMoney *Money `json:"valueMoney,omitempty"`
	// Value of extension
	ValuePeriod *Period `json:"valuePeriod,omitempty"`
	// Value of extension
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`
	// Value of extension
	ValueRange *Range `json:"valueRange,omitempty"`
	// Value of extension
	ValueRatio *Ratio `json:"valueRatio,omitempty"`
	// Value of extension
	ValueRatioRange *RatioRange `json:"valueRatioRange,omitempty"`
	// Value of extension
	ValueReference *Reference `json:"valueReference,omitempty"`
	// Value of extension
	ValueSampledData *SampledData `json:"valueSampledData,omitempty"`
	// Value of extension
	ValueSignature *Signature `json:"valueSignature,omitempty"`
	// Value of extension
	ValueTiming *Timing `json:"valueTiming,omitempty"`
	// Value of extension
	ValueContactDetail *ContactDetail `json:"valueContactDetail,omitempty"`
	// Value of extension
	ValueContributor *Contributor `json:"valueContributor,omitempty"`
	// Value of extension
	ValueDataRequirement *DataRequirement `json:"valueDataRequirement,omitempty"`
	// Value of extension
	ValueExpression *Expression `json:"valueExpression,omitempty"`
	// Value of extension
	ValueParameterDefinition *ParameterDefinition `json:"valueParameterDefinition,omitempty"`
	// Value of extension
	ValueRelatedArtifact *RelatedArtifact `json:"valueRelatedArtifact,omitempty"`
	// Value of extension
	ValueTriggerDefinition *TriggerDefinition `json:"valueTriggerDefinition,omitempty"`
	// Value of extension
	ValueUsageContext *UsageContext `json:"valueUsageContext,omitempty"`
	// Value of extension
	ValueDosage *Dosage `json:"valueDosage,omitempty"`
}

// HumanName represents FHIR HumanName.
type HumanName struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// usual | official | temp | nickname | anonymous | old | maiden
	Use *NameUse `json:"use,omitempty"`
	// Extension for Use
	UseExt *Element `json:"_use,omitempty"`
	// Text representation of the full name
	Text *string `json:"text,omitempty"`
	// Extension for Text
	TextExt *Element `json:"_text,omitempty"`
	// Family name (often called 'Surname')
	Family *string `json:"family,omitempty"`
	// Extension for Family
	FamilyExt *Element `json:"_family,omitempty"`
	// Given names (not always 'first'). Includes middle names
	Given []string `json:"given,omitempty"`
	// Extension for Given
	GivenExt []Element `json:"_given,omitempty"`
	// Parts that come before the name
	Prefix []string `json:"prefix,omitempty"`
	// Extension for Prefix
	PrefixExt []Element `json:"_prefix,omitempty"`
	// Parts that come after the name
	Suffix []string `json:"suffix,omitempty"`
	// Extension for Suffix
	SuffixExt []Element `json:"_suffix,omitempty"`
	// Time period when name was/is in use
	Period *Period `json:"period,omitempty"`
}

// Identifier represents FHIR Identifier.
type Identifier struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// usual | official | temp | secondary | old (If known)
	Use *IdentifierUse `json:"use,omitempty"`
	// Extension for Use
	UseExt *Element `json:"_use,omitempty"`
	// Description of identifier
	Type *CodeableConcept `json:"type,omitempty"`
	// The namespace for the identifier value
	System *string `json:"system,omitempty"`
	// Extension for System
	SystemExt *Element `json:"_system,omitempty"`
	// The value that is unique
	Value *string `json:"value,omitempty"`
	// Extension for Value
	ValueExt *Element `json:"_value,omitempty"`
	// Time period when id is/was valid for use
	Period *Period `json:"period,omitempty"`
	// Organization that issued id (may be just text)
	Assigner *Reference `json:"assigner,omitempty"`
}

// MarketingStatus represents FHIR MarketingStatus.
type MarketingStatus struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The country in which the marketing authorisation has been granted shall be specified It should be specified using the ISO 3166  1 alpha-2 code elements
	Country *CodeableConcept `json:"country,omitempty"`
	// Where a Medicines Regulatory Agency has granted a marketing authorisation for which specific provisions within a jurisdiction apply, the jurisdiction can be specified using an appropriate controlled terminology The controlled term and the controlled term identifier shall be specified
	Jurisdiction *CodeableConcept `json:"jurisdiction,omitempty"`
	// This attribute provides information on the status of the marketing of the medicinal product See ISO/TS 20443 for more information and examples
	Status CodeableConcept `json:"status"`
	// The date when the Medicinal Product is placed on the market by the Marketing Authorisation Holder (or where applicable, the manufacturer/distributor) in a country and/or jurisdiction shall be provided A complete date consisting of day, month and year shall be specified using the ISO 8601 date format NOTE Placed on the market refers to the release of the Medicinal Product into the distribution chain
	DateRange *Period `json:"dateRange,omitempty"`
	// The date when the Medicinal Product is placed on the market by the Marketing Authorisation Holder (or where applicable, the manufacturer/distributor) in a country and/or jurisdiction shall be provided A complete date consisting of day, month and year shall be specified using the ISO 8601 date format NOTE Placed on the market refers to the release of the Medicinal Product into the distribution chain
	RestoreDate *string `json:"restoreDate,omitempty"`
	// Extension for RestoreDate
	RestoreDateExt *Element `json:"_restoreDate,omitempty"`
}

// Meta represents FHIR Meta.
type Meta struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Version specific identifier
	VersionId *string `json:"versionId,omitempty"`
	// Extension for VersionId
	VersionIdExt *Element `json:"_versionId,omitempty"`
	// When the resource version last changed
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// Extension for LastUpdated
	LastUpdatedExt *Element `json:"_lastUpdated,omitempty"`
	// Identifies where the resource comes from
	Source *string `json:"source,omitempty"`
	// Extension for Source
	SourceExt *Element `json:"_source,omitempty"`
	// Profiles this resource claims to conform to
	Profile []string `json:"profile,omitempty"`
	// Extension for Profile
	ProfileExt []Element `json:"_profile,omitempty"`
	// Security Labels applied to this resource
	Security []Coding `json:"security,omitempty"`
	// Tags applied to this resource
	Tag []Coding `json:"tag,omitempty"`
}

// Money represents FHIR Money.
type Money struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Numerical value (with implicit precision)
	Value *Decimal `json:"value,omitempty"`
	// Extension for Value
	ValueExt *Element `json:"_value,omitempty"`
	// ISO 4217 Currency Code
	Currency *string `json:"currency,omitempty"`
	// Extension for Currency
	CurrencyExt *Element `json:"_currency,omitempty"`
}

// Narrative represents FHIR Narrative.
type Narrative struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// generated | extensions | additional | empty
	Status *NarrativeStatus `json:"status,omitempty"`
	// Extension for Status
	StatusExt *Element `json:"_status,omitempty"`
	// Limited xhtml content
	Div *string `json:"div,omitempty"`
	// Extension for Div
	DivExt *Element `json:"_div,omitempty"`
}

// ParameterDefinition represents FHIR ParameterDefinition.
type ParameterDefinition struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Name used to access the parameter value
	Name *string `json:"name,omitempty"`
	// Extension for Name
	NameExt *Element `json:"_name,omitempty"`
	// in | out
	Use *OperationParameterUse `json:"use,omitempty"`
	// Extension for Use
	UseExt *Element `json:"_use,omitempty"`
	// Minimum cardinality
	Min *int `json:"min,omitempty"`
	// Extension for Min
	MinExt *Element `json:"_min,omitempty"`
	// Maximum cardinality (a number of *)
	Max *string `json:"max,omitempty"`
	// Extension for Max
	MaxExt *Element `json:"_max,omitempty"`
	// A brief description of the parameter
	Documentation *string `json:"documentation,omitempty"`
	// Extension for Documentation
	DocumentationExt *Element `json:"_documentation,omitempty"`
	// What type of value
	Type *string `json:"type,omitempty"`
	// Extension for Type
	TypeExt *Element `json:"_type,omitempty"`
	// What profile the value is expected to be
	Profile *string `json:"profile,omitempty"`
	// Extension for Profile
	ProfileExt *Element `json:"_profile,omitempty"`
}

// Period represents FHIR Period.
type Period struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Starting time with inclusive boundary
	Start *string `json:"start,omitempty"`
	// Extension for Start
	StartExt *Element `json:"_start,omitempty"`
	// End time with inclusive boundary, if not ongoing
	End *string `json:"end,omitempty"`
	// Extension for End
	EndExt *Element `json:"_end,omitempty"`
}

// Population represents FHIR Population.
type Population struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The age of the specific population
	AgeRange *Range `json:"ageRange,omitempty"`
	// The age of the specific population
	AgeCodeableConcept *CodeableConcept `json:"ageCodeableConcept,omitempty"`
	// The gender of the specific population
	Gender *CodeableConcept `json:"gender,omitempty"`
	// Race of the specific population
	Race *CodeableConcept `json:"race,omitempty"`
	// The existing physiological conditions of the specific population to which this applies
	PhysiologicalCondition *CodeableConcept `json:"physiologicalCondition,omitempty"`
}

// ProdCharacteristic represents FHIR ProdCharacteristic.
type ProdCharacteristic struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Where applicable, the height can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used
	Height *Quantity `json:"height,omitempty"`
	// Where applicable, the width can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used
	Width *Quantity `json:"width,omitempty"`
	// Where applicable, the depth can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used
	Depth *Quantity `json:"depth,omitempty"`
	// Where applicable, the weight can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used
	Weight *Quantity `json:"weight,omitempty"`
	// Where applicable, the nominal volume can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used
	NominalVolume *Quantity `json:"nominalVolume,omitempty"`
	// Where applicable, the external diameter can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used
	ExternalDiameter *Quantity `json:"externalDiameter,omitempty"`
	// Where applicable, the shape can be specified An appropriate controlled vocabulary shall be used The term and the term identifier shall be used
	Shape *string `json:"shape,omitempty"`
	// Extension for Shape
	ShapeExt *Element `json:"_shape,omitempty"`
	// Where applicable, the color can be specified An appropriate controlled vocabulary shall be used The term and the term identifier shall be used
	Color []string `json:"color,omitempty"`
	// Extension for Color
	ColorExt []Element `json:"_color,omitempty"`
	// Where applicable, the imprint can be specified as text
	Imprint []string `json:"imprint,omitempty"`
	// Extension for Imprint
	ImprintExt []Element `json:"_imprint,omitempty"`
	// Where applicable, the image can be provided The format of the image attachment shall be specified by regional implementations
	Image []Attachment `json:"image,omitempty"`
	// Where applicable, the scoring can be specified An appropriate controlled vocabulary shall be used The term and the term identifier shall be used
	Scoring *CodeableConcept `json:"scoring,omitempty"`
}

// ProductShelfLife represents FHIR ProductShelfLife.
type ProductShelfLife struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Unique identifier for the packaged Medicinal Product
	Identifier *Identifier `json:"identifier,omitempty"`
	// This describes the shelf life, taking into account various scenarios such as shelf life of the packaged Medicinal Product itself, shelf life after transformation where necessary and shelf life after the first opening of a bottle, etc. The shelf life type shall be specified using an appropriate controlled vocabulary The controlled term and the controlled term identifier shall be specified
	Type CodeableConcept `json:"type"`
	// The shelf life time period can be specified using a numerical value for the period of time and its unit of time measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used
	Period Quantity `json:"period"`
	// Special precautions for storage, if any, can be specified using an appropriate controlled vocabulary The controlled term and the controlled term identifier shall be specified
	SpecialPrecautionsForStorage []CodeableConcept `json:"specialPrecautionsForStorage,omitempty"`
}

// Quantity represents FHIR Quantity.
type Quantity struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Numerical value (with implicit precision)
	Value *Decimal `json:"value,omitempty"`
	// Extension for Value
	ValueExt *Element `json:"_value,omitempty"`
	// < | <= | >= | > - how to understand the value
	Comparator *QuantityComparator `json:"comparator,omitempty"`
	// Extension for Comparator
	ComparatorExt *Element `json:"_comparator,omitempty"`
	// Unit representation
	Unit *string `json:"unit,omitempty"`
	// Extension for Unit
	UnitExt *Element `json:"_unit,omitempty"`
	// System that defines coded unit form
	System *string `json:"system,omitempty"`
	// Extension for System
	SystemExt *Element `json:"_system,omitempty"`
	// Coded form of the unit
	Code *string `json:"code,omitempty"`
	// Extension for Code
	CodeExt *Element `json:"_code,omitempty"`
}

// Range represents FHIR Range.
type Range struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Low limit
	Low *Quantity `json:"low,omitempty"`
	// High limit
	High *Quantity `json:"high,omitempty"`
}

// Ratio represents FHIR Ratio.
type Ratio struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Numerator value
	Numerator *Quantity `json:"numerator,omitempty"`
	// Denominator value
	Denominator *Quantity `json:"denominator,omitempty"`
}

// RatioRange represents FHIR RatioRange.
type RatioRange struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Low Numerator limit
	LowNumerator *Quantity `json:"lowNumerator,omitempty"`
	// High Numerator limit
	HighNumerator *Quantity `json:"highNumerator,omitempty"`
	// Denominator value
	Denominator *Quantity `json:"denominator,omitempty"`
}

// Reference represents FHIR Reference.
type Reference struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Literal reference, Relative, internal or absolute URL
	Reference *string `json:"reference,omitempty"`
	// Extension for Reference
	ReferenceExt *Element `json:"_reference,omitempty"`
	// Type the reference refers to (e.g. "Patient")
	Type *string `json:"type,omitempty"`
	// Extension for Type
	TypeExt *Element `json:"_type,omitempty"`
	// Logical reference, when literal reference is not known
	Identifier *Identifier `json:"identifier,omitempty"`
	// Text alternative for the resource
	Display *string `json:"display,omitempty"`
	// Extension for Display
	DisplayExt *Element `json:"_display,omitempty"`
}

// RelatedArtifact represents FHIR RelatedArtifact.
type RelatedArtifact struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// documentation | justification | citation | predecessor | successor | derived-from | depends-on | composed-of
	Type *RelatedArtifactType `json:"type,omitempty"`
	// Extension for Type
	TypeExt *Element `json:"_type,omitempty"`
	// Short label
	Label *string `json:"label,omitempty"`
	// Extension for Label
	LabelExt *Element `json:"_label,omitempty"`
	// Brief description of the related artifact
	Display *string `json:"display,omitempty"`
	// Extension for Display
	DisplayExt *Element `json:"_display,omitempty"`
	// Bibliographic citation for the artifact
	Citation *string `json:"citation,omitempty"`
	// Extension for Citation
	CitationExt *Element `json:"_citation,omitempty"`
	// Where the artifact can be accessed
	Url *string `json:"url,omitempty"`
	// Extension for Url
	UrlExt *Element `json:"_url,omitempty"`
	// What document is being referenced
	Document *Attachment `json:"document,omitempty"`
	// What resource is being referenced
	Resource *string `json:"resource,omitempty"`
	// Extension for Resource
	ResourceExt *Element `json:"_resource,omitempty"`
}

// SampledData represents FHIR SampledData.
type SampledData struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Zero value and units
	Origin Quantity `json:"origin"`
	// Number of milliseconds between samples
	Period *Decimal `json:"period,omitempty"`
	// Extension for Period
	PeriodExt *Element `json:"_period,omitempty"`
	// Multiply data by this before adding to origin
	Factor *Decimal `json:"factor,omitempty"`
	// Extension for Factor
	FactorExt *Element `json:"_factor,omitempty"`
	// Lower limit of detection
	LowerLimit *Decimal `json:"lowerLimit,omitempty"`
	// Extension for LowerLimit
	LowerLimitExt *Element `json:"_lowerLimit,omitempty"`
	// Upper limit of detection
	UpperLimit *Decimal `json:"upperLimit,omitempty"`
	// Extension for UpperLimit
	UpperLimitExt *Element `json:"_upperLimit,omitempty"`
	// Number of sample points at each time point
	Dimensions *uint32 `json:"dimensions,omitempty"`
	// Extension for Dimensions
	DimensionsExt *Element `json:"_dimensions,omitempty"`
	// Decimal values with spaces, or "E" | "U" | "L"
	Data *string `json:"data,omitempty"`
	// Extension for Data
	DataExt *Element `json:"_data,omitempty"`
}

// Signature represents FHIR Signature.
type Signature struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Indication of the reason the entity signed the object(s)
	Type []Coding `json:"type,omitempty"`
	// When the signature was created
	When *string `json:"when,omitempty"`
	// Extension for When
	WhenExt *Element `json:"_when,omitempty"`
	// Who signed
	Who Reference `json:"who"`
	// The party represented
	OnBehalfOf *Reference `json:"onBehalfOf,omitempty"`
	// The technical format of the signed resources
	TargetFormat *string `json:"targetFormat,omitempty"`
	// Extension for TargetFormat
	TargetFormatExt *Element `json:"_targetFormat,omitempty"`
	// The technical format of the signature
	SigFormat *string `json:"sigFormat,omitempty"`
	// Extension for SigFormat
	SigFormatExt *Element `json:"_sigFormat,omitempty"`
	// The actual signature content (XML DigSig. JWS, picture, etc.)
	Data *string `json:"data,omitempty"`
	// Extension for Data
	DataExt *Element `json:"_data,omitempty"`
}

// Timing represents FHIR Timing.
type Timing struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// When the event occurs
	Event []string `json:"event,omitempty"`
	// Extension for Event
	EventExt []Element `json:"_event,omitempty"`
	// When the event is to occur
	Repeat *TimingRepeat `json:"repeat,omitempty"`
	// BID | TID | QID | AM | PM | QD | QOD | +
	Code *CodeableConcept `json:"code,omitempty"`
}

// TriggerDefinition represents FHIR TriggerDefinition.
type TriggerDefinition struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// named-event | periodic | data-changed | data-added | data-modified | data-removed | data-accessed | data-access-ended
	Type *TriggerType `json:"type,omitempty"`
	// Extension for Type
	TypeExt *Element `json:"_type,omitempty"`
	// Name or URI that identifies the event
	Name *string `json:"name,omitempty"`
	// Extension for Name
	NameExt *Element `json:"_name,omitempty"`
	// Timing of the event
	TimingTiming *Timing `json:"timingTiming,omitempty"`
	// Timing of the event
	TimingReference *Reference `json:"timingReference,omitempty"`
	// Timing of the event
	TimingDate *string `json:"timingDate,omitempty"`
	// Extension for TimingDate
	TimingDateExt *Element `json:"_timingDate,omitempty"`
	// Timing of the event
	TimingDateTime *string `json:"timingDateTime,omitempty"`
	// Extension for TimingDateTime
	TimingDateTimeExt *Element `json:"_timingDateTime,omitempty"`
	// Triggering data of the event (multiple = 'and')
	Data []DataRequirement `json:"data,omitempty"`
	// Whether the event triggers (boolean expression)
	Condition *Expression `json:"condition,omitempty"`
}

// UsageContext represents FHIR UsageContext.
type UsageContext struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Type of context being specified
	Code Coding `json:"code"`
	// Value that defines the context
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`
	// Value that defines the context
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`
	// Value that defines the context
	ValueRange *Range `json:"valueRange,omitempty"`
	// Value that defines the context
	ValueReference *Reference `json:"valueReference,omitempty"`
}

// MoneyQuantity represents FHIR MoneyQuantity.
type MoneyQuantity struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Numerical value (with implicit precision)
	Value *Decimal `json:"value,omitempty"`
	// Extension for Value
	ValueExt *Element `json:"_value,omitempty"`
	// < | <= | >= | > - how to understand the value
	Comparator *QuantityComparator `json:"comparator,omitempty"`
	// Extension for Comparator
	ComparatorExt *Element `json:"_comparator,omitempty"`
	// Unit representation
	Unit *string `json:"unit,omitempty"`
	// Extension for Unit
	UnitExt *Element `json:"_unit,omitempty"`
	// System that defines coded unit form
	System *string `json:"system,omitempty"`
	// Extension for System
	SystemExt *Element `json:"_system,omitempty"`
	// Coded form of the unit
	Code *string `json:"code,omitempty"`
	// Extension for Code
	CodeExt *Element `json:"_code,omitempty"`
}

// SimpleQuantity represents FHIR SimpleQuantity.
type SimpleQuantity struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Numerical value (with implicit precision)
	Value *Decimal `json:"value,omitempty"`
	// Extension for Value
	ValueExt *Element `json:"_value,omitempty"`
	// < | <= | >= | > - how to understand the value
	Comparator *QuantityComparator `json:"comparator,omitempty"`
	// Extension for Comparator
	ComparatorExt *Element `json:"_comparator,omitempty"`
	// Unit representation
	Unit *string `json:"unit,omitempty"`
	// Extension for Unit
	UnitExt *Element `json:"_unit,omitempty"`
	// System that defines coded unit form
	System *string `json:"system,omitempty"`
	// Extension for System
	SystemExt *Element `json:"_system,omitempty"`
	// Coded form of the unit
	Code *string `json:"code,omitempty"`
	// Extension for Code
	CodeExt *Element `json:"_code,omitempty"`
}

// DataRequirementCodeFilter represents the DataRequirement.codeFilter backbone element.
// What codes are expected
type DataRequirementCodeFilter struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// A code-valued attribute to filter on
	Path *string `json:"path,omitempty"`
	// A coded (token) parameter to search on
	SearchParam *string `json:"searchParam,omitempty"`
	// Valueset for the filter
	ValueSet *string `json:"valueSet,omitempty"`
	// What code is expected
	Code []Coding `json:"code,omitempty"`
}

// DataRequirementDateFilter represents the DataRequirement.dateFilter backbone element.
// What dates/date ranges are expected
type DataRequirementDateFilter struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// A date-valued attribute to filter on
	Path *string `json:"path,omitempty"`
	// A date valued parameter to search on
	SearchParam *string `json:"searchParam,omitempty"`
	// The value of the filter, as a Period, DateTime, or Duration value
	ValueDateTime *string `json:"valueDateTime,omitempty"`
	// Extension for ValueDateTime
	ValueDateTimeExt *Element `json:"_valueDateTime,omitempty"`
	// The value of the filter, as a Period, DateTime, or Duration value
	ValuePeriod *Period `json:"valuePeriod,omitempty"`
	// The value of the filter, as a Period, DateTime, or Duration value
	ValueDuration *Duration `json:"valueDuration,omitempty"`
}

// DataRequirementSort represents the DataRequirement.sort backbone element.
// Order of the results
type DataRequirementSort struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// The name of the attribute to perform the sort
	Path *string `json:"path,omitempty"`
	// ascending | descending
	Direction *SortDirection `json:"direction,omitempty"`
}

// DosageDoseAndRate represents the Dosage.doseAndRate backbone element.
// Amount of medication administered
type DosageDoseAndRate struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// The kind of dose or rate specified
	Type *CodeableConcept `json:"type,omitempty"`
	// Amount of medication per dose
	DoseRange *Range `json:"doseRange,omitempty"`
	// Amount of medication per dose
	DoseQuantity *Quantity `json:"doseQuantity,omitempty"`
	// Amount of medication per unit of time
	RateRatio *Ratio `json:"rateRatio,omitempty"`
	// Amount of medication per unit of time
	RateRange *Range `json:"rateRange,omitempty"`
	// Amount of medication per unit of time
	RateQuantity *Quantity `json:"rateQuantity,omitempty"`
}

// ElementDefinitionBase represents the ElementDefinition.base backbone element.
// Base definition information for tools
type ElementDefinitionBase struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Path that identifies the base element
	Path *string `json:"path,omitempty"`
	// Min cardinality of the base element
	Min *uint32 `json:"min,omitempty"`
	// Max cardinality of the base element
	Max *string `json:"max,omitempty"`
}

// ElementDefinitionBinding represents the ElementDefinition.binding backbone element.
// ValueSet details if this is coded
type ElementDefinitionBinding struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// required | extensible | preferred | example
	Strength *BindingStrength `json:"strength,omitempty"`
	// Human explanation of the value set
	Description *string `json:"description,omitempty"`
	// Source of value set
	ValueSet *string `json:"valueSet,omitempty"`
}

// ElementDefinitionConstraint represents the ElementDefinition.constraint backbone element.
// Condition that must evaluate to true
type ElementDefinitionConstraint struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Target of 'condition' reference above
	Key *string `json:"key,omitempty"`
	// Why this constraint is necessary or appropriate
	Requirements *string `json:"requirements,omitempty"`
	// error | warning
	Severity *ConstraintSeverity `json:"severity,omitempty"`
	// Human description of constraint
	Human *string `json:"human,omitempty"`
	// FHIRPath expression of constraint
	Expression *string `json:"expression,omitempty"`
	// XPath expression of constraint
	Xpath *string `json:"xpath,omitempty"`
	// Reference to original source of constraint
	Source *string `json:"source,omitempty"`
}

// ElementDefinitionExample represents the ElementDefinition.example backbone element.
// Example value (as defined for type)
type ElementDefinitionExample struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Describes the purpose of this example
	Label *string `json:"label,omitempty"`
	// Value of Example (one of allowed types)
	ValueBase64Binary *string `json:"valueBase64Binary,omitempty"`
	// Extension for ValueBase64Binary
	ValueBase64BinaryExt *Element `json:"_valueBase64Binary,omitempty"`
	// Value of Example (one of allowed types)
	ValueBoolean *bool `json:"valueBoolean,omitempty"`
	// Extension for ValueBoolean
	ValueBooleanExt *Element `json:"_valueBoolean,omitempty"`
	// Value of Example (one of allowed types)
	ValueCanonical *string `json:"valueCanonical,omitempty"`
	// Extension for ValueCanonical
	ValueCanonicalExt *Element `json:"_valueCanonical,omitempty"`
	// Value of Example (one of allowed types)
	ValueCode *string `json:"valueCode,omitempty"`
	// Extension for ValueCode
	ValueCodeExt *Element `json:"_valueCode,omitempty"`
	// Value of Example (one of allowed types)
	ValueDate *string `json:"valueDate,omitempty"`
	// Extension for ValueDate
	ValueDateExt *Element `json:"_valueDate,omitempty"`
	// Value of Example (one of allowed types)
	ValueDateTime *string `json:"valueDateTime,omitempty"`
	// Extension for ValueDateTime
	ValueDateTimeExt *Element `json:"_valueDateTime,omitempty"`
	// Value of Example (one of allowed types)
	ValueDecimal *Decimal `json:"valueDecimal,omitempty"`
	// Extension for ValueDecimal
	ValueDecimalExt *Element `json:"_valueDecimal,omitempty"`
	// Value of Example (one of allowed types)
	ValueId *string `json:"valueId,omitempty"`
	// Extension for ValueId
	ValueIdExt *Element `json:"_valueId,omitempty"`
	// Value of Example (one of allowed types)
	ValueInstant *string `json:"valueInstant,omitempty"`
	// Extension for ValueInstant
	ValueInstantExt *Element `json:"_valueInstant,omitempty"`
	// Value of Example (one of allowed types)
	ValueInteger *int `json:"valueInteger,omitempty"`
	// Extension for ValueInteger
	ValueIntegerExt *Element `json:"_valueInteger,omitempty"`
	// Value of Example (one of allowed types)
	ValueMarkdown *string `json:"valueMarkdown,omitempty"`
	// Extension for ValueMarkdown
	ValueMarkdownExt *Element `json:"_valueMarkdown,omitempty"`
	// Value of Example (one of allowed types)
	ValueOid *string `json:"valueOid,omitempty"`
	// Extension for ValueOid
	ValueOidExt *Element `json:"_valueOid,omitempty"`
	// Value of Example (one of allowed types)
	ValuePositiveInt *uint32 `json:"valuePositiveInt,omitempty"`
	// Extension for ValuePositiveInt
	ValuePositiveIntExt *Element `json:"_valuePositiveInt,omitempty"`
	// Value of Example (one of allowed types)
	ValueString *string `json:"valueString,omitempty"`
	// Extension for ValueString
	ValueStringExt *Element `json:"_valueString,omitempty"`
	// Value of Example (one of allowed types)
	ValueTime *string `json:"valueTime,omitempty"`
	// Extension for ValueTime
	ValueTimeExt *Element `json:"_valueTime,omitempty"`
	// Value of Example (one of allowed types)
	ValueUnsignedInt *uint32 `json:"valueUnsignedInt,omitempty"`
	// Extension for ValueUnsignedInt
	ValueUnsignedIntExt *Element `json:"_valueUnsignedInt,omitempty"`
	// Value of Example (one of allowed types)
	ValueUri *string `json:"valueUri,omitempty"`
	// Extension for ValueUri
	ValueUriExt *Element `json:"_valueUri,omitempty"`
	// Value of Example (one of allowed types)
	ValueUrl *string `json:"valueUrl,omitempty"`
	// Extension for ValueUrl
	ValueUrlExt *Element `json:"_valueUrl,omitempty"`
	// Value of Example (one of allowed types)
	ValueUuid *string `json:"valueUuid,omitempty"`
	// Extension for ValueUuid
	ValueUuidExt *Element `json:"_valueUuid,omitempty"`
	// Value of Example (one of allowed types)
	ValueAddress *Address `json:"valueAddress,omitempty"`
	// Value of Example (one of allowed types)
	ValueAge *Age `json:"valueAge,omitempty"`
	// Value of Example (one of allowed types)
	ValueAnnotation *Annotation `json:"valueAnnotation,omitempty"`
	// Value of Example (one of allowed types)
	ValueAttachment *Attachment `json:"valueAttachment,omitempty"`
	// Value of Example (one of allowed types)
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`
	// Value of Example (one of allowed types)
	ValueCodeableReference *CodeableReference `json:"valueCodeableReference,omitempty"`
	// Value of Example (one of allowed types)
	ValueCoding *Coding `json:"valueCoding,omitempty"`
	// Value of Example (one of allowed types)
	ValueContactPoint *ContactPoint `json:"valueContactPoint,omitempty"`
	// Value of Example (one of allowed types)
	ValueCount *Count `json:"valueCount,omitempty"`
	// Value of Example (one of allowed types)
	ValueDistance *Distance `json:"valueDistance,omitempty"`
	// Value of Example (one of allowed types)
	ValueDuration *Duration `json:"valueDuration,omitempty"`
	// Value of Example (one of allowed types)
	ValueHumanName *HumanName `json:"valueHumanName,omitempty"`
	// Value of Example (one of allowed types)
	ValueIdentifier *Identifier `json:"valueIdentifier,omitempty"`
	// Value of Example (one of allowed types)
	ValueMoney *Money `json:"valueMoney,omitempty"`
	// Value of Example (one of allowed types)
	ValuePeriod *Period `json:"valuePeriod,omitempty"`
	// Value of Example (one of allowed types)
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`
	// Value of Example (one of allowed types)
	ValueRange *Range `json:"valueRange,omitempty"`
	// Value of Example (one of allowed types)
	ValueRatio *Ratio `json:"valueRatio,omitempty"`
	// Value of Example (one of allowed types)
	ValueRatioRange *RatioRange `json:"valueRatioRange,omitempty"`
	// Value of Example (one of allowed types)
	ValueReference *Reference `json:"valueReference,omitempty"`
	// Value of Example (one of allowed types)
	ValueSampledData *SampledData `json:"valueSampledData,omitempty"`
	// Value of Example (one of allowed types)
	ValueSignature *Signature `json:"valueSignature,omitempty"`
	// Value of Example (one of allowed types)
	ValueTiming *Timing `json:"valueTiming,omitempty"`
	// Value of Example (one of allowed types)
	ValueContactDetail *ContactDetail `json:"valueContactDetail,omitempty"`
	// Value of Example (one of allowed types)
	ValueContributor *Contributor `json:"valueContributor,omitempty"`
	// Value of Example (one of allowed types)
	ValueDataRequirement *DataRequirement `json:"valueDataRequirement,omitempty"`
	// Value of Example (one of allowed types)
	ValueExpression *Expression `json:"valueExpression,omitempty"`
	// Value of Example (one of allowed types)
	ValueParameterDefinition *ParameterDefinition `json:"valueParameterDefinition,omitempty"`
	// Value of Example (one of allowed types)
	ValueRelatedArtifact *RelatedArtifact `json:"valueRelatedArtifact,omitempty"`
	// Value of Example (one of allowed types)
	ValueTriggerDefinition *TriggerDefinition `json:"valueTriggerDefinition,omitempty"`
	// Value of Example (one of allowed types)
	ValueUsageContext *UsageContext `json:"valueUsageContext,omitempty"`
	// Value of Example (one of allowed types)
	ValueDosage *Dosage `json:"valueDosage,omitempty"`
}

// ElementDefinitionMapping represents the ElementDefinition.mapping backbone element.
// Map element to another set of definitions
type ElementDefinitionMapping struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Reference to mapping declaration
	Identity *string `json:"identity,omitempty"`
	// Computable language of mapping
	Language *string `json:"language,omitempty"`
	// Details of the mapping
	Map *string `json:"map,omitempty"`
	// Comments about the mapping or its use
	Comment *string `json:"comment,omitempty"`
}

// ElementDefinitionSlicing represents the ElementDefinition.slicing backbone element.
// This element is sliced - slices follow
type ElementDefinitionSlicing struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Element values that are used to distinguish the slices
	Discriminator []ElementDefinitionSlicingDiscriminator `json:"discriminator,omitempty"`
	// Text description of how slicing works (or not)
	Description *string `json:"description,omitempty"`
	// If elements must be in same order as slices
	Ordered *bool `json:"ordered,omitempty"`
	// closed | open | openAtEnd
	Rules *SlicingRules `json:"rules,omitempty"`
}

// ElementDefinitionSlicingDiscriminator represents the ElementDefinition.slicing.discriminator backbone element.
// Element values that are used to distinguish the slices
type ElementDefinitionSlicingDiscriminator struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// value | exists | pattern | type | profile
	Type *DiscriminatorType `json:"type,omitempty"`
	// Path to element value
	Path *string `json:"path,omitempty"`
}

// ElementDefinitionType represents the ElementDefinition.type backbone element.
// Data type and Profile for this element
type ElementDefinitionType struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Data type or Resource (reference to definition)
	Code *string `json:"code,omitempty"`
	// Profiles (StructureDefinition or IG) - one must apply
	Profile []string `json:"profile,omitempty"`
	// Profile (StructureDefinition or IG) on the Reference/canonical target - one must apply
	TargetProfile []string `json:"targetProfile,omitempty"`
	// contained | referenced | bundled - how aggregated
	Aggregation []AggregationMode `json:"aggregation,omitempty"`
	// either | independent | specific
	Versioning *ReferenceVersionRules `json:"versioning,omitempty"`
}

// TimingRepeat represents the Timing.repeat backbone element.
// When the event is to occur
type TimingRepeat struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Length/Range of lengths, or (Start and/or end) limits
	BoundsDuration *Duration `json:"boundsDuration,omitempty"`
	// Length/Range of lengths, or (Start and/or end) limits
	BoundsRange *Range `json:"boundsRange,omitempty"`
	// Length/Range of lengths, or (Start and/or end) limits
	BoundsPeriod *Period `json:"boundsPeriod,omitempty"`
	// Number of times to repeat
	Count *uint32 `json:"count,omitempty"`
	// Maximum number of times to repeat
	CountMax *uint32 `json:"countMax,omitempty"`
	// How long when it happens
	Duration *Decimal `json:"duration,omitempty"`
	// How long when it happens (Max)
	DurationMax *Decimal `json:"durationMax,omitempty"`
	// s | min | h | d | wk | mo | a - unit of time (UCUM)
	DurationUnit *UnitsOfTime `json:"durationUnit,omitempty"`
	// Event occurs frequency times per period
	Frequency *uint32 `json:"frequency,omitempty"`
	// Event occurs up to frequencyMax times per period
	FrequencyMax *uint32 `json:"frequencyMax,omitempty"`
	// Event occurs frequency times per period
	Period *Decimal `json:"period,omitempty"`
	// Upper limit of period (3-4 hours)
	PeriodMax *Decimal `json:"periodMax,omitempty"`
	// s | min | h | d | wk | mo | a - unit of time (UCUM)
	PeriodUnit *UnitsOfTime `json:"periodUnit,omitempty"`
	// mon | tue | wed | thu | fri | sat | sun
	DayOfWeek []DaysOfWeek `json:"dayOfWeek,omitempty"`
	// Time of day for action
	TimeOfDay []string `json:"timeOfDay,omitempty"`
	// Code for time period of occurrence
	When []EventTiming `json:"when,omitempty"`
	// Minutes from event (before or after)
	Offset *uint32 `json:"offset,omitempty"`
}

// =============================================================================
// Datatype XML Serialization
// =============================================================================

// MarshalXML serializes Element to FHIR-conformant XML.
func (d Element) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Element"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes BackboneElement to FHIR-conformant XML.
func (d BackboneElement) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "BackboneElement"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range d.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes Address to FHIR-conformant XML.
func (d Address) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Address"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveCode(e, "use", d.Use, d.UseExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveCode(e, "type", d.Type, d.TypeExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "text", d.Text, d.TextExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveStringArray(e, "line", d.Line, d.LineExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "city", d.City, d.CityExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "district", d.District, d.DistrictExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "state", d.State, d.StateExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "postalCode", d.PostalCode, d.PostalCodeExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "country", d.Country, d.CountryExt); err != nil {
		return err
	}
	if d.Period != nil {
		if err := d.Period.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "period"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes Age to FHIR-conformant XML.
func (d Age) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Age"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveDecimal(e, "value", d.Value, d.ValueExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveCode(e, "comparator", d.Comparator, d.ComparatorExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "unit", d.Unit, d.UnitExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "system", d.System, d.SystemExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "code", d.Code, d.CodeExt); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes Annotation to FHIR-conformant XML.
func (d Annotation) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Annotation"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if d.AuthorReference != nil {
		if err := d.AuthorReference.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "authorReference"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "authorString", d.AuthorString, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "time", d.Time, d.TimeExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "text", d.Text, d.TextExt); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes Attachment to FHIR-conformant XML.
func (d Attachment) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Attachment"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "contentType", d.ContentType, d.ContentTypeExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "language", d.Language, d.LanguageExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "data", d.Data, d.DataExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "url", d.Url, d.UrlExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveUint32(e, "size", d.Size, d.SizeExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "hash", d.Hash, d.HashExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "title", d.Title, d.TitleExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "creation", d.Creation, d.CreationExt); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes CodeableConcept to FHIR-conformant XML.
func (d CodeableConcept) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "CodeableConcept"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range d.Coding {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "coding"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "text", d.Text, d.TextExt); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes CodeableReference to FHIR-conformant XML.
func (d CodeableReference) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "CodeableReference"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if d.Concept != nil {
		if err := d.Concept.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "concept"}}); err != nil {
			return err
		}
	}
	if d.Reference != nil {
		if err := d.Reference.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "reference"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes Coding to FHIR-conformant XML.
func (d Coding) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Coding"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "system", d.System, d.SystemExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "version", d.Version, d.VersionExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "code", d.Code, d.CodeExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "display", d.Display, d.DisplayExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveBool(e, "userSelected", d.UserSelected, d.UserSelectedExt); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes ContactDetail to FHIR-conformant XML.
func (d ContactDetail) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "ContactDetail"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "name", d.Name, d.NameExt); err != nil {
		return err
	}
	for _, item := range d.Telecom {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "telecom"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes ContactPoint to FHIR-conformant XML.
func (d ContactPoint) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "ContactPoint"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveCode(e, "system", d.System, d.SystemExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "value", d.Value, d.ValueExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveCode(e, "use", d.Use, d.UseExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveUint32(e, "rank", d.Rank, d.RankExt); err != nil {
		return err
	}
	if d.Period != nil {
		if err := d.Period.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "period"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes Contributor to FHIR-conformant XML.
func (d Contributor) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Contributor"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveCode(e, "type", d.Type, d.TypeExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "name", d.Name, d.NameExt); err != nil {
		return err
	}
	for _, item := range d.Contact {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "contact"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes Count to FHIR-conformant XML.
func (d Count) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Count"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveDecimal(e, "value", d.Value, d.ValueExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveCode(e, "comparator", d.Comparator, d.ComparatorExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "unit", d.Unit, d.UnitExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "system", d.System, d.SystemExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "code", d.Code, d.CodeExt); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes DataRequirement to FHIR-conformant XML.
func (d DataRequirement) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "DataRequirement"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "type", d.Type, d.TypeExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveStringArray(e, "profile", d.Profile, d.ProfileExt); err != nil {
		return err
	}
	if d.SubjectCodeableConcept != nil {
		if err := d.SubjectCodeableConcept.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "subjectCodeableConcept"}}); err != nil {
			return err
		}
	}
	if d.SubjectReference != nil {
		if err := d.SubjectReference.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "subjectReference"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveStringArray(e, "mustSupport", d.MustSupport, d.MustSupportExt); err != nil {
		return err
	}
	for _, item := range d.CodeFilter {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "codeFilter"}}); err != nil {
			return err
		}
	}
	for _, item := range d.DateFilter {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "dateFilter"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveUint32(e, "limit", d.Limit, d.LimitExt); err != nil {
		return err
	}
	for _, item := range d.Sort {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "sort"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes Distance to FHIR-conformant XML.
func (d Distance) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Distance"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveDecimal(e, "value", d.Value, d.ValueExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveCode(e, "comparator", d.Comparator, d.ComparatorExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "unit", d.Unit, d.UnitExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "system", d.System, d.SystemExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "code", d.Code, d.CodeExt); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes Dosage to FHIR-conformant XML.
func (d Dosage) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Dosage"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range d.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveInt(e, "sequence", d.Sequence, d.SequenceExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "text", d.Text, d.TextExt); err != nil {
		return err
	}
	for _, item := range d.AdditionalInstruction {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "additionalInstruction"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "patientInstruction", d.PatientInstruction, d.PatientInstructionExt); err != nil {
		return err
	}
	if d.Timing != nil {
		if err := d.Timing.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "timing"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveBool(e, "asNeededBoolean", d.AsNeededBoolean, nil); err != nil {
		return err
	}
	if d.AsNeededCodeableConcept != nil {
		if err := d.AsNeededCodeableConcept.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "asNeededCodeableConcept"}}); err != nil {
			return err
		}
	}
	if d.Site != nil {
		if err := d.Site.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "site"}}); err != nil {
			return err
		}
	}
	if d.Route != nil {
		if err := d.Route.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "route"}}); err != nil {
			return err
		}
	}
	if d.Method != nil {
		if err := d.Method.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "method"}}); err != nil {
			return err
		}
	}
	for _, item := range d.DoseAndRate {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "doseAndRate"}}); err != nil {
			return err
		}
	}
	if d.MaxDosePerPeriod != nil {
		if err := d.MaxDosePerPeriod.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "maxDosePerPeriod"}}); err != nil {
			return err
		}
	}
	if d.MaxDosePerAdministration != nil {
		if err := d.MaxDosePerAdministration.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "maxDosePerAdministration"}}); err != nil {
			return err
		}
	}
	if d.MaxDosePerLifetime != nil {
		if err := d.MaxDosePerLifetime.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "maxDosePerLifetime"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes Duration to FHIR-conformant XML.
func (d Duration) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Duration"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveDecimal(e, "value", d.Value, d.ValueExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveCode(e, "comparator", d.Comparator, d.ComparatorExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "unit", d.Unit, d.UnitExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "system", d.System, d.SystemExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "code", d.Code, d.CodeExt); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes ElementDefinition to FHIR-conformant XML.
func (d ElementDefinition) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "ElementDefinition"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range d.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "path", d.Path, d.PathExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveCodeArray(e, "representation", d.Representation, d.RepresentationExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "sliceName", d.SliceName, d.SliceNameExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveBool(e, "sliceIsConstraining", d.SliceIsConstraining, d.SliceIsConstrainingExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "label", d.Label, d.LabelExt); err != nil {
		return err
	}
	for _, item := range d.Code {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "code"}}); err != nil {
			return err
		}
	}
	if d.Slicing != nil {
		if err := d.Slicing.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "slicing"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "short", d.Short, d.ShortExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "definition", d.Definition, d.DefinitionExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "comment", d.Comment, d.CommentExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "requirements", d.Requirements, d.RequirementsExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveStringArray(e, "alias", d.Alias, d.AliasExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveUint32(e, "min", d.Min, d.MinExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "max", d.Max, d.MaxExt); err != nil {
		return err
	}
	if d.Base != nil {
		if err := d.Base.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "base"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "contentReference", d.ContentReference, d.ContentReferenceExt); err != nil {
		return err
	}
	for _, item := range d.Type {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "defaultValueBase64Binary", d.DefaultValueBase64Binary, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveBool(e, "defaultValueBoolean", d.DefaultValueBoolean, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "defaultValueCanonical", d.DefaultValueCanonical, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "defaultValueCode", d.DefaultValueCode, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "defaultValueDate", d.DefaultValueDate, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "defaultValueDateTime", d.DefaultValueDateTime, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveDecimal(e, "defaultValueDecimal", d.DefaultValueDecimal, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "defaultValueId", d.DefaultValueId, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "defaultValueInstant", d.DefaultValueInstant, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveInt(e, "defaultValueInteger", d.DefaultValueInteger, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "defaultValueMarkdown", d.DefaultValueMarkdown, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "defaultValueOid", d.DefaultValueOid, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveUint32(e, "defaultValuePositiveInt", d.DefaultValuePositiveInt, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "defaultValueString", d.DefaultValueString, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "defaultValueTime", d.DefaultValueTime, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveUint32(e, "defaultValueUnsignedInt", d.DefaultValueUnsignedInt, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "defaultValueUri", d.DefaultValueUri, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "defaultValueUrl", d.DefaultValueUrl, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "defaultValueUuid", d.DefaultValueUuid, nil); err != nil {
		return err
	}
	if d.DefaultValueAddress != nil {
		if err := d.DefaultValueAddress.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "defaultValueAddress"}}); err != nil {
			return err
		}
	}
	if d.DefaultValueAge != nil {
		if err := d.DefaultValueAge.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "defaultValueAge"}}); err != nil {
			return err
		}
	}
	if d.DefaultValueAnnotation != nil {
		if err := d.DefaultValueAnnotation.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "defaultValueAnnotation"}}); err != nil {
			return err
		}
	}
	if d.DefaultValueAttachment != nil {
		if err := d.DefaultValueAttachment.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "defaultValueAttachment"}}); err != nil {
			return err
		}
	}
	if d.DefaultValueCodeableConcept != nil {
		if err := d.DefaultValueCodeableConcept.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "defaultValueCodeableConcept"}}); err != nil {
			return err
		}
	}
	if d.DefaultValueCodeableReference != nil {
		if err := d.DefaultValueCodeableReference.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "defaultValueCodeableReference"}}); err != nil {
			return err
		}
	}
	if d.DefaultValueCoding != nil {
		if err := d.DefaultValueCoding.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "defaultValueCoding"}}); err != nil {
			return err
		}
	}
	if d.DefaultValueContactPoint != nil {
		if err := d.DefaultValueContactPoint.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "defaultValueContactPoint"}}); err != nil {
			return err
		}
	}
	if d.DefaultValueCount != nil {
		if err := d.DefaultValueCount.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "defaultValueCount"}}); err != nil {
			return err
		}
	}
	if d.DefaultValueDistance != nil {
		if err := d.DefaultValueDistance.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "defaultValueDistance"}}); err != nil {
			return err
		}
	}
	if d.DefaultValueDuration != nil {
		if err := d.DefaultValueDuration.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "defaultValueDuration"}}); err != nil {
			return err
		}
	}
	if d.DefaultValueHumanName != nil {
		if err := d.DefaultValueHumanName.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "defaultValueHumanName"}}); err != nil {
			return err
		}
	}
	if d.DefaultValueIdentifier != nil {
		if err := d.DefaultValueIdentifier.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "defaultValueIdentifier"}}); err != nil {
			return err
		}
	}
	if d.DefaultValueMoney != nil {
		if err := d.DefaultValueMoney.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "defaultValueMoney"}}); err != nil {
			return err
		}
	}
	if d.DefaultValuePeriod != nil {
		if err := d.DefaultValuePeriod.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "defaultValuePeriod"}}); err != nil {
			return err
		}
	}
	if d.DefaultValueQuantity != nil {
		if err := d.DefaultValueQuantity.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "defaultValueQuantity"}}); err != nil {
			return err
		}
	}
	if d.DefaultValueRange != nil {
		if err := d.DefaultValueRange.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "defaultValueRange"}}); err != nil {
			return err
		}
	}
	if d.DefaultValueRatio != nil {
		if err := d.DefaultValueRatio.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "defaultValueRatio"}}); err != nil {
			return err
		}
	}
	if d.DefaultValueRatioRange != nil {
		if err := d.DefaultValueRatioRange.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "defaultValueRatioRange"}}); err != nil {
			return err
		}
	}
	if d.DefaultValueReference != nil {
		if err := d.DefaultValueReference.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "defaultValueReference"}}); err != nil {
			return err
		}
	}
	if d.DefaultValueSampledData != nil {
		if err := d.DefaultValueSampledData.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "defaultValueSampledData"}}); err != nil {
			return err
		}
	}
	if d.DefaultValueSignature != nil {
		if err := d.DefaultValueSignature.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "defaultValueSignature"}}); err != nil {
			return err
		}
	}
	if d.DefaultValueTiming != nil {
		if err := d.DefaultValueTiming.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "defaultValueTiming"}}); err != nil {
			return err
		}
	}
	if d.DefaultValueContactDetail != nil {
		if err := d.DefaultValueContactDetail.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "defaultValueContactDetail"}}); err != nil {
			return err
		}
	}
	if d.DefaultValueContributor != nil {
		if err := d.DefaultValueContributor.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "defaultValueContributor"}}); err != nil {
			return err
		}
	}
	if d.DefaultValueDataRequirement != nil {
		if err := d.DefaultValueDataRequirement.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "defaultValueDataRequirement"}}); err != nil {
			return err
		}
	}
	if d.DefaultValueExpression != nil {
		if err := d.DefaultValueExpression.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "defaultValueExpression"}}); err != nil {
			return err
		}
	}
	if d.DefaultValueParameterDefinition != nil {
		if err := d.DefaultValueParameterDefinition.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "defaultValueParameterDefinition"}}); err != nil {
			return err
		}
	}
	if d.DefaultValueRelatedArtifact != nil {
		if err := d.DefaultValueRelatedArtifact.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "defaultValueRelatedArtifact"}}); err != nil {
			return err
		}
	}
	if d.DefaultValueTriggerDefinition != nil {
		if err := d.DefaultValueTriggerDefinition.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "defaultValueTriggerDefinition"}}); err != nil {
			return err
		}
	}
	if d.DefaultValueUsageContext != nil {
		if err := d.DefaultValueUsageContext.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "defaultValueUsageContext"}}); err != nil {
			return err
		}
	}
	if d.DefaultValueDosage != nil {
		if err := d.DefaultValueDosage.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "defaultValueDosage"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "meaningWhenMissing", d.MeaningWhenMissing, d.MeaningWhenMissingExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "orderMeaning", d.OrderMeaning, d.OrderMeaningExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "fixedBase64Binary", d.FixedBase64Binary, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveBool(e, "fixedBoolean", d.FixedBoolean, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "fixedCanonical", d.FixedCanonical, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "fixedCode", d.FixedCode, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "fixedDate", d.FixedDate, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "fixedDateTime", d.FixedDateTime, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveDecimal(e, "fixedDecimal", d.FixedDecimal, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "fixedId", d.FixedId, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "fixedInstant", d.FixedInstant, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveInt(e, "fixedInteger", d.FixedInteger, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "fixedMarkdown", d.FixedMarkdown, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "fixedOid", d.FixedOid, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveUint32(e, "fixedPositiveInt", d.FixedPositiveInt, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "fixedString", d.FixedString, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "fixedTime", d.FixedTime, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveUint32(e, "fixedUnsignedInt", d.FixedUnsignedInt, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "fixedUri", d.FixedUri, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "fixedUrl", d.FixedUrl, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "fixedUuid", d.FixedUuid, nil); err != nil {
		return err
	}
	if d.FixedAddress != nil {
		if err := d.FixedAddress.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "fixedAddress"}}); err != nil {
			return err
		}
	}
	if d.FixedAge != nil {
		if err := d.FixedAge.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "fixedAge"}}); err != nil {
			return err
		}
	}
	if d.FixedAnnotation != nil {
		if err := d.FixedAnnotation.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "fixedAnnotation"}}); err != nil {
			return err
		}
	}
	if d.FixedAttachment != nil {
		if err := d.FixedAttachment.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "fixedAttachment"}}); err != nil {
			return err
		}
	}
	if d.FixedCodeableConcept != nil {
		if err := d.FixedCodeableConcept.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "fixedCodeableConcept"}}); err != nil {
			return err
		}
	}
	if d.FixedCodeableReference != nil {
		if err := d.FixedCodeableReference.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "fixedCodeableReference"}}); err != nil {
			return err
		}
	}
	if d.FixedCoding != nil {
		if err := d.FixedCoding.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "fixedCoding"}}); err != nil {
			return err
		}
	}
	if d.FixedContactPoint != nil {
		if err := d.FixedContactPoint.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "fixedContactPoint"}}); err != nil {
			return err
		}
	}
	if d.FixedCount != nil {
		if err := d.FixedCount.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "fixedCount"}}); err != nil {
			return err
		}
	}
	if d.FixedDistance != nil {
		if err := d.FixedDistance.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "fixedDistance"}}); err != nil {
			return err
		}
	}
	if d.FixedDuration != nil {
		if err := d.FixedDuration.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "fixedDuration"}}); err != nil {
			return err
		}
	}
	if d.FixedHumanName != nil {
		if err := d.FixedHumanName.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "fixedHumanName"}}); err != nil {
			return err
		}
	}
	if d.FixedIdentifier != nil {
		if err := d.FixedIdentifier.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "fixedIdentifier"}}); err != nil {
			return err
		}
	}
	if d.FixedMoney != nil {
		if err := d.FixedMoney.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "fixedMoney"}}); err != nil {
			return err
		}
	}
	if d.FixedPeriod != nil {
		if err := d.FixedPeriod.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "fixedPeriod"}}); err != nil {
			return err
		}
	}
	if d.FixedQuantity != nil {
		if err := d.FixedQuantity.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "fixedQuantity"}}); err != nil {
			return err
		}
	}
	if d.FixedRange != nil {
		if err := d.FixedRange.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "fixedRange"}}); err != nil {
			return err
		}
	}
	if d.FixedRatio != nil {
		if err := d.FixedRatio.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "fixedRatio"}}); err != nil {
			return err
		}
	}
	if d.FixedRatioRange != nil {
		if err := d.FixedRatioRange.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "fixedRatioRange"}}); err != nil {
			return err
		}
	}
	if d.FixedReference != nil {
		if err := d.FixedReference.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "fixedReference"}}); err != nil {
			return err
		}
	}
	if d.FixedSampledData != nil {
		if err := d.FixedSampledData.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "fixedSampledData"}}); err != nil {
			return err
		}
	}
	if d.FixedSignature != nil {
		if err := d.FixedSignature.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "fixedSignature"}}); err != nil {
			return err
		}
	}
	if d.FixedTiming != nil {
		if err := d.FixedTiming.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "fixedTiming"}}); err != nil {
			return err
		}
	}
	if d.FixedContactDetail != nil {
		if err := d.FixedContactDetail.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "fixedContactDetail"}}); err != nil {
			return err
		}
	}
	if d.FixedContributor != nil {
		if err := d.FixedContributor.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "fixedContributor"}}); err != nil {
			return err
		}
	}
	if d.FixedDataRequirement != nil {
		if err := d.FixedDataRequirement.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "fixedDataRequirement"}}); err != nil {
			return err
		}
	}
	if d.FixedExpression != nil {
		if err := d.FixedExpression.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "fixedExpression"}}); err != nil {
			return err
		}
	}
	if d.FixedParameterDefinition != nil {
		if err := d.FixedParameterDefinition.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "fixedParameterDefinition"}}); err != nil {
			return err
		}
	}
	if d.FixedRelatedArtifact != nil {
		if err := d.FixedRelatedArtifact.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "fixedRelatedArtifact"}}); err != nil {
			return err
		}
	}
	if d.FixedTriggerDefinition != nil {
		if err := d.FixedTriggerDefinition.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "fixedTriggerDefinition"}}); err != nil {
			return err
		}
	}
	if d.FixedUsageContext != nil {
		if err := d.FixedUsageContext.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "fixedUsageContext"}}); err != nil {
			return err
		}
	}
	if d.FixedDosage != nil {
		if err := d.FixedDosage.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "fixedDosage"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "patternBase64Binary", d.PatternBase64Binary, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveBool(e, "patternBoolean", d.PatternBoolean, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "patternCanonical", d.PatternCanonical, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "patternCode", d.PatternCode, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "patternDate", d.PatternDate, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "patternDateTime", d.PatternDateTime, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveDecimal(e, "patternDecimal", d.PatternDecimal, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "patternId", d.PatternId, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "patternInstant", d.PatternInstant, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveInt(e, "patternInteger", d.PatternInteger, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "patternMarkdown", d.PatternMarkdown, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "patternOid", d.PatternOid, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveUint32(e, "patternPositiveInt", d.PatternPositiveInt, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "patternString", d.PatternString, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "patternTime", d.PatternTime, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveUint32(e, "patternUnsignedInt", d.PatternUnsignedInt, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "patternUri", d.PatternUri, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "patternUrl", d.PatternUrl, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "patternUuid", d.PatternUuid, nil); err != nil {
		return err
	}
	if d.PatternAddress != nil {
		if err := d.PatternAddress.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "patternAddress"}}); err != nil {
			return err
		}
	}
	if d.PatternAge != nil {
		if err := d.PatternAge.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "patternAge"}}); err != nil {
			return err
		}
	}
	if d.PatternAnnotation != nil {
		if err := d.PatternAnnotation.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "patternAnnotation"}}); err != nil {
			return err
		}
	}
	if d.PatternAttachment != nil {
		if err := d.PatternAttachment.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "patternAttachment"}}); err != nil {
			return err
		}
	}
	if d.PatternCodeableConcept != nil {
		if err := d.PatternCodeableConcept.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "patternCodeableConcept"}}); err != nil {
			return err
		}
	}
	if d.PatternCodeableReference != nil {
		if err := d.PatternCodeableReference.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "patternCodeableReference"}}); err != nil {
			return err
		}
	}
	if d.PatternCoding != nil {
		if err := d.PatternCoding.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "patternCoding"}}); err != nil {
			return err
		}
	}
	if d.PatternContactPoint != nil {
		if err := d.PatternContactPoint.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "patternContactPoint"}}); err != nil {
			return err
		}
	}
	if d.PatternCount != nil {
		if err := d.PatternCount.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "patternCount"}}); err != nil {
			return err
		}
	}
	if d.PatternDistance != nil {
		if err := d.PatternDistance.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "patternDistance"}}); err != nil {
			return err
		}
	}
	if d.PatternDuration != nil {
		if err := d.PatternDuration.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "patternDuration"}}); err != nil {
			return err
		}
	}
	if d.PatternHumanName != nil {
		if err := d.PatternHumanName.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "patternHumanName"}}); err != nil {
			return err
		}
	}
	if d.PatternIdentifier != nil {
		if err := d.PatternIdentifier.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "patternIdentifier"}}); err != nil {
			return err
		}
	}
	if d.PatternMoney != nil {
		if err := d.PatternMoney.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "patternMoney"}}); err != nil {
			return err
		}
	}
	if d.PatternPeriod != nil {
		if err := d.PatternPeriod.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "patternPeriod"}}); err != nil {
			return err
		}
	}
	if d.PatternQuantity != nil {
		if err := d.PatternQuantity.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "patternQuantity"}}); err != nil {
			return err
		}
	}
	if d.PatternRange != nil {
		if err := d.PatternRange.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "patternRange"}}); err != nil {
			return err
		}
	}
	if d.PatternRatio != nil {
		if err := d.PatternRatio.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "patternRatio"}}); err != nil {
			return err
		}
	}
	if d.PatternRatioRange != nil {
		if err := d.PatternRatioRange.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "patternRatioRange"}}); err != nil {
			return err
		}
	}
	if d.PatternReference != nil {
		if err := d.PatternReference.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "patternReference"}}); err != nil {
			return err
		}
	}
	if d.PatternSampledData != nil {
		if err := d.PatternSampledData.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "patternSampledData"}}); err != nil {
			return err
		}
	}
	if d.PatternSignature != nil {
		if err := d.PatternSignature.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "patternSignature"}}); err != nil {
			return err
		}
	}
	if d.PatternTiming != nil {
		if err := d.PatternTiming.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "patternTiming"}}); err != nil {
			return err
		}
	}
	if d.PatternContactDetail != nil {
		if err := d.PatternContactDetail.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "patternContactDetail"}}); err != nil {
			return err
		}
	}
	if d.PatternContributor != nil {
		if err := d.PatternContributor.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "patternContributor"}}); err != nil {
			return err
		}
	}
	if d.PatternDataRequirement != nil {
		if err := d.PatternDataRequirement.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "patternDataRequirement"}}); err != nil {
			return err
		}
	}
	if d.PatternExpression != nil {
		if err := d.PatternExpression.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "patternExpression"}}); err != nil {
			return err
		}
	}
	if d.PatternParameterDefinition != nil {
		if err := d.PatternParameterDefinition.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "patternParameterDefinition"}}); err != nil {
			return err
		}
	}
	if d.PatternRelatedArtifact != nil {
		if err := d.PatternRelatedArtifact.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "patternRelatedArtifact"}}); err != nil {
			return err
		}
	}
	if d.PatternTriggerDefinition != nil {
		if err := d.PatternTriggerDefinition.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "patternTriggerDefinition"}}); err != nil {
			return err
		}
	}
	if d.PatternUsageContext != nil {
		if err := d.PatternUsageContext.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "patternUsageContext"}}); err != nil {
			return err
		}
	}
	if d.PatternDosage != nil {
		if err := d.PatternDosage.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "patternDosage"}}); err != nil {
			return err
		}
	}
	for _, item := range d.Example {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "example"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "minValueDate", d.MinValueDate, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "minValueDateTime", d.MinValueDateTime, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "minValueInstant", d.MinValueInstant, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "minValueTime", d.MinValueTime, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveDecimal(e, "minValueDecimal", d.MinValueDecimal, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveInt(e, "minValueInteger", d.MinValueInteger, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveUint32(e, "minValuePositiveInt", d.MinValuePositiveInt, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveUint32(e, "minValueUnsignedInt", d.MinValueUnsignedInt, nil); err != nil {
		return err
	}
	if d.MinValueQuantity != nil {
		if err := d.MinValueQuantity.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "minValueQuantity"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "maxValueDate", d.MaxValueDate, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "maxValueDateTime", d.MaxValueDateTime, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "maxValueInstant", d.MaxValueInstant, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "maxValueTime", d.MaxValueTime, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveDecimal(e, "maxValueDecimal", d.MaxValueDecimal, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveInt(e, "maxValueInteger", d.MaxValueInteger, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveUint32(e, "maxValuePositiveInt", d.MaxValuePositiveInt, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveUint32(e, "maxValueUnsignedInt", d.MaxValueUnsignedInt, nil); err != nil {
		return err
	}
	if d.MaxValueQuantity != nil {
		if err := d.MaxValueQuantity.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "maxValueQuantity"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveInt(e, "maxLength", d.MaxLength, d.MaxLengthExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveStringArray(e, "condition", d.Condition, d.ConditionExt); err != nil {
		return err
	}
	for _, item := range d.Constraint {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "constraint"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveBool(e, "mustSupport", d.MustSupport, d.MustSupportExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveBool(e, "isModifier", d.IsModifier, d.IsModifierExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "isModifierReason", d.IsModifierReason, d.IsModifierReasonExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveBool(e, "isSummary", d.IsSummary, d.IsSummaryExt); err != nil {
		return err
	}
	if d.Binding != nil {
		if err := d.Binding.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "binding"}}); err != nil {
			return err
		}
	}
	for _, item := range d.Mapping {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "mapping"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes Expression to FHIR-conformant XML.
func (d Expression) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Expression"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "description", d.Description, d.DescriptionExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "name", d.Name, d.NameExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "language", d.Language, d.LanguageExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "expression", d.Expression, d.ExpressionExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "reference", d.Reference, d.ReferenceExt); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes Extension to FHIR-conformant XML.
func (d Extension) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Extension"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if d.Url != "" {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "url"}, Value: d.Url})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "valueBase64Binary", d.ValueBase64Binary, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveBool(e, "valueBoolean", d.ValueBoolean, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "valueCanonical", d.ValueCanonical, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "valueCode", d.ValueCode, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "valueDate", d.ValueDate, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "valueDateTime", d.ValueDateTime, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveDecimal(e, "valueDecimal", d.ValueDecimal, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "valueId", d.ValueId, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "valueInstant", d.ValueInstant, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveInt(e, "valueInteger", d.ValueInteger, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "valueMarkdown", d.ValueMarkdown, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "valueOid", d.ValueOid, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveUint32(e, "valuePositiveInt", d.ValuePositiveInt, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "valueString", d.ValueString, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "valueTime", d.ValueTime, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveUint32(e, "valueUnsignedInt", d.ValueUnsignedInt, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "valueUri", d.ValueUri, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "valueUrl", d.ValueUrl, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "valueUuid", d.ValueUuid, nil); err != nil {
		return err
	}
	if d.ValueAddress != nil {
		if err := d.ValueAddress.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueAddress"}}); err != nil {
			return err
		}
	}
	if d.ValueAge != nil {
		if err := d.ValueAge.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueAge"}}); err != nil {
			return err
		}
	}
	if d.ValueAnnotation != nil {
		if err := d.ValueAnnotation.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueAnnotation"}}); err != nil {
			return err
		}
	}
	if d.ValueAttachment != nil {
		if err := d.ValueAttachment.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueAttachment"}}); err != nil {
			return err
		}
	}
	if d.ValueCodeableConcept != nil {
		if err := d.ValueCodeableConcept.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueCodeableConcept"}}); err != nil {
			return err
		}
	}
	if d.ValueCodeableReference != nil {
		if err := d.ValueCodeableReference.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueCodeableReference"}}); err != nil {
			return err
		}
	}
	if d.ValueCoding != nil {
		if err := d.ValueCoding.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueCoding"}}); err != nil {
			return err
		}
	}
	if d.ValueContactPoint != nil {
		if err := d.ValueContactPoint.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueContactPoint"}}); err != nil {
			return err
		}
	}
	if d.ValueCount != nil {
		if err := d.ValueCount.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueCount"}}); err != nil {
			return err
		}
	}
	if d.ValueDistance != nil {
		if err := d.ValueDistance.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueDistance"}}); err != nil {
			return err
		}
	}
	if d.ValueDuration != nil {
		if err := d.ValueDuration.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueDuration"}}); err != nil {
			return err
		}
	}
	if d.ValueHumanName != nil {
		if err := d.ValueHumanName.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueHumanName"}}); err != nil {
			return err
		}
	}
	if d.ValueIdentifier != nil {
		if err := d.ValueIdentifier.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueIdentifier"}}); err != nil {
			return err
		}
	}
	if d.ValueMoney != nil {
		if err := d.ValueMoney.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueMoney"}}); err != nil {
			return err
		}
	}
	if d.ValuePeriod != nil {
		if err := d.ValuePeriod.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valuePeriod"}}); err != nil {
			return err
		}
	}
	if d.ValueQuantity != nil {
		if err := d.ValueQuantity.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueQuantity"}}); err != nil {
			return err
		}
	}
	if d.ValueRange != nil {
		if err := d.ValueRange.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueRange"}}); err != nil {
			return err
		}
	}
	if d.ValueRatio != nil {
		if err := d.ValueRatio.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueRatio"}}); err != nil {
			return err
		}
	}
	if d.ValueRatioRange != nil {
		if err := d.ValueRatioRange.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueRatioRange"}}); err != nil {
			return err
		}
	}
	if d.ValueReference != nil {
		if err := d.ValueReference.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueReference"}}); err != nil {
			return err
		}
	}
	if d.ValueSampledData != nil {
		if err := d.ValueSampledData.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueSampledData"}}); err != nil {
			return err
		}
	}
	if d.ValueSignature != nil {
		if err := d.ValueSignature.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueSignature"}}); err != nil {
			return err
		}
	}
	if d.ValueTiming != nil {
		if err := d.ValueTiming.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueTiming"}}); err != nil {
			return err
		}
	}
	if d.ValueContactDetail != nil {
		if err := d.ValueContactDetail.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueContactDetail"}}); err != nil {
			return err
		}
	}
	if d.ValueContributor != nil {
		if err := d.ValueContributor.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueContributor"}}); err != nil {
			return err
		}
	}
	if d.ValueDataRequirement != nil {
		if err := d.ValueDataRequirement.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueDataRequirement"}}); err != nil {
			return err
		}
	}
	if d.ValueExpression != nil {
		if err := d.ValueExpression.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueExpression"}}); err != nil {
			return err
		}
	}
	if d.ValueParameterDefinition != nil {
		if err := d.ValueParameterDefinition.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueParameterDefinition"}}); err != nil {
			return err
		}
	}
	if d.ValueRelatedArtifact != nil {
		if err := d.ValueRelatedArtifact.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueRelatedArtifact"}}); err != nil {
			return err
		}
	}
	if d.ValueTriggerDefinition != nil {
		if err := d.ValueTriggerDefinition.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueTriggerDefinition"}}); err != nil {
			return err
		}
	}
	if d.ValueUsageContext != nil {
		if err := d.ValueUsageContext.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueUsageContext"}}); err != nil {
			return err
		}
	}
	if d.ValueDosage != nil {
		if err := d.ValueDosage.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueDosage"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes HumanName to FHIR-conformant XML.
func (d HumanName) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "HumanName"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveCode(e, "use", d.Use, d.UseExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "text", d.Text, d.TextExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "family", d.Family, d.FamilyExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveStringArray(e, "given", d.Given, d.GivenExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveStringArray(e, "prefix", d.Prefix, d.PrefixExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveStringArray(e, "suffix", d.Suffix, d.SuffixExt); err != nil {
		return err
	}
	if d.Period != nil {
		if err := d.Period.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "period"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes Identifier to FHIR-conformant XML.
func (d Identifier) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Identifier"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveCode(e, "use", d.Use, d.UseExt); err != nil {
		return err
	}
	if d.Type != nil {
		if err := d.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "system", d.System, d.SystemExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "value", d.Value, d.ValueExt); err != nil {
		return err
	}
	if d.Period != nil {
		if err := d.Period.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "period"}}); err != nil {
			return err
		}
	}
	if d.Assigner != nil {
		if err := d.Assigner.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "assigner"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes MarketingStatus to FHIR-conformant XML.
func (d MarketingStatus) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MarketingStatus"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range d.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if d.Country != nil {
		if err := d.Country.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "country"}}); err != nil {
			return err
		}
	}
	if d.Jurisdiction != nil {
		if err := d.Jurisdiction.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "jurisdiction"}}); err != nil {
			return err
		}
	}
	if err := d.Status.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "status"}}); err != nil {
		return err
	}
	if d.DateRange != nil {
		if err := d.DateRange.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "dateRange"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "restoreDate", d.RestoreDate, d.RestoreDateExt); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes Meta to FHIR-conformant XML.
func (d Meta) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Meta"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "versionId", d.VersionId, d.VersionIdExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "lastUpdated", d.LastUpdated, d.LastUpdatedExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "source", d.Source, d.SourceExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveStringArray(e, "profile", d.Profile, d.ProfileExt); err != nil {
		return err
	}
	for _, item := range d.Security {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "security"}}); err != nil {
			return err
		}
	}
	for _, item := range d.Tag {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "tag"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes Money to FHIR-conformant XML.
func (d Money) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Money"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveDecimal(e, "value", d.Value, d.ValueExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "currency", d.Currency, d.CurrencyExt); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes Narrative to FHIR-conformant XML.
func (d Narrative) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Narrative"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveCode(e, "status", d.Status, d.StatusExt); err != nil {
		return err
	}
	if err := xmlEncodeRawXHTML(e, d.Div); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes ParameterDefinition to FHIR-conformant XML.
func (d ParameterDefinition) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "ParameterDefinition"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "name", d.Name, d.NameExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveCode(e, "use", d.Use, d.UseExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveInt(e, "min", d.Min, d.MinExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "max", d.Max, d.MaxExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "documentation", d.Documentation, d.DocumentationExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "type", d.Type, d.TypeExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "profile", d.Profile, d.ProfileExt); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes Period to FHIR-conformant XML.
func (d Period) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Period"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "start", d.Start, d.StartExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "end", d.End, d.EndExt); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes Population to FHIR-conformant XML.
func (d Population) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Population"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range d.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if d.AgeRange != nil {
		if err := d.AgeRange.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "ageRange"}}); err != nil {
			return err
		}
	}
	if d.AgeCodeableConcept != nil {
		if err := d.AgeCodeableConcept.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "ageCodeableConcept"}}); err != nil {
			return err
		}
	}
	if d.Gender != nil {
		if err := d.Gender.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "gender"}}); err != nil {
			return err
		}
	}
	if d.Race != nil {
		if err := d.Race.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "race"}}); err != nil {
			return err
		}
	}
	if d.PhysiologicalCondition != nil {
		if err := d.PhysiologicalCondition.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "physiologicalCondition"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes ProdCharacteristic to FHIR-conformant XML.
func (d ProdCharacteristic) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "ProdCharacteristic"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range d.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if d.Height != nil {
		if err := d.Height.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "height"}}); err != nil {
			return err
		}
	}
	if d.Width != nil {
		if err := d.Width.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "width"}}); err != nil {
			return err
		}
	}
	if d.Depth != nil {
		if err := d.Depth.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "depth"}}); err != nil {
			return err
		}
	}
	if d.Weight != nil {
		if err := d.Weight.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "weight"}}); err != nil {
			return err
		}
	}
	if d.NominalVolume != nil {
		if err := d.NominalVolume.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "nominalVolume"}}); err != nil {
			return err
		}
	}
	if d.ExternalDiameter != nil {
		if err := d.ExternalDiameter.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "externalDiameter"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "shape", d.Shape, d.ShapeExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveStringArray(e, "color", d.Color, d.ColorExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveStringArray(e, "imprint", d.Imprint, d.ImprintExt); err != nil {
		return err
	}
	for _, item := range d.Image {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "image"}}); err != nil {
			return err
		}
	}
	if d.Scoring != nil {
		if err := d.Scoring.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "scoring"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes ProductShelfLife to FHIR-conformant XML.
func (d ProductShelfLife) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "ProductShelfLife"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range d.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if d.Identifier != nil {
		if err := d.Identifier.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "identifier"}}); err != nil {
			return err
		}
	}
	if err := d.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
		return err
	}
	if err := d.Period.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "period"}}); err != nil {
		return err
	}
	for _, item := range d.SpecialPrecautionsForStorage {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "specialPrecautionsForStorage"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes Quantity to FHIR-conformant XML.
func (d Quantity) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Quantity"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveDecimal(e, "value", d.Value, d.ValueExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveCode(e, "comparator", d.Comparator, d.ComparatorExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "unit", d.Unit, d.UnitExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "system", d.System, d.SystemExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "code", d.Code, d.CodeExt); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes Range to FHIR-conformant XML.
func (d Range) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Range"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if d.Low != nil {
		if err := d.Low.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "low"}}); err != nil {
			return err
		}
	}
	if d.High != nil {
		if err := d.High.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "high"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes Ratio to FHIR-conformant XML.
func (d Ratio) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Ratio"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if d.Numerator != nil {
		if err := d.Numerator.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "numerator"}}); err != nil {
			return err
		}
	}
	if d.Denominator != nil {
		if err := d.Denominator.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "denominator"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes RatioRange to FHIR-conformant XML.
func (d RatioRange) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "RatioRange"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if d.LowNumerator != nil {
		if err := d.LowNumerator.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "lowNumerator"}}); err != nil {
			return err
		}
	}
	if d.HighNumerator != nil {
		if err := d.HighNumerator.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "highNumerator"}}); err != nil {
			return err
		}
	}
	if d.Denominator != nil {
		if err := d.Denominator.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "denominator"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes Reference to FHIR-conformant XML.
func (d Reference) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Reference"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "reference", d.Reference, d.ReferenceExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "type", d.Type, d.TypeExt); err != nil {
		return err
	}
	if d.Identifier != nil {
		if err := d.Identifier.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "identifier"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "display", d.Display, d.DisplayExt); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes RelatedArtifact to FHIR-conformant XML.
func (d RelatedArtifact) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "RelatedArtifact"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveCode(e, "type", d.Type, d.TypeExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "label", d.Label, d.LabelExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "display", d.Display, d.DisplayExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "citation", d.Citation, d.CitationExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "url", d.Url, d.UrlExt); err != nil {
		return err
	}
	if d.Document != nil {
		if err := d.Document.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "document"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "resource", d.Resource, d.ResourceExt); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes SampledData to FHIR-conformant XML.
func (d SampledData) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "SampledData"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if err := d.Origin.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "origin"}}); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveDecimal(e, "period", d.Period, d.PeriodExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveDecimal(e, "factor", d.Factor, d.FactorExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveDecimal(e, "lowerLimit", d.LowerLimit, d.LowerLimitExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveDecimal(e, "upperLimit", d.UpperLimit, d.UpperLimitExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveUint32(e, "dimensions", d.Dimensions, d.DimensionsExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "data", d.Data, d.DataExt); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes Signature to FHIR-conformant XML.
func (d Signature) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Signature"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range d.Type {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "when", d.When, d.WhenExt); err != nil {
		return err
	}
	if err := d.Who.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "who"}}); err != nil {
		return err
	}
	if d.OnBehalfOf != nil {
		if err := d.OnBehalfOf.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "onBehalfOf"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "targetFormat", d.TargetFormat, d.TargetFormatExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "sigFormat", d.SigFormat, d.SigFormatExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "data", d.Data, d.DataExt); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes Timing to FHIR-conformant XML.
func (d Timing) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Timing"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range d.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveStringArray(e, "event", d.Event, d.EventExt); err != nil {
		return err
	}
	if d.Repeat != nil {
		if err := d.Repeat.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "repeat"}}); err != nil {
			return err
		}
	}
	if d.Code != nil {
		if err := d.Code.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "code"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes TriggerDefinition to FHIR-conformant XML.
func (d TriggerDefinition) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "TriggerDefinition"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveCode(e, "type", d.Type, d.TypeExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "name", d.Name, d.NameExt); err != nil {
		return err
	}
	if d.TimingTiming != nil {
		if err := d.TimingTiming.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "timingTiming"}}); err != nil {
			return err
		}
	}
	if d.TimingReference != nil {
		if err := d.TimingReference.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "timingReference"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "timingDate", d.TimingDate, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "timingDateTime", d.TimingDateTime, nil); err != nil {
		return err
	}
	for _, item := range d.Data {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "data"}}); err != nil {
			return err
		}
	}
	if d.Condition != nil {
		if err := d.Condition.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "condition"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes UsageContext to FHIR-conformant XML.
func (d UsageContext) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "UsageContext"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if err := d.Code.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "code"}}); err != nil {
		return err
	}
	if d.ValueCodeableConcept != nil {
		if err := d.ValueCodeableConcept.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueCodeableConcept"}}); err != nil {
			return err
		}
	}
	if d.ValueQuantity != nil {
		if err := d.ValueQuantity.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueQuantity"}}); err != nil {
			return err
		}
	}
	if d.ValueRange != nil {
		if err := d.ValueRange.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueRange"}}); err != nil {
			return err
		}
	}
	if d.ValueReference != nil {
		if err := d.ValueReference.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueReference"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes MoneyQuantity to FHIR-conformant XML.
func (d MoneyQuantity) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MoneyQuantity"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveDecimal(e, "value", d.Value, d.ValueExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveCode(e, "comparator", d.Comparator, d.ComparatorExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "unit", d.Unit, d.UnitExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "system", d.System, d.SystemExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "code", d.Code, d.CodeExt); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes SimpleQuantity to FHIR-conformant XML.
func (d SimpleQuantity) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "SimpleQuantity"
	}
	if d.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *d.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range d.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveDecimal(e, "value", d.Value, d.ValueExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveCode(e, "comparator", d.Comparator, d.ComparatorExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "unit", d.Unit, d.UnitExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "system", d.System, d.SystemExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "code", d.Code, d.CodeExt); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// =============================================================================
// Backbone XML Serialization (for datatype backbones)
// =============================================================================

// MarshalXML serializes DataRequirementCodeFilter to FHIR-conformant XML.
func (b DataRequirementCodeFilter) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "DataRequirement.codeFilter"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "path", b.Path, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "searchParam", b.SearchParam, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "valueSet", b.ValueSet, nil); err != nil {
		return err
	}
	for _, item := range b.Code {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "code"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes DataRequirementDateFilter to FHIR-conformant XML.
func (b DataRequirementDateFilter) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "DataRequirement.dateFilter"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "path", b.Path, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "searchParam", b.SearchParam, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "valueDateTime", b.ValueDateTime, nil); err != nil {
		return err
	}
	if b.ValuePeriod != nil {
		if err := b.ValuePeriod.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valuePeriod"}}); err != nil {
			return err
		}
	}
	if b.ValueDuration != nil {
		if err := b.ValueDuration.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueDuration"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes DataRequirementSort to FHIR-conformant XML.
func (b DataRequirementSort) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "DataRequirement.sort"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "path", b.Path, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveCode(e, "direction", b.Direction, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes DosageDoseAndRate to FHIR-conformant XML.
func (b DosageDoseAndRate) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Dosage.doseAndRate"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if b.Type != nil {
		if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
			return err
		}
	}
	if b.DoseRange != nil {
		if err := b.DoseRange.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "doseRange"}}); err != nil {
			return err
		}
	}
	if b.DoseQuantity != nil {
		if err := b.DoseQuantity.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "doseQuantity"}}); err != nil {
			return err
		}
	}
	if b.RateRatio != nil {
		if err := b.RateRatio.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "rateRatio"}}); err != nil {
			return err
		}
	}
	if b.RateRange != nil {
		if err := b.RateRange.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "rateRange"}}); err != nil {
			return err
		}
	}
	if b.RateQuantity != nil {
		if err := b.RateQuantity.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "rateQuantity"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes ElementDefinitionBase to FHIR-conformant XML.
func (b ElementDefinitionBase) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "ElementDefinition.base"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "path", b.Path, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveUint32(e, "min", b.Min, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "max", b.Max, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes ElementDefinitionBinding to FHIR-conformant XML.
func (b ElementDefinitionBinding) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "ElementDefinition.binding"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveCode(e, "strength", b.Strength, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "description", b.Description, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "valueSet", b.ValueSet, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes ElementDefinitionConstraint to FHIR-conformant XML.
func (b ElementDefinitionConstraint) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "ElementDefinition.constraint"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "key", b.Key, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "requirements", b.Requirements, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveCode(e, "severity", b.Severity, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "human", b.Human, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "expression", b.Expression, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "xpath", b.Xpath, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "source", b.Source, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes ElementDefinitionExample to FHIR-conformant XML.
func (b ElementDefinitionExample) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "ElementDefinition.example"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "label", b.Label, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "valueBase64Binary", b.ValueBase64Binary, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveBool(e, "valueBoolean", b.ValueBoolean, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "valueCanonical", b.ValueCanonical, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "valueCode", b.ValueCode, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "valueDate", b.ValueDate, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "valueDateTime", b.ValueDateTime, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveDecimal(e, "valueDecimal", b.ValueDecimal, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "valueId", b.ValueId, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "valueInstant", b.ValueInstant, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveInt(e, "valueInteger", b.ValueInteger, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "valueMarkdown", b.ValueMarkdown, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "valueOid", b.ValueOid, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveUint32(e, "valuePositiveInt", b.ValuePositiveInt, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "valueString", b.ValueString, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "valueTime", b.ValueTime, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveUint32(e, "valueUnsignedInt", b.ValueUnsignedInt, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "valueUri", b.ValueUri, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "valueUrl", b.ValueUrl, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "valueUuid", b.ValueUuid, nil); err != nil {
		return err
	}
	if b.ValueAddress != nil {
		if err := b.ValueAddress.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueAddress"}}); err != nil {
			return err
		}
	}
	if b.ValueAge != nil {
		if err := b.ValueAge.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueAge"}}); err != nil {
			return err
		}
	}
	if b.ValueAnnotation != nil {
		if err := b.ValueAnnotation.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueAnnotation"}}); err != nil {
			return err
		}
	}
	if b.ValueAttachment != nil {
		if err := b.ValueAttachment.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueAttachment"}}); err != nil {
			return err
		}
	}
	if b.ValueCodeableConcept != nil {
		if err := b.ValueCodeableConcept.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueCodeableConcept"}}); err != nil {
			return err
		}
	}
	if b.ValueCodeableReference != nil {
		if err := b.ValueCodeableReference.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueCodeableReference"}}); err != nil {
			return err
		}
	}
	if b.ValueCoding != nil {
		if err := b.ValueCoding.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueCoding"}}); err != nil {
			return err
		}
	}
	if b.ValueContactPoint != nil {
		if err := b.ValueContactPoint.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueContactPoint"}}); err != nil {
			return err
		}
	}
	if b.ValueCount != nil {
		if err := b.ValueCount.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueCount"}}); err != nil {
			return err
		}
	}
	if b.ValueDistance != nil {
		if err := b.ValueDistance.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueDistance"}}); err != nil {
			return err
		}
	}
	if b.ValueDuration != nil {
		if err := b.ValueDuration.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueDuration"}}); err != nil {
			return err
		}
	}
	if b.ValueHumanName != nil {
		if err := b.ValueHumanName.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueHumanName"}}); err != nil {
			return err
		}
	}
	if b.ValueIdentifier != nil {
		if err := b.ValueIdentifier.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueIdentifier"}}); err != nil {
			return err
		}
	}
	if b.ValueMoney != nil {
		if err := b.ValueMoney.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueMoney"}}); err != nil {
			return err
		}
	}
	if b.ValuePeriod != nil {
		if err := b.ValuePeriod.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valuePeriod"}}); err != nil {
			return err
		}
	}
	if b.ValueQuantity != nil {
		if err := b.ValueQuantity.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueQuantity"}}); err != nil {
			return err
		}
	}
	if b.ValueRange != nil {
		if err := b.ValueRange.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueRange"}}); err != nil {
			return err
		}
	}
	if b.ValueRatio != nil {
		if err := b.ValueRatio.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueRatio"}}); err != nil {
			return err
		}
	}
	if b.ValueRatioRange != nil {
		if err := b.ValueRatioRange.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueRatioRange"}}); err != nil {
			return err
		}
	}
	if b.ValueReference != nil {
		if err := b.ValueReference.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueReference"}}); err != nil {
			return err
		}
	}
	if b.ValueSampledData != nil {
		if err := b.ValueSampledData.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueSampledData"}}); err != nil {
			return err
		}
	}
	if b.ValueSignature != nil {
		if err := b.ValueSignature.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueSignature"}}); err != nil {
			return err
		}
	}
	if b.ValueTiming != nil {
		if err := b.ValueTiming.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueTiming"}}); err != nil {
			return err
		}
	}
	if b.ValueContactDetail != nil {
		if err := b.ValueContactDetail.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueContactDetail"}}); err != nil {
			return err
		}
	}
	if b.ValueContributor != nil {
		if err := b.ValueContributor.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueContributor"}}); err != nil {
			return err
		}
	}
	if b.ValueDataRequirement != nil {
		if err := b.ValueDataRequirement.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueDataRequirement"}}); err != nil {
			return err
		}
	}
	if b.ValueExpression != nil {
		if err := b.ValueExpression.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueExpression"}}); err != nil {
			return err
		}
	}
	if b.ValueParameterDefinition != nil {
		if err := b.ValueParameterDefinition.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueParameterDefinition"}}); err != nil {
			return err
		}
	}
	if b.ValueRelatedArtifact != nil {
		if err := b.ValueRelatedArtifact.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueRelatedArtifact"}}); err != nil {
			return err
		}
	}
	if b.ValueTriggerDefinition != nil {
		if err := b.ValueTriggerDefinition.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueTriggerDefinition"}}); err != nil {
			return err
		}
	}
	if b.ValueUsageContext != nil {
		if err := b.ValueUsageContext.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueUsageContext"}}); err != nil {
			return err
		}
	}
	if b.ValueDosage != nil {
		if err := b.ValueDosage.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueDosage"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes ElementDefinitionMapping to FHIR-conformant XML.
func (b ElementDefinitionMapping) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "ElementDefinition.mapping"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "identity", b.Identity, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "language", b.Language, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "map", b.Map, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "comment", b.Comment, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes ElementDefinitionSlicing to FHIR-conformant XML.
func (b ElementDefinitionSlicing) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "ElementDefinition.slicing"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Discriminator {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "discriminator"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "description", b.Description, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveBool(e, "ordered", b.Ordered, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveCode(e, "rules", b.Rules, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes ElementDefinitionSlicingDiscriminator to FHIR-conformant XML.
func (b ElementDefinitionSlicingDiscriminator) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "ElementDefinition.slicing.discriminator"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveCode(e, "type", b.Type, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "path", b.Path, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes ElementDefinitionType to FHIR-conformant XML.
func (b ElementDefinitionType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "ElementDefinition.type"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "code", b.Code, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveStringArray(e, "profile", b.Profile, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveStringArray(e, "targetProfile", b.TargetProfile, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveCodeArray(e, "aggregation", b.Aggregation, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveCode(e, "versioning", b.Versioning, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// MarshalXML serializes TimingRepeat to FHIR-conformant XML.
func (b TimingRepeat) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Timing.repeat"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	if b.BoundsDuration != nil {
		if err := b.BoundsDuration.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "boundsDuration"}}); err != nil {
			return err
		}
	}
	if b.BoundsRange != nil {
		if err := b.BoundsRange.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "boundsRange"}}); err != nil {
			return err
		}
	}
	if b.BoundsPeriod != nil {
		if err := b.BoundsPeriod.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "boundsPeriod"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveUint32(e, "count", b.Count, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveUint32(e, "countMax", b.CountMax, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveDecimal(e, "duration", b.Duration, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveDecimal(e, "durationMax", b.DurationMax, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveCode(e, "durationUnit", b.DurationUnit, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveUint32(e, "frequency", b.Frequency, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveUint32(e, "frequencyMax", b.FrequencyMax, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveDecimal(e, "period", b.Period, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveDecimal(e, "periodMax", b.PeriodMax, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveCode(e, "periodUnit", b.PeriodUnit, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveCodeArray(e, "dayOfWeek", b.DayOfWeek, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveStringArray(e, "timeOfDay", b.TimeOfDay, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveCodeArray(e, "when", b.When, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveUint32(e, "offset", b.Offset, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// =============================================================================
// Datatype XML Deserialization
// =============================================================================

// UnmarshalXML deserializes Element from FHIR-conformant XML.
func (r *Element) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes BackboneElement from FHIR-conformant XML.
func (r *BackboneElement) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes Address from FHIR-conformant XML.
func (r *Address) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "use":
				v, ext, err := xmlDecodePrimitiveCode[AddressUse](dec, t)
				if err != nil {
					return err
				}
				r.Use = v
				r.UseExt = ext
			case "type":
				v, ext, err := xmlDecodePrimitiveCode[AddressType](dec, t)
				if err != nil {
					return err
				}
				r.Type = v
				r.TypeExt = ext
			case "text":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Text = v
				r.TextExt = ext
			case "line":
				v, _, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.Line = append(r.Line, *v)
				}
			case "city":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.City = v
				r.CityExt = ext
			case "district":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.District = v
				r.DistrictExt = ext
			case "state":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.State = v
				r.StateExt = ext
			case "postalCode":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.PostalCode = v
				r.PostalCodeExt = ext
			case "country":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Country = v
				r.CountryExt = ext
			case "period":
				var v Period
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Period = &v
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes Age from FHIR-conformant XML.
func (r *Age) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "value":
				v, ext, err := xmlDecodePrimitiveDecimal(dec, t)
				if err != nil {
					return err
				}
				r.Value = v
				r.ValueExt = ext
			case "comparator":
				v, ext, err := xmlDecodePrimitiveCode[QuantityComparator](dec, t)
				if err != nil {
					return err
				}
				r.Comparator = v
				r.ComparatorExt = ext
			case "unit":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Unit = v
				r.UnitExt = ext
			case "system":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.System = v
				r.SystemExt = ext
			case "code":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Code = v
				r.CodeExt = ext
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes Annotation from FHIR-conformant XML.
func (r *Annotation) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "authorReference":
				var v Reference
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.AuthorReference = &v
			case "authorString":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.AuthorString = v
				_ = ext
			case "time":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Time = v
				r.TimeExt = ext
			case "text":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Text = v
				r.TextExt = ext
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes Attachment from FHIR-conformant XML.
func (r *Attachment) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "contentType":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.ContentType = v
				r.ContentTypeExt = ext
			case "language":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Language = v
				r.LanguageExt = ext
			case "data":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Data = v
				r.DataExt = ext
			case "url":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Url = v
				r.UrlExt = ext
			case "size":
				v, ext, err := xmlDecodePrimitiveUint32(dec, t)
				if err != nil {
					return err
				}
				r.Size = v
				r.SizeExt = ext
			case "hash":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Hash = v
				r.HashExt = ext
			case "title":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Title = v
				r.TitleExt = ext
			case "creation":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Creation = v
				r.CreationExt = ext
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes CodeableConcept from FHIR-conformant XML.
func (r *CodeableConcept) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "coding":
				var v Coding
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Coding = append(r.Coding, v)
			case "text":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Text = v
				r.TextExt = ext
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes CodeableReference from FHIR-conformant XML.
func (r *CodeableReference) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "concept":
				var v CodeableConcept
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Concept = &v
			case "reference":
				var v Reference
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Reference = &v
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes Coding from FHIR-conformant XML.
func (r *Coding) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "system":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.System = v
				r.SystemExt = ext
			case "version":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Version = v
				r.VersionExt = ext
			case "code":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Code = v
				r.CodeExt = ext
			case "display":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Display = v
				r.DisplayExt = ext
			case "userSelected":
				v, ext, err := xmlDecodePrimitiveBool(dec, t)
				if err != nil {
					return err
				}
				r.UserSelected = v
				r.UserSelectedExt = ext
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes ContactDetail from FHIR-conformant XML.
func (r *ContactDetail) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "name":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Name = v
				r.NameExt = ext
			case "telecom":
				var v ContactPoint
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Telecom = append(r.Telecom, v)
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes ContactPoint from FHIR-conformant XML.
func (r *ContactPoint) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "system":
				v, ext, err := xmlDecodePrimitiveCode[ContactPointSystem](dec, t)
				if err != nil {
					return err
				}
				r.System = v
				r.SystemExt = ext
			case "value":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Value = v
				r.ValueExt = ext
			case "use":
				v, ext, err := xmlDecodePrimitiveCode[ContactPointUse](dec, t)
				if err != nil {
					return err
				}
				r.Use = v
				r.UseExt = ext
			case "rank":
				v, ext, err := xmlDecodePrimitiveUint32(dec, t)
				if err != nil {
					return err
				}
				r.Rank = v
				r.RankExt = ext
			case "period":
				var v Period
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Period = &v
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes Contributor from FHIR-conformant XML.
func (r *Contributor) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "type":
				v, ext, err := xmlDecodePrimitiveCode[ContributorType](dec, t)
				if err != nil {
					return err
				}
				r.Type = v
				r.TypeExt = ext
			case "name":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Name = v
				r.NameExt = ext
			case "contact":
				var v ContactDetail
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Contact = append(r.Contact, v)
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes Count from FHIR-conformant XML.
func (r *Count) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "value":
				v, ext, err := xmlDecodePrimitiveDecimal(dec, t)
				if err != nil {
					return err
				}
				r.Value = v
				r.ValueExt = ext
			case "comparator":
				v, ext, err := xmlDecodePrimitiveCode[QuantityComparator](dec, t)
				if err != nil {
					return err
				}
				r.Comparator = v
				r.ComparatorExt = ext
			case "unit":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Unit = v
				r.UnitExt = ext
			case "system":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.System = v
				r.SystemExt = ext
			case "code":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Code = v
				r.CodeExt = ext
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes DataRequirement from FHIR-conformant XML.
func (r *DataRequirement) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "type":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Type = v
				r.TypeExt = ext
			case "profile":
				v, _, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.Profile = append(r.Profile, *v)
				}
			case "subjectCodeableConcept":
				var v CodeableConcept
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.SubjectCodeableConcept = &v
			case "subjectReference":
				var v Reference
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.SubjectReference = &v
			case "mustSupport":
				v, _, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.MustSupport = append(r.MustSupport, *v)
				}
			case "codeFilter":
				var v DataRequirementCodeFilter
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.CodeFilter = append(r.CodeFilter, v)
			case "dateFilter":
				var v DataRequirementDateFilter
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.DateFilter = append(r.DateFilter, v)
			case "limit":
				v, ext, err := xmlDecodePrimitiveUint32(dec, t)
				if err != nil {
					return err
				}
				r.Limit = v
				r.LimitExt = ext
			case "sort":
				var v DataRequirementSort
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Sort = append(r.Sort, v)
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes Distance from FHIR-conformant XML.
func (r *Distance) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "value":
				v, ext, err := xmlDecodePrimitiveDecimal(dec, t)
				if err != nil {
					return err
				}
				r.Value = v
				r.ValueExt = ext
			case "comparator":
				v, ext, err := xmlDecodePrimitiveCode[QuantityComparator](dec, t)
				if err != nil {
					return err
				}
				r.Comparator = v
				r.ComparatorExt = ext
			case "unit":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Unit = v
				r.UnitExt = ext
			case "system":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.System = v
				r.SystemExt = ext
			case "code":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Code = v
				r.CodeExt = ext
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes Dosage from FHIR-conformant XML.
func (r *Dosage) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "sequence":
				v, ext, err := xmlDecodePrimitiveInt(dec, t)
				if err != nil {
					return err
				}
				r.Sequence = v
				r.SequenceExt = ext
			case "text":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Text = v
				r.TextExt = ext
			case "additionalInstruction":
				var v CodeableConcept
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.AdditionalInstruction = append(r.AdditionalInstruction, v)
			case "patientInstruction":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.PatientInstruction = v
				r.PatientInstructionExt = ext
			case "timing":
				var v Timing
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Timing = &v
			case "asNeededBoolean":
				v, ext, err := xmlDecodePrimitiveBool(dec, t)
				if err != nil {
					return err
				}
				r.AsNeededBoolean = v
				_ = ext
			case "asNeededCodeableConcept":
				var v CodeableConcept
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.AsNeededCodeableConcept = &v
			case "site":
				var v CodeableConcept
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Site = &v
			case "route":
				var v CodeableConcept
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Route = &v
			case "method":
				var v CodeableConcept
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Method = &v
			case "doseAndRate":
				var v DosageDoseAndRate
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.DoseAndRate = append(r.DoseAndRate, v)
			case "maxDosePerPeriod":
				var v Ratio
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.MaxDosePerPeriod = &v
			case "maxDosePerAdministration":
				var v Quantity
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.MaxDosePerAdministration = &v
			case "maxDosePerLifetime":
				var v Quantity
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.MaxDosePerLifetime = &v
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes Duration from FHIR-conformant XML.
func (r *Duration) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "value":
				v, ext, err := xmlDecodePrimitiveDecimal(dec, t)
				if err != nil {
					return err
				}
				r.Value = v
				r.ValueExt = ext
			case "comparator":
				v, ext, err := xmlDecodePrimitiveCode[QuantityComparator](dec, t)
				if err != nil {
					return err
				}
				r.Comparator = v
				r.ComparatorExt = ext
			case "unit":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Unit = v
				r.UnitExt = ext
			case "system":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.System = v
				r.SystemExt = ext
			case "code":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Code = v
				r.CodeExt = ext
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes ElementDefinition from FHIR-conformant XML.
func (r *ElementDefinition) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "path":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Path = v
				r.PathExt = ext
			case "representation":
				v, _, err := xmlDecodePrimitiveCode[PropertyRepresentation](dec, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.Representation = append(r.Representation, *v)
				}
			case "sliceName":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.SliceName = v
				r.SliceNameExt = ext
			case "sliceIsConstraining":
				v, ext, err := xmlDecodePrimitiveBool(dec, t)
				if err != nil {
					return err
				}
				r.SliceIsConstraining = v
				r.SliceIsConstrainingExt = ext
			case "label":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Label = v
				r.LabelExt = ext
			case "code":
				var v Coding
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Code = append(r.Code, v)
			case "slicing":
				var v ElementDefinitionSlicing
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Slicing = &v
			case "short":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Short = v
				r.ShortExt = ext
			case "definition":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Definition = v
				r.DefinitionExt = ext
			case "comment":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Comment = v
				r.CommentExt = ext
			case "requirements":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Requirements = v
				r.RequirementsExt = ext
			case "alias":
				v, _, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.Alias = append(r.Alias, *v)
				}
			case "min":
				v, ext, err := xmlDecodePrimitiveUint32(dec, t)
				if err != nil {
					return err
				}
				r.Min = v
				r.MinExt = ext
			case "max":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Max = v
				r.MaxExt = ext
			case "base":
				var v ElementDefinitionBase
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Base = &v
			case "contentReference":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.ContentReference = v
				r.ContentReferenceExt = ext
			case "type":
				var v ElementDefinitionType
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Type = append(r.Type, v)
			case "defaultValueBase64Binary":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.DefaultValueBase64Binary = v
				_ = ext
			case "defaultValueBoolean":
				v, ext, err := xmlDecodePrimitiveBool(dec, t)
				if err != nil {
					return err
				}
				r.DefaultValueBoolean = v
				_ = ext
			case "defaultValueCanonical":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.DefaultValueCanonical = v
				_ = ext
			case "defaultValueCode":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.DefaultValueCode = v
				_ = ext
			case "defaultValueDate":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.DefaultValueDate = v
				_ = ext
			case "defaultValueDateTime":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.DefaultValueDateTime = v
				_ = ext
			case "defaultValueDecimal":
				v, ext, err := xmlDecodePrimitiveDecimal(dec, t)
				if err != nil {
					return err
				}
				r.DefaultValueDecimal = v
				_ = ext
			case "defaultValueId":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.DefaultValueId = v
				_ = ext
			case "defaultValueInstant":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.DefaultValueInstant = v
				_ = ext
			case "defaultValueInteger":
				v, ext, err := xmlDecodePrimitiveInt(dec, t)
				if err != nil {
					return err
				}
				r.DefaultValueInteger = v
				_ = ext
			case "defaultValueMarkdown":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.DefaultValueMarkdown = v
				_ = ext
			case "defaultValueOid":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.DefaultValueOid = v
				_ = ext
			case "defaultValuePositiveInt":
				v, ext, err := xmlDecodePrimitiveUint32(dec, t)
				if err != nil {
					return err
				}
				r.DefaultValuePositiveInt = v
				_ = ext
			case "defaultValueString":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.DefaultValueString = v
				_ = ext
			case "defaultValueTime":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.DefaultValueTime = v
				_ = ext
			case "defaultValueUnsignedInt":
				v, ext, err := xmlDecodePrimitiveUint32(dec, t)
				if err != nil {
					return err
				}
				r.DefaultValueUnsignedInt = v
				_ = ext
			case "defaultValueUri":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.DefaultValueUri = v
				_ = ext
			case "defaultValueUrl":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.DefaultValueUrl = v
				_ = ext
			case "defaultValueUuid":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.DefaultValueUuid = v
				_ = ext
			case "defaultValueAddress":
				var v Address
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.DefaultValueAddress = &v
			case "defaultValueAge":
				var v Age
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.DefaultValueAge = &v
			case "defaultValueAnnotation":
				var v Annotation
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.DefaultValueAnnotation = &v
			case "defaultValueAttachment":
				var v Attachment
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.DefaultValueAttachment = &v
			case "defaultValueCodeableConcept":
				var v CodeableConcept
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.DefaultValueCodeableConcept = &v
			case "defaultValueCodeableReference":
				var v CodeableReference
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.DefaultValueCodeableReference = &v
			case "defaultValueCoding":
				var v Coding
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.DefaultValueCoding = &v
			case "defaultValueContactPoint":
				var v ContactPoint
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.DefaultValueContactPoint = &v
			case "defaultValueCount":
				var v Count
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.DefaultValueCount = &v
			case "defaultValueDistance":
				var v Distance
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.DefaultValueDistance = &v
			case "defaultValueDuration":
				var v Duration
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.DefaultValueDuration = &v
			case "defaultValueHumanName":
				var v HumanName
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.DefaultValueHumanName = &v
			case "defaultValueIdentifier":
				var v Identifier
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.DefaultValueIdentifier = &v
			case "defaultValueMoney":
				var v Money
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.DefaultValueMoney = &v
			case "defaultValuePeriod":
				var v Period
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.DefaultValuePeriod = &v
			case "defaultValueQuantity":
				var v Quantity
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.DefaultValueQuantity = &v
			case "defaultValueRange":
				var v Range
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.DefaultValueRange = &v
			case "defaultValueRatio":
				var v Ratio
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.DefaultValueRatio = &v
			case "defaultValueRatioRange":
				var v RatioRange
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.DefaultValueRatioRange = &v
			case "defaultValueReference":
				var v Reference
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.DefaultValueReference = &v
			case "defaultValueSampledData":
				var v SampledData
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.DefaultValueSampledData = &v
			case "defaultValueSignature":
				var v Signature
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.DefaultValueSignature = &v
			case "defaultValueTiming":
				var v Timing
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.DefaultValueTiming = &v
			case "defaultValueContactDetail":
				var v ContactDetail
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.DefaultValueContactDetail = &v
			case "defaultValueContributor":
				var v Contributor
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.DefaultValueContributor = &v
			case "defaultValueDataRequirement":
				var v DataRequirement
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.DefaultValueDataRequirement = &v
			case "defaultValueExpression":
				var v Expression
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.DefaultValueExpression = &v
			case "defaultValueParameterDefinition":
				var v ParameterDefinition
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.DefaultValueParameterDefinition = &v
			case "defaultValueRelatedArtifact":
				var v RelatedArtifact
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.DefaultValueRelatedArtifact = &v
			case "defaultValueTriggerDefinition":
				var v TriggerDefinition
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.DefaultValueTriggerDefinition = &v
			case "defaultValueUsageContext":
				var v UsageContext
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.DefaultValueUsageContext = &v
			case "defaultValueDosage":
				var v Dosage
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.DefaultValueDosage = &v
			case "meaningWhenMissing":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.MeaningWhenMissing = v
				r.MeaningWhenMissingExt = ext
			case "orderMeaning":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.OrderMeaning = v
				r.OrderMeaningExt = ext
			case "fixedBase64Binary":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.FixedBase64Binary = v
				_ = ext
			case "fixedBoolean":
				v, ext, err := xmlDecodePrimitiveBool(dec, t)
				if err != nil {
					return err
				}
				r.FixedBoolean = v
				_ = ext
			case "fixedCanonical":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.FixedCanonical = v
				_ = ext
			case "fixedCode":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.FixedCode = v
				_ = ext
			case "fixedDate":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.FixedDate = v
				_ = ext
			case "fixedDateTime":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.FixedDateTime = v
				_ = ext
			case "fixedDecimal":
				v, ext, err := xmlDecodePrimitiveDecimal(dec, t)
				if err != nil {
					return err
				}
				r.FixedDecimal = v
				_ = ext
			case "fixedId":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.FixedId = v
				_ = ext
			case "fixedInstant":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.FixedInstant = v
				_ = ext
			case "fixedInteger":
				v, ext, err := xmlDecodePrimitiveInt(dec, t)
				if err != nil {
					return err
				}
				r.FixedInteger = v
				_ = ext
			case "fixedMarkdown":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.FixedMarkdown = v
				_ = ext
			case "fixedOid":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.FixedOid = v
				_ = ext
			case "fixedPositiveInt":
				v, ext, err := xmlDecodePrimitiveUint32(dec, t)
				if err != nil {
					return err
				}
				r.FixedPositiveInt = v
				_ = ext
			case "fixedString":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.FixedString = v
				_ = ext
			case "fixedTime":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.FixedTime = v
				_ = ext
			case "fixedUnsignedInt":
				v, ext, err := xmlDecodePrimitiveUint32(dec, t)
				if err != nil {
					return err
				}
				r.FixedUnsignedInt = v
				_ = ext
			case "fixedUri":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.FixedUri = v
				_ = ext
			case "fixedUrl":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.FixedUrl = v
				_ = ext
			case "fixedUuid":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.FixedUuid = v
				_ = ext
			case "fixedAddress":
				var v Address
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.FixedAddress = &v
			case "fixedAge":
				var v Age
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.FixedAge = &v
			case "fixedAnnotation":
				var v Annotation
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.FixedAnnotation = &v
			case "fixedAttachment":
				var v Attachment
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.FixedAttachment = &v
			case "fixedCodeableConcept":
				var v CodeableConcept
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.FixedCodeableConcept = &v
			case "fixedCodeableReference":
				var v CodeableReference
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.FixedCodeableReference = &v
			case "fixedCoding":
				var v Coding
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.FixedCoding = &v
			case "fixedContactPoint":
				var v ContactPoint
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.FixedContactPoint = &v
			case "fixedCount":
				var v Count
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.FixedCount = &v
			case "fixedDistance":
				var v Distance
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.FixedDistance = &v
			case "fixedDuration":
				var v Duration
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.FixedDuration = &v
			case "fixedHumanName":
				var v HumanName
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.FixedHumanName = &v
			case "fixedIdentifier":
				var v Identifier
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.FixedIdentifier = &v
			case "fixedMoney":
				var v Money
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.FixedMoney = &v
			case "fixedPeriod":
				var v Period
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.FixedPeriod = &v
			case "fixedQuantity":
				var v Quantity
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.FixedQuantity = &v
			case "fixedRange":
				var v Range
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.FixedRange = &v
			case "fixedRatio":
				var v Ratio
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.FixedRatio = &v
			case "fixedRatioRange":
				var v RatioRange
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.FixedRatioRange = &v
			case "fixedReference":
				var v Reference
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.FixedReference = &v
			case "fixedSampledData":
				var v SampledData
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.FixedSampledData = &v
			case "fixedSignature":
				var v Signature
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.FixedSignature = &v
			case "fixedTiming":
				var v Timing
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.FixedTiming = &v
			case "fixedContactDetail":
				var v ContactDetail
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.FixedContactDetail = &v
			case "fixedContributor":
				var v Contributor
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.FixedContributor = &v
			case "fixedDataRequirement":
				var v DataRequirement
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.FixedDataRequirement = &v
			case "fixedExpression":
				var v Expression
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.FixedExpression = &v
			case "fixedParameterDefinition":
				var v ParameterDefinition
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.FixedParameterDefinition = &v
			case "fixedRelatedArtifact":
				var v RelatedArtifact
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.FixedRelatedArtifact = &v
			case "fixedTriggerDefinition":
				var v TriggerDefinition
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.FixedTriggerDefinition = &v
			case "fixedUsageContext":
				var v UsageContext
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.FixedUsageContext = &v
			case "fixedDosage":
				var v Dosage
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.FixedDosage = &v
			case "patternBase64Binary":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.PatternBase64Binary = v
				_ = ext
			case "patternBoolean":
				v, ext, err := xmlDecodePrimitiveBool(dec, t)
				if err != nil {
					return err
				}
				r.PatternBoolean = v
				_ = ext
			case "patternCanonical":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.PatternCanonical = v
				_ = ext
			case "patternCode":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.PatternCode = v
				_ = ext
			case "patternDate":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.PatternDate = v
				_ = ext
			case "patternDateTime":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.PatternDateTime = v
				_ = ext
			case "patternDecimal":
				v, ext, err := xmlDecodePrimitiveDecimal(dec, t)
				if err != nil {
					return err
				}
				r.PatternDecimal = v
				_ = ext
			case "patternId":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.PatternId = v
				_ = ext
			case "patternInstant":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.PatternInstant = v
				_ = ext
			case "patternInteger":
				v, ext, err := xmlDecodePrimitiveInt(dec, t)
				if err != nil {
					return err
				}
				r.PatternInteger = v
				_ = ext
			case "patternMarkdown":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.PatternMarkdown = v
				_ = ext
			case "patternOid":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.PatternOid = v
				_ = ext
			case "patternPositiveInt":
				v, ext, err := xmlDecodePrimitiveUint32(dec, t)
				if err != nil {
					return err
				}
				r.PatternPositiveInt = v
				_ = ext
			case "patternString":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.PatternString = v
				_ = ext
			case "patternTime":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.PatternTime = v
				_ = ext
			case "patternUnsignedInt":
				v, ext, err := xmlDecodePrimitiveUint32(dec, t)
				if err != nil {
					return err
				}
				r.PatternUnsignedInt = v
				_ = ext
			case "patternUri":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.PatternUri = v
				_ = ext
			case "patternUrl":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.PatternUrl = v
				_ = ext
			case "patternUuid":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.PatternUuid = v
				_ = ext
			case "patternAddress":
				var v Address
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.PatternAddress = &v
			case "patternAge":
				var v Age
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.PatternAge = &v
			case "patternAnnotation":
				var v Annotation
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.PatternAnnotation = &v
			case "patternAttachment":
				var v Attachment
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.PatternAttachment = &v
			case "patternCodeableConcept":
				var v CodeableConcept
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.PatternCodeableConcept = &v
			case "patternCodeableReference":
				var v CodeableReference
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.PatternCodeableReference = &v
			case "patternCoding":
				var v Coding
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.PatternCoding = &v
			case "patternContactPoint":
				var v ContactPoint
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.PatternContactPoint = &v
			case "patternCount":
				var v Count
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.PatternCount = &v
			case "patternDistance":
				var v Distance
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.PatternDistance = &v
			case "patternDuration":
				var v Duration
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.PatternDuration = &v
			case "patternHumanName":
				var v HumanName
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.PatternHumanName = &v
			case "patternIdentifier":
				var v Identifier
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.PatternIdentifier = &v
			case "patternMoney":
				var v Money
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.PatternMoney = &v
			case "patternPeriod":
				var v Period
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.PatternPeriod = &v
			case "patternQuantity":
				var v Quantity
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.PatternQuantity = &v
			case "patternRange":
				var v Range
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.PatternRange = &v
			case "patternRatio":
				var v Ratio
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.PatternRatio = &v
			case "patternRatioRange":
				var v RatioRange
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.PatternRatioRange = &v
			case "patternReference":
				var v Reference
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.PatternReference = &v
			case "patternSampledData":
				var v SampledData
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.PatternSampledData = &v
			case "patternSignature":
				var v Signature
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.PatternSignature = &v
			case "patternTiming":
				var v Timing
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.PatternTiming = &v
			case "patternContactDetail":
				var v ContactDetail
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.PatternContactDetail = &v
			case "patternContributor":
				var v Contributor
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.PatternContributor = &v
			case "patternDataRequirement":
				var v DataRequirement
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.PatternDataRequirement = &v
			case "patternExpression":
				var v Expression
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.PatternExpression = &v
			case "patternParameterDefinition":
				var v ParameterDefinition
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.PatternParameterDefinition = &v
			case "patternRelatedArtifact":
				var v RelatedArtifact
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.PatternRelatedArtifact = &v
			case "patternTriggerDefinition":
				var v TriggerDefinition
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.PatternTriggerDefinition = &v
			case "patternUsageContext":
				var v UsageContext
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.PatternUsageContext = &v
			case "patternDosage":
				var v Dosage
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.PatternDosage = &v
			case "example":
				var v ElementDefinitionExample
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Example = append(r.Example, v)
			case "minValueDate":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.MinValueDate = v
				_ = ext
			case "minValueDateTime":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.MinValueDateTime = v
				_ = ext
			case "minValueInstant":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.MinValueInstant = v
				_ = ext
			case "minValueTime":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.MinValueTime = v
				_ = ext
			case "minValueDecimal":
				v, ext, err := xmlDecodePrimitiveDecimal(dec, t)
				if err != nil {
					return err
				}
				r.MinValueDecimal = v
				_ = ext
			case "minValueInteger":
				v, ext, err := xmlDecodePrimitiveInt(dec, t)
				if err != nil {
					return err
				}
				r.MinValueInteger = v
				_ = ext
			case "minValuePositiveInt":
				v, ext, err := xmlDecodePrimitiveUint32(dec, t)
				if err != nil {
					return err
				}
				r.MinValuePositiveInt = v
				_ = ext
			case "minValueUnsignedInt":
				v, ext, err := xmlDecodePrimitiveUint32(dec, t)
				if err != nil {
					return err
				}
				r.MinValueUnsignedInt = v
				_ = ext
			case "minValueQuantity":
				var v Quantity
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.MinValueQuantity = &v
			case "maxValueDate":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.MaxValueDate = v
				_ = ext
			case "maxValueDateTime":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.MaxValueDateTime = v
				_ = ext
			case "maxValueInstant":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.MaxValueInstant = v
				_ = ext
			case "maxValueTime":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.MaxValueTime = v
				_ = ext
			case "maxValueDecimal":
				v, ext, err := xmlDecodePrimitiveDecimal(dec, t)
				if err != nil {
					return err
				}
				r.MaxValueDecimal = v
				_ = ext
			case "maxValueInteger":
				v, ext, err := xmlDecodePrimitiveInt(dec, t)
				if err != nil {
					return err
				}
				r.MaxValueInteger = v
				_ = ext
			case "maxValuePositiveInt":
				v, ext, err := xmlDecodePrimitiveUint32(dec, t)
				if err != nil {
					return err
				}
				r.MaxValuePositiveInt = v
				_ = ext
			case "maxValueUnsignedInt":
				v, ext, err := xmlDecodePrimitiveUint32(dec, t)
				if err != nil {
					return err
				}
				r.MaxValueUnsignedInt = v
				_ = ext
			case "maxValueQuantity":
				var v Quantity
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.MaxValueQuantity = &v
			case "maxLength":
				v, ext, err := xmlDecodePrimitiveInt(dec, t)
				if err != nil {
					return err
				}
				r.MaxLength = v
				r.MaxLengthExt = ext
			case "condition":
				v, _, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.Condition = append(r.Condition, *v)
				}
			case "constraint":
				var v ElementDefinitionConstraint
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Constraint = append(r.Constraint, v)
			case "mustSupport":
				v, ext, err := xmlDecodePrimitiveBool(dec, t)
				if err != nil {
					return err
				}
				r.MustSupport = v
				r.MustSupportExt = ext
			case "isModifier":
				v, ext, err := xmlDecodePrimitiveBool(dec, t)
				if err != nil {
					return err
				}
				r.IsModifier = v
				r.IsModifierExt = ext
			case "isModifierReason":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.IsModifierReason = v
				r.IsModifierReasonExt = ext
			case "isSummary":
				v, ext, err := xmlDecodePrimitiveBool(dec, t)
				if err != nil {
					return err
				}
				r.IsSummary = v
				r.IsSummaryExt = ext
			case "binding":
				var v ElementDefinitionBinding
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Binding = &v
			case "mapping":
				var v ElementDefinitionMapping
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Mapping = append(r.Mapping, v)
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes Expression from FHIR-conformant XML.
func (r *Expression) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "description":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Description = v
				r.DescriptionExt = ext
			case "name":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Name = v
				r.NameExt = ext
			case "language":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Language = v
				r.LanguageExt = ext
			case "expression":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Expression = v
				r.ExpressionExt = ext
			case "reference":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Reference = v
				r.ReferenceExt = ext
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes Extension from FHIR-conformant XML.
func (r *Extension) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		switch attr.Name.Local {
		case "id":
			v := attr.Value
			r.Id = &v
		case "url":
			r.Url = attr.Value
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "valueBase64Binary":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.ValueBase64Binary = v
				_ = ext
			case "valueBoolean":
				v, ext, err := xmlDecodePrimitiveBool(dec, t)
				if err != nil {
					return err
				}
				r.ValueBoolean = v
				_ = ext
			case "valueCanonical":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.ValueCanonical = v
				_ = ext
			case "valueCode":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.ValueCode = v
				_ = ext
			case "valueDate":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.ValueDate = v
				_ = ext
			case "valueDateTime":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.ValueDateTime = v
				_ = ext
			case "valueDecimal":
				v, ext, err := xmlDecodePrimitiveDecimal(dec, t)
				if err != nil {
					return err
				}
				r.ValueDecimal = v
				_ = ext
			case "valueId":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.ValueId = v
				_ = ext
			case "valueInstant":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.ValueInstant = v
				_ = ext
			case "valueInteger":
				v, ext, err := xmlDecodePrimitiveInt(dec, t)
				if err != nil {
					return err
				}
				r.ValueInteger = v
				_ = ext
			case "valueMarkdown":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.ValueMarkdown = v
				_ = ext
			case "valueOid":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.ValueOid = v
				_ = ext
			case "valuePositiveInt":
				v, ext, err := xmlDecodePrimitiveUint32(dec, t)
				if err != nil {
					return err
				}
				r.ValuePositiveInt = v
				_ = ext
			case "valueString":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.ValueString = v
				_ = ext
			case "valueTime":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.ValueTime = v
				_ = ext
			case "valueUnsignedInt":
				v, ext, err := xmlDecodePrimitiveUint32(dec, t)
				if err != nil {
					return err
				}
				r.ValueUnsignedInt = v
				_ = ext
			case "valueUri":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.ValueUri = v
				_ = ext
			case "valueUrl":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.ValueUrl = v
				_ = ext
			case "valueUuid":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.ValueUuid = v
				_ = ext
			case "valueAddress":
				var v Address
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ValueAddress = &v
			case "valueAge":
				var v Age
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ValueAge = &v
			case "valueAnnotation":
				var v Annotation
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ValueAnnotation = &v
			case "valueAttachment":
				var v Attachment
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ValueAttachment = &v
			case "valueCodeableConcept":
				var v CodeableConcept
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ValueCodeableConcept = &v
			case "valueCodeableReference":
				var v CodeableReference
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ValueCodeableReference = &v
			case "valueCoding":
				var v Coding
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ValueCoding = &v
			case "valueContactPoint":
				var v ContactPoint
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ValueContactPoint = &v
			case "valueCount":
				var v Count
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ValueCount = &v
			case "valueDistance":
				var v Distance
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ValueDistance = &v
			case "valueDuration":
				var v Duration
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ValueDuration = &v
			case "valueHumanName":
				var v HumanName
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ValueHumanName = &v
			case "valueIdentifier":
				var v Identifier
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ValueIdentifier = &v
			case "valueMoney":
				var v Money
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ValueMoney = &v
			case "valuePeriod":
				var v Period
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ValuePeriod = &v
			case "valueQuantity":
				var v Quantity
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ValueQuantity = &v
			case "valueRange":
				var v Range
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ValueRange = &v
			case "valueRatio":
				var v Ratio
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ValueRatio = &v
			case "valueRatioRange":
				var v RatioRange
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ValueRatioRange = &v
			case "valueReference":
				var v Reference
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ValueReference = &v
			case "valueSampledData":
				var v SampledData
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ValueSampledData = &v
			case "valueSignature":
				var v Signature
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ValueSignature = &v
			case "valueTiming":
				var v Timing
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ValueTiming = &v
			case "valueContactDetail":
				var v ContactDetail
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ValueContactDetail = &v
			case "valueContributor":
				var v Contributor
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ValueContributor = &v
			case "valueDataRequirement":
				var v DataRequirement
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ValueDataRequirement = &v
			case "valueExpression":
				var v Expression
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ValueExpression = &v
			case "valueParameterDefinition":
				var v ParameterDefinition
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ValueParameterDefinition = &v
			case "valueRelatedArtifact":
				var v RelatedArtifact
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ValueRelatedArtifact = &v
			case "valueTriggerDefinition":
				var v TriggerDefinition
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ValueTriggerDefinition = &v
			case "valueUsageContext":
				var v UsageContext
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ValueUsageContext = &v
			case "valueDosage":
				var v Dosage
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ValueDosage = &v
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes HumanName from FHIR-conformant XML.
func (r *HumanName) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "use":
				v, ext, err := xmlDecodePrimitiveCode[NameUse](dec, t)
				if err != nil {
					return err
				}
				r.Use = v
				r.UseExt = ext
			case "text":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Text = v
				r.TextExt = ext
			case "family":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Family = v
				r.FamilyExt = ext
			case "given":
				v, _, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.Given = append(r.Given, *v)
				}
			case "prefix":
				v, _, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.Prefix = append(r.Prefix, *v)
				}
			case "suffix":
				v, _, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.Suffix = append(r.Suffix, *v)
				}
			case "period":
				var v Period
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Period = &v
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes Identifier from FHIR-conformant XML.
func (r *Identifier) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "use":
				v, ext, err := xmlDecodePrimitiveCode[IdentifierUse](dec, t)
				if err != nil {
					return err
				}
				r.Use = v
				r.UseExt = ext
			case "type":
				var v CodeableConcept
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Type = &v
			case "system":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.System = v
				r.SystemExt = ext
			case "value":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Value = v
				r.ValueExt = ext
			case "period":
				var v Period
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Period = &v
			case "assigner":
				var v Reference
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Assigner = &v
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes MarketingStatus from FHIR-conformant XML.
func (r *MarketingStatus) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "country":
				var v CodeableConcept
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Country = &v
			case "jurisdiction":
				var v CodeableConcept
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Jurisdiction = &v
			case "status":
				if err := r.Status.UnmarshalXML(dec, t); err != nil {
					return err
				}
			case "dateRange":
				var v Period
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.DateRange = &v
			case "restoreDate":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.RestoreDate = v
				r.RestoreDateExt = ext
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes Meta from FHIR-conformant XML.
func (r *Meta) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "versionId":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.VersionId = v
				r.VersionIdExt = ext
			case "lastUpdated":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.LastUpdated = v
				r.LastUpdatedExt = ext
			case "source":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Source = v
				r.SourceExt = ext
			case "profile":
				v, _, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.Profile = append(r.Profile, *v)
				}
			case "security":
				var v Coding
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Security = append(r.Security, v)
			case "tag":
				var v Coding
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Tag = append(r.Tag, v)
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes Money from FHIR-conformant XML.
func (r *Money) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "value":
				v, ext, err := xmlDecodePrimitiveDecimal(dec, t)
				if err != nil {
					return err
				}
				r.Value = v
				r.ValueExt = ext
			case "currency":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Currency = v
				r.CurrencyExt = ext
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes Narrative from FHIR-conformant XML.
func (r *Narrative) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "status":
				v, ext, err := xmlDecodePrimitiveCode[NarrativeStatus](dec, t)
				if err != nil {
					return err
				}
				r.Status = v
				r.StatusExt = ext
			case "div":
				v, err := xmlDecodeRawXHTML(dec, t)
				if err != nil {
					return err
				}
				r.Div = v
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes ParameterDefinition from FHIR-conformant XML.
func (r *ParameterDefinition) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "name":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Name = v
				r.NameExt = ext
			case "use":
				v, ext, err := xmlDecodePrimitiveCode[OperationParameterUse](dec, t)
				if err != nil {
					return err
				}
				r.Use = v
				r.UseExt = ext
			case "min":
				v, ext, err := xmlDecodePrimitiveInt(dec, t)
				if err != nil {
					return err
				}
				r.Min = v
				r.MinExt = ext
			case "max":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Max = v
				r.MaxExt = ext
			case "documentation":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Documentation = v
				r.DocumentationExt = ext
			case "type":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Type = v
				r.TypeExt = ext
			case "profile":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Profile = v
				r.ProfileExt = ext
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes Period from FHIR-conformant XML.
func (r *Period) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "start":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Start = v
				r.StartExt = ext
			case "end":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.End = v
				r.EndExt = ext
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes Population from FHIR-conformant XML.
func (r *Population) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "ageRange":
				var v Range
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.AgeRange = &v
			case "ageCodeableConcept":
				var v CodeableConcept
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.AgeCodeableConcept = &v
			case "gender":
				var v CodeableConcept
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Gender = &v
			case "race":
				var v CodeableConcept
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Race = &v
			case "physiologicalCondition":
				var v CodeableConcept
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.PhysiologicalCondition = &v
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes ProdCharacteristic from FHIR-conformant XML.
func (r *ProdCharacteristic) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "height":
				var v Quantity
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Height = &v
			case "width":
				var v Quantity
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Width = &v
			case "depth":
				var v Quantity
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Depth = &v
			case "weight":
				var v Quantity
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Weight = &v
			case "nominalVolume":
				var v Quantity
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.NominalVolume = &v
			case "externalDiameter":
				var v Quantity
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ExternalDiameter = &v
			case "shape":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Shape = v
				r.ShapeExt = ext
			case "color":
				v, _, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.Color = append(r.Color, *v)
				}
			case "imprint":
				v, _, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.Imprint = append(r.Imprint, *v)
				}
			case "image":
				var v Attachment
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Image = append(r.Image, v)
			case "scoring":
				var v CodeableConcept
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Scoring = &v
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes ProductShelfLife from FHIR-conformant XML.
func (r *ProductShelfLife) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "identifier":
				var v Identifier
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Identifier = &v
			case "type":
				if err := r.Type.UnmarshalXML(dec, t); err != nil {
					return err
				}
			case "period":
				if err := r.Period.UnmarshalXML(dec, t); err != nil {
					return err
				}
			case "specialPrecautionsForStorage":
				var v CodeableConcept
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.SpecialPrecautionsForStorage = append(r.SpecialPrecautionsForStorage, v)
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes Quantity from FHIR-conformant XML.
func (r *Quantity) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "value":
				v, ext, err := xmlDecodePrimitiveDecimal(dec, t)
				if err != nil {
					return err
				}
				r.Value = v
				r.ValueExt = ext
			case "comparator":
				v, ext, err := xmlDecodePrimitiveCode[QuantityComparator](dec, t)
				if err != nil {
					return err
				}
				r.Comparator = v
				r.ComparatorExt = ext
			case "unit":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Unit = v
				r.UnitExt = ext
			case "system":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.System = v
				r.SystemExt = ext
			case "code":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Code = v
				r.CodeExt = ext
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes Range from FHIR-conformant XML.
func (r *Range) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "low":
				var v Quantity
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Low = &v
			case "high":
				var v Quantity
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.High = &v
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes Ratio from FHIR-conformant XML.
func (r *Ratio) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "numerator":
				var v Quantity
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Numerator = &v
			case "denominator":
				var v Quantity
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Denominator = &v
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes RatioRange from FHIR-conformant XML.
func (r *RatioRange) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "lowNumerator":
				var v Quantity
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.LowNumerator = &v
			case "highNumerator":
				var v Quantity
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.HighNumerator = &v
			case "denominator":
				var v Quantity
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Denominator = &v
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes Reference from FHIR-conformant XML.
func (r *Reference) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "reference":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Reference = v
				r.ReferenceExt = ext
			case "type":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Type = v
				r.TypeExt = ext
			case "identifier":
				var v Identifier
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Identifier = &v
			case "display":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Display = v
				r.DisplayExt = ext
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes RelatedArtifact from FHIR-conformant XML.
func (r *RelatedArtifact) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "type":
				v, ext, err := xmlDecodePrimitiveCode[RelatedArtifactType](dec, t)
				if err != nil {
					return err
				}
				r.Type = v
				r.TypeExt = ext
			case "label":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Label = v
				r.LabelExt = ext
			case "display":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Display = v
				r.DisplayExt = ext
			case "citation":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Citation = v
				r.CitationExt = ext
			case "url":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Url = v
				r.UrlExt = ext
			case "document":
				var v Attachment
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Document = &v
			case "resource":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Resource = v
				r.ResourceExt = ext
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes SampledData from FHIR-conformant XML.
func (r *SampledData) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "origin":
				if err := r.Origin.UnmarshalXML(dec, t); err != nil {
					return err
				}
			case "period":
				v, ext, err := xmlDecodePrimitiveDecimal(dec, t)
				if err != nil {
					return err
				}
				r.Period = v
				r.PeriodExt = ext
			case "factor":
				v, ext, err := xmlDecodePrimitiveDecimal(dec, t)
				if err != nil {
					return err
				}
				r.Factor = v
				r.FactorExt = ext
			case "lowerLimit":
				v, ext, err := xmlDecodePrimitiveDecimal(dec, t)
				if err != nil {
					return err
				}
				r.LowerLimit = v
				r.LowerLimitExt = ext
			case "upperLimit":
				v, ext, err := xmlDecodePrimitiveDecimal(dec, t)
				if err != nil {
					return err
				}
				r.UpperLimit = v
				r.UpperLimitExt = ext
			case "dimensions":
				v, ext, err := xmlDecodePrimitiveUint32(dec, t)
				if err != nil {
					return err
				}
				r.Dimensions = v
				r.DimensionsExt = ext
			case "data":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Data = v
				r.DataExt = ext
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes Signature from FHIR-conformant XML.
func (r *Signature) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "type":
				var v Coding
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Type = append(r.Type, v)
			case "when":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.When = v
				r.WhenExt = ext
			case "who":
				if err := r.Who.UnmarshalXML(dec, t); err != nil {
					return err
				}
			case "onBehalfOf":
				var v Reference
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.OnBehalfOf = &v
			case "targetFormat":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.TargetFormat = v
				r.TargetFormatExt = ext
			case "sigFormat":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.SigFormat = v
				r.SigFormatExt = ext
			case "data":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Data = v
				r.DataExt = ext
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes Timing from FHIR-conformant XML.
func (r *Timing) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "event":
				v, _, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.Event = append(r.Event, *v)
				}
			case "repeat":
				var v TimingRepeat
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Repeat = &v
			case "code":
				var v CodeableConcept
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Code = &v
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes TriggerDefinition from FHIR-conformant XML.
func (r *TriggerDefinition) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "type":
				v, ext, err := xmlDecodePrimitiveCode[TriggerType](dec, t)
				if err != nil {
					return err
				}
				r.Type = v
				r.TypeExt = ext
			case "name":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Name = v
				r.NameExt = ext
			case "timingTiming":
				var v Timing
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.TimingTiming = &v
			case "timingReference":
				var v Reference
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.TimingReference = &v
			case "timingDate":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.TimingDate = v
				_ = ext
			case "timingDateTime":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.TimingDateTime = v
				_ = ext
			case "data":
				var v DataRequirement
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Data = append(r.Data, v)
			case "condition":
				var v Expression
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Condition = &v
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes UsageContext from FHIR-conformant XML.
func (r *UsageContext) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "code":
				if err := r.Code.UnmarshalXML(dec, t); err != nil {
					return err
				}
			case "valueCodeableConcept":
				var v CodeableConcept
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ValueCodeableConcept = &v
			case "valueQuantity":
				var v Quantity
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ValueQuantity = &v
			case "valueRange":
				var v Range
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ValueRange = &v
			case "valueReference":
				var v Reference
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.ValueReference = &v
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes MoneyQuantity from FHIR-conformant XML.
func (r *MoneyQuantity) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "value":
				v, ext, err := xmlDecodePrimitiveDecimal(dec, t)
				if err != nil {
					return err
				}
				r.Value = v
				r.ValueExt = ext
			case "comparator":
				v, ext, err := xmlDecodePrimitiveCode[QuantityComparator](dec, t)
				if err != nil {
					return err
				}
				r.Comparator = v
				r.ComparatorExt = ext
			case "unit":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Unit = v
				r.UnitExt = ext
			case "system":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.System = v
				r.SystemExt = ext
			case "code":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Code = v
				r.CodeExt = ext
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes SimpleQuantity from FHIR-conformant XML.
func (r *SimpleQuantity) UnmarshalXML(dec *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := dec.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(dec, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "value":
				v, ext, err := xmlDecodePrimitiveDecimal(dec, t)
				if err != nil {
					return err
				}
				r.Value = v
				r.ValueExt = ext
			case "comparator":
				v, ext, err := xmlDecodePrimitiveCode[QuantityComparator](dec, t)
				if err != nil {
					return err
				}
				r.Comparator = v
				r.ComparatorExt = ext
			case "unit":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Unit = v
				r.UnitExt = ext
			case "system":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.System = v
				r.SystemExt = ext
			case "code":
				v, ext, err := xmlDecodePrimitiveString(dec, t)
				if err != nil {
					return err
				}
				r.Code = v
				r.CodeExt = ext
			default:
				if err := dec.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// =============================================================================
// Backbone XML Deserialization (for datatype backbones)
// =============================================================================

// UnmarshalXML deserializes DataRequirementCodeFilter from FHIR-conformant XML.
func (r *DataRequirementCodeFilter) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "path":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Path = v
			case "searchParam":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.SearchParam = v
			case "valueSet":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ValueSet = v
			case "code":
				var v Coding
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Code = append(r.Code, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes DataRequirementDateFilter from FHIR-conformant XML.
func (r *DataRequirementDateFilter) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "path":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Path = v
			case "searchParam":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.SearchParam = v
			case "valueDateTime":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ValueDateTime = v
			case "valuePeriod":
				var v Period
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValuePeriod = &v
			case "valueDuration":
				var v Duration
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueDuration = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes DataRequirementSort from FHIR-conformant XML.
func (r *DataRequirementSort) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "path":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Path = v
			case "direction":
				v, _, err := xmlDecodePrimitiveCode[SortDirection](d, t)
				if err != nil {
					return err
				}
				r.Direction = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes DosageDoseAndRate from FHIR-conformant XML.
func (r *DosageDoseAndRate) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "type":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Type = &v
			case "doseRange":
				var v Range
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.DoseRange = &v
			case "doseQuantity":
				var v Quantity
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.DoseQuantity = &v
			case "rateRatio":
				var v Ratio
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.RateRatio = &v
			case "rateRange":
				var v Range
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.RateRange = &v
			case "rateQuantity":
				var v Quantity
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.RateQuantity = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes ElementDefinitionBase from FHIR-conformant XML.
func (r *ElementDefinitionBase) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "path":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Path = v
			case "min":
				v, _, err := xmlDecodePrimitiveUint32(d, t)
				if err != nil {
					return err
				}
				r.Min = v
			case "max":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Max = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes ElementDefinitionBinding from FHIR-conformant XML.
func (r *ElementDefinitionBinding) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "strength":
				v, _, err := xmlDecodePrimitiveCode[BindingStrength](d, t)
				if err != nil {
					return err
				}
				r.Strength = v
			case "description":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Description = v
			case "valueSet":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ValueSet = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes ElementDefinitionConstraint from FHIR-conformant XML.
func (r *ElementDefinitionConstraint) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "key":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Key = v
			case "requirements":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Requirements = v
			case "severity":
				v, _, err := xmlDecodePrimitiveCode[ConstraintSeverity](d, t)
				if err != nil {
					return err
				}
				r.Severity = v
			case "human":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Human = v
			case "expression":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Expression = v
			case "xpath":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Xpath = v
			case "source":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Source = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes ElementDefinitionExample from FHIR-conformant XML.
func (r *ElementDefinitionExample) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "label":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Label = v
			case "valueBase64Binary":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ValueBase64Binary = v
			case "valueBoolean":
				v, _, err := xmlDecodePrimitiveBool(d, t)
				if err != nil {
					return err
				}
				r.ValueBoolean = v
			case "valueCanonical":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ValueCanonical = v
			case "valueCode":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ValueCode = v
			case "valueDate":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ValueDate = v
			case "valueDateTime":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ValueDateTime = v
			case "valueDecimal":
				v, _, err := xmlDecodePrimitiveDecimal(d, t)
				if err != nil {
					return err
				}
				r.ValueDecimal = v
			case "valueId":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ValueId = v
			case "valueInstant":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ValueInstant = v
			case "valueInteger":
				v, _, err := xmlDecodePrimitiveInt(d, t)
				if err != nil {
					return err
				}
				r.ValueInteger = v
			case "valueMarkdown":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ValueMarkdown = v
			case "valueOid":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ValueOid = v
			case "valuePositiveInt":
				v, _, err := xmlDecodePrimitiveUint32(d, t)
				if err != nil {
					return err
				}
				r.ValuePositiveInt = v
			case "valueString":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ValueString = v
			case "valueTime":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ValueTime = v
			case "valueUnsignedInt":
				v, _, err := xmlDecodePrimitiveUint32(d, t)
				if err != nil {
					return err
				}
				r.ValueUnsignedInt = v
			case "valueUri":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ValueUri = v
			case "valueUrl":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ValueUrl = v
			case "valueUuid":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ValueUuid = v
			case "valueAddress":
				var v Address
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueAddress = &v
			case "valueAge":
				var v Age
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueAge = &v
			case "valueAnnotation":
				var v Annotation
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueAnnotation = &v
			case "valueAttachment":
				var v Attachment
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueAttachment = &v
			case "valueCodeableConcept":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueCodeableConcept = &v
			case "valueCodeableReference":
				var v CodeableReference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueCodeableReference = &v
			case "valueCoding":
				var v Coding
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueCoding = &v
			case "valueContactPoint":
				var v ContactPoint
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueContactPoint = &v
			case "valueCount":
				var v Count
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueCount = &v
			case "valueDistance":
				var v Distance
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueDistance = &v
			case "valueDuration":
				var v Duration
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueDuration = &v
			case "valueHumanName":
				var v HumanName
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueHumanName = &v
			case "valueIdentifier":
				var v Identifier
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueIdentifier = &v
			case "valueMoney":
				var v Money
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueMoney = &v
			case "valuePeriod":
				var v Period
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValuePeriod = &v
			case "valueQuantity":
				var v Quantity
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueQuantity = &v
			case "valueRange":
				var v Range
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueRange = &v
			case "valueRatio":
				var v Ratio
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueRatio = &v
			case "valueRatioRange":
				var v RatioRange
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueRatioRange = &v
			case "valueReference":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueReference = &v
			case "valueSampledData":
				var v SampledData
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueSampledData = &v
			case "valueSignature":
				var v Signature
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueSignature = &v
			case "valueTiming":
				var v Timing
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueTiming = &v
			case "valueContactDetail":
				var v ContactDetail
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueContactDetail = &v
			case "valueContributor":
				var v Contributor
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueContributor = &v
			case "valueDataRequirement":
				var v DataRequirement
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueDataRequirement = &v
			case "valueExpression":
				var v Expression
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueExpression = &v
			case "valueParameterDefinition":
				var v ParameterDefinition
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueParameterDefinition = &v
			case "valueRelatedArtifact":
				var v RelatedArtifact
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueRelatedArtifact = &v
			case "valueTriggerDefinition":
				var v TriggerDefinition
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueTriggerDefinition = &v
			case "valueUsageContext":
				var v UsageContext
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueUsageContext = &v
			case "valueDosage":
				var v Dosage
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueDosage = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes ElementDefinitionMapping from FHIR-conformant XML.
func (r *ElementDefinitionMapping) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "identity":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Identity = v
			case "language":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Language = v
			case "map":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Map = v
			case "comment":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Comment = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes ElementDefinitionSlicing from FHIR-conformant XML.
func (r *ElementDefinitionSlicing) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "discriminator":
				var v ElementDefinitionSlicingDiscriminator
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Discriminator = append(r.Discriminator, v)
			case "description":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Description = v
			case "ordered":
				v, _, err := xmlDecodePrimitiveBool(d, t)
				if err != nil {
					return err
				}
				r.Ordered = v
			case "rules":
				v, _, err := xmlDecodePrimitiveCode[SlicingRules](d, t)
				if err != nil {
					return err
				}
				r.Rules = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes ElementDefinitionSlicingDiscriminator from FHIR-conformant XML.
func (r *ElementDefinitionSlicingDiscriminator) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "type":
				v, _, err := xmlDecodePrimitiveCode[DiscriminatorType](d, t)
				if err != nil {
					return err
				}
				r.Type = v
			case "path":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Path = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes ElementDefinitionType from FHIR-conformant XML.
func (r *ElementDefinitionType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "code":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Code = v
			case "profile":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.Profile = append(r.Profile, *v)
				}
			case "targetProfile":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.TargetProfile = append(r.TargetProfile, *v)
				}
			case "aggregation":
				v, _, err := xmlDecodePrimitiveCode[AggregationMode](d, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.Aggregation = append(r.Aggregation, *v)
				}
			case "versioning":
				v, _, err := xmlDecodePrimitiveCode[ReferenceVersionRules](d, t)
				if err != nil {
					return err
				}
				r.Versioning = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// UnmarshalXML deserializes TimingRepeat from FHIR-conformant XML.
func (r *TimingRepeat) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "boundsDuration":
				var v Duration
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.BoundsDuration = &v
			case "boundsRange":
				var v Range
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.BoundsRange = &v
			case "boundsPeriod":
				var v Period
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.BoundsPeriod = &v
			case "count":
				v, _, err := xmlDecodePrimitiveUint32(d, t)
				if err != nil {
					return err
				}
				r.Count = v
			case "countMax":
				v, _, err := xmlDecodePrimitiveUint32(d, t)
				if err != nil {
					return err
				}
				r.CountMax = v
			case "duration":
				v, _, err := xmlDecodePrimitiveDecimal(d, t)
				if err != nil {
					return err
				}
				r.Duration = v
			case "durationMax":
				v, _, err := xmlDecodePrimitiveDecimal(d, t)
				if err != nil {
					return err
				}
				r.DurationMax = v
			case "durationUnit":
				v, _, err := xmlDecodePrimitiveCode[UnitsOfTime](d, t)
				if err != nil {
					return err
				}
				r.DurationUnit = v
			case "frequency":
				v, _, err := xmlDecodePrimitiveUint32(d, t)
				if err != nil {
					return err
				}
				r.Frequency = v
			case "frequencyMax":
				v, _, err := xmlDecodePrimitiveUint32(d, t)
				if err != nil {
					return err
				}
				r.FrequencyMax = v
			case "period":
				v, _, err := xmlDecodePrimitiveDecimal(d, t)
				if err != nil {
					return err
				}
				r.Period = v
			case "periodMax":
				v, _, err := xmlDecodePrimitiveDecimal(d, t)
				if err != nil {
					return err
				}
				r.PeriodMax = v
			case "periodUnit":
				v, _, err := xmlDecodePrimitiveCode[UnitsOfTime](d, t)
				if err != nil {
					return err
				}
				r.PeriodUnit = v
			case "dayOfWeek":
				v, _, err := xmlDecodePrimitiveCode[DaysOfWeek](d, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.DayOfWeek = append(r.DayOfWeek, *v)
				}
			case "timeOfDay":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.TimeOfDay = append(r.TimeOfDay, *v)
				}
			case "when":
				v, _, err := xmlDecodePrimitiveCode[EventTiming](d, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.When = append(r.When, *v)
				}
			case "offset":
				v, _, err := xmlDecodePrimitiveUint32(d, t)
				if err != nil {
					return err
				}
				r.Offset = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}
