// Code generated by gofhir. DO NOT EDIT.
// Source: FHIR StructureDefinitions (consolidated resource)
// Package: r4b

package r4b

import (
	"bytes"
	"encoding/json"
	"encoding/xml"
	"fmt"
)

// =============================================================================
// Contract Resource
// =============================================================================

// Contract represents FHIR Contract.
type Contract struct {
	// FHIR resource type
	ResourceType string `json:"resourceType"`
	// Logical id of this artifact
	Id *string `json:"id,omitempty"`
	// Metadata about the resource
	Meta *Meta `json:"meta,omitempty"`
	// A set of rules under which this content was created
	ImplicitRules *string `json:"implicitRules,omitempty"`
	// Extension for ImplicitRules
	ImplicitRulesExt *Element `json:"_implicitRules,omitempty"`
	// Language of the resource content
	Language *string `json:"language,omitempty"`
	// Extension for Language
	LanguageExt *Element `json:"_language,omitempty"`
	// Text summary of the resource, for human interpretation
	Text *Narrative `json:"text,omitempty"`
	// Contained, inline Resources
	Contained []Resource `json:"contained,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Contract number
	Identifier []Identifier `json:"identifier,omitempty"`
	// Basal definition
	Url *string `json:"url,omitempty"`
	// Extension for Url
	UrlExt *Element `json:"_url,omitempty"`
	// Business edition
	Version *string `json:"version,omitempty"`
	// Extension for Version
	VersionExt *Element `json:"_version,omitempty"`
	// amended | appended | cancelled | disputed | entered-in-error | executable | executed | negotiable | offered | policy | rejected | renewed | revoked | resolved | terminated
	Status *ContractResourceStatusCodes `json:"status,omitempty"`
	// Extension for Status
	StatusExt *Element `json:"_status,omitempty"`
	// Negotiation status
	LegalState *CodeableConcept `json:"legalState,omitempty"`
	// Source Contract Definition
	InstantiatesCanonical *Reference `json:"instantiatesCanonical,omitempty"`
	// External Contract Definition
	InstantiatesUri *string `json:"instantiatesUri,omitempty"`
	// Extension for InstantiatesUri
	InstantiatesUriExt *Element `json:"_instantiatesUri,omitempty"`
	// Content derived from the basal information
	ContentDerivative *CodeableConcept `json:"contentDerivative,omitempty"`
	// When this Contract was issued
	Issued *string `json:"issued,omitempty"`
	// Extension for Issued
	IssuedExt *Element `json:"_issued,omitempty"`
	// Effective time
	Applies *Period `json:"applies,omitempty"`
	// Contract cessation cause
	ExpirationType *CodeableConcept `json:"expirationType,omitempty"`
	// Contract Target Entity
	Subject []Reference `json:"subject,omitempty"`
	// Authority under which this Contract has standing
	Authority []Reference `json:"authority,omitempty"`
	// A sphere of control governed by an authoritative jurisdiction, organization, or person
	Domain []Reference `json:"domain,omitempty"`
	// Specific Location
	Site []Reference `json:"site,omitempty"`
	// Computer friendly designation
	Name *string `json:"name,omitempty"`
	// Extension for Name
	NameExt *Element `json:"_name,omitempty"`
	// Human Friendly name
	Title *string `json:"title,omitempty"`
	// Extension for Title
	TitleExt *Element `json:"_title,omitempty"`
	// Subordinate Friendly name
	Subtitle *string `json:"subtitle,omitempty"`
	// Extension for Subtitle
	SubtitleExt *Element `json:"_subtitle,omitempty"`
	// Acronym or short name
	Alias []string `json:"alias,omitempty"`
	// Extension for Alias
	AliasExt []Element `json:"_alias,omitempty"`
	// Source of Contract
	Author *Reference `json:"author,omitempty"`
	// Range of Legal Concerns
	Scope *CodeableConcept `json:"scope,omitempty"`
	// Focus of contract interest
	TopicCodeableConcept *CodeableConcept `json:"topicCodeableConcept,omitempty"`
	// Focus of contract interest
	TopicReference *Reference `json:"topicReference,omitempty"`
	// Legal instrument category
	Type *CodeableConcept `json:"type,omitempty"`
	// Subtype within the context of type
	SubType []CodeableConcept `json:"subType,omitempty"`
	// Contract precursor content
	ContentDefinition *ContractContentDefinition `json:"contentDefinition,omitempty"`
	// Contract Term List
	Term []ContractTerm `json:"term,omitempty"`
	// Extra Information
	SupportingInfo []Reference `json:"supportingInfo,omitempty"`
	// Key event in Contract History
	RelevantHistory []Reference `json:"relevantHistory,omitempty"`
	// Contract Signatory
	Signer []ContractSigner `json:"signer,omitempty"`
	// Contract Friendly Language
	Friendly []ContractFriendly `json:"friendly,omitempty"`
	// Contract Legal Language
	Legal []ContractLegal `json:"legal,omitempty"`
	// Computable Contract Language
	Rule []ContractRule `json:"rule,omitempty"`
	// Binding Contract
	LegallyBindingAttachment *Attachment `json:"legallyBindingAttachment,omitempty"`
	// Binding Contract
	LegallyBindingReference *Reference `json:"legallyBindingReference,omitempty"`
}

// GetResourceType returns the FHIR resource type.
func (r *Contract) GetResourceType() string {
	return "Contract"
}

// GetId returns the resource's logical ID.
func (r *Contract) GetId() *string {
	return r.Id
}

// SetId sets the resource's logical ID.
func (r *Contract) SetId(id string) {
	r.Id = &id
}

// GetMeta returns the resource's Meta element.
func (r *Contract) GetMeta() *Meta {
	return r.Meta
}

// SetMeta sets the resource's Meta element.
func (r *Contract) SetMeta(m *Meta) {
	r.Meta = m
}

// GetText returns the resource's narrative text.
func (r *Contract) GetText() *Narrative {
	return r.Text
}

// SetText sets the resource's narrative text.
func (r *Contract) SetText(t *Narrative) {
	r.Text = t
}

// GetContained returns the resource's contained resources.
func (r *Contract) GetContained() []Resource {
	return r.Contained
}

// GetExtension returns the resource's extensions.
func (r *Contract) GetExtension() []Extension {
	return r.Extension
}

// GetModifierExtension returns the resource's modifier extensions.
func (r *Contract) GetModifierExtension() []Extension {
	return r.ModifierExtension
}

// MarshalJSON ensures resourceType is always included in JSON output.
// HTML escaping is disabled to preserve FHIR narrative XHTML content.
//
// Note: Use the package-level Marshal function instead of json.Marshal
// to ensure HTML in narrative text.div fields is not escaped.
func (r Contract) MarshalJSON() ([]byte, error) {
	r.ResourceType = "Contract"
	type Alias Contract
	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	enc.SetEscapeHTML(false)
	if err := enc.Encode((Alias)(r)); err != nil {
		return nil, err
	}
	b := buf.Bytes()
	if len(b) > 0 && b[len(b)-1] == '\n' {
		b = b[:len(b)-1]
	}
	return b, nil
}

// UnmarshalJSON handles deserialization of polymorphic contained resources.
func (r *Contract) UnmarshalJSON(data []byte) error {
	// Use an alias to avoid infinite recursion
	type Alias Contract
	aux := &struct {
		Contained []json.RawMessage `json:"contained,omitempty"`
		*Alias
	}{
		Alias: (*Alias)(r),
	}

	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}

	// Unmarshal each contained resource using the dispatcher
	if len(aux.Contained) > 0 {
		r.Contained = make([]Resource, len(aux.Contained))
		for i, raw := range aux.Contained {
			resource, err := UnmarshalResource(raw)
			if err != nil {
				return fmt.Errorf("failed to unmarshal contained[%d]: %w", i, err)
			}
			r.Contained[i] = resource
		}
	}

	return nil
}

// MarshalXML serializes Contract to FHIR-conformant XML.
func (r Contract) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Contract"
		start.Name.Space = fhirNamespace
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	if err := xmlEncodePrimitiveString(e, "id", r.Id, nil); err != nil {
		return err
	}
	if r.Meta != nil {
		if err := r.Meta.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "meta"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "implicitRules", r.ImplicitRules, r.ImplicitRulesExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "language", r.Language, r.LanguageExt); err != nil {
		return err
	}
	if r.Text != nil {
		if err := r.Text.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "text"}}); err != nil {
			return err
		}
	}
	for _, c := range r.Contained {
		if c != nil {
			if err := xmlEncodeContainedResource(e, c); err != nil {
				return err
			}
		}
	}
	for _, item := range r.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range r.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Identifier {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "identifier"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "url", r.Url, r.UrlExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "version", r.Version, r.VersionExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveCode(e, "status", r.Status, r.StatusExt); err != nil {
		return err
	}
	if r.LegalState != nil {
		if err := r.LegalState.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "legalState"}}); err != nil {
			return err
		}
	}
	if r.InstantiatesCanonical != nil {
		if err := r.InstantiatesCanonical.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "instantiatesCanonical"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "instantiatesUri", r.InstantiatesUri, r.InstantiatesUriExt); err != nil {
		return err
	}
	if r.ContentDerivative != nil {
		if err := r.ContentDerivative.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "contentDerivative"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "issued", r.Issued, r.IssuedExt); err != nil {
		return err
	}
	if r.Applies != nil {
		if err := r.Applies.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "applies"}}); err != nil {
			return err
		}
	}
	if r.ExpirationType != nil {
		if err := r.ExpirationType.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "expirationType"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Subject {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "subject"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Authority {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "authority"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Domain {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "domain"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Site {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "site"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "name", r.Name, r.NameExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "title", r.Title, r.TitleExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "subtitle", r.Subtitle, r.SubtitleExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveStringArray(e, "alias", r.Alias, r.AliasExt); err != nil {
		return err
	}
	if r.Author != nil {
		if err := r.Author.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "author"}}); err != nil {
			return err
		}
	}
	if r.Scope != nil {
		if err := r.Scope.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "scope"}}); err != nil {
			return err
		}
	}
	if r.TopicCodeableConcept != nil {
		if err := r.TopicCodeableConcept.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "topicCodeableConcept"}}); err != nil {
			return err
		}
	}
	if r.TopicReference != nil {
		if err := r.TopicReference.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "topicReference"}}); err != nil {
			return err
		}
	}
	if r.Type != nil {
		if err := r.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
			return err
		}
	}
	for _, item := range r.SubType {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "subType"}}); err != nil {
			return err
		}
	}
	if r.ContentDefinition != nil {
		if err := r.ContentDefinition.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "contentDefinition"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Term {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "term"}}); err != nil {
			return err
		}
	}
	for _, item := range r.SupportingInfo {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "supportingInfo"}}); err != nil {
			return err
		}
	}
	for _, item := range r.RelevantHistory {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "relevantHistory"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Signer {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "signer"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Friendly {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "friendly"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Legal {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "legal"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Rule {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "rule"}}); err != nil {
			return err
		}
	}
	if r.LegallyBindingAttachment != nil {
		if err := r.LegallyBindingAttachment.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "legallyBindingAttachment"}}); err != nil {
			return err
		}
	}
	if r.LegallyBindingReference != nil {
		if err := r.LegallyBindingReference.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "legallyBindingReference"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes Contract from FHIR-conformant XML.
func (r *Contract) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "id":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Id = v
			case "meta":
				var v Meta
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Meta = &v
			case "implicitRules":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ImplicitRules = v
				r.ImplicitRulesExt = ext
			case "language":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Language = v
				r.LanguageExt = ext
			case "text":
				var v Narrative
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Text = &v
			case "contained":
				res, err := xmlDecodeContainedResource(d, t)
				if err != nil {
					return err
				}
				if res != nil {
					r.Contained = append(r.Contained, res)
				}
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "identifier":
				var v Identifier
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Identifier = append(r.Identifier, v)
			case "url":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Url = v
				r.UrlExt = ext
			case "version":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Version = v
				r.VersionExt = ext
			case "status":
				v, ext, err := xmlDecodePrimitiveCode[ContractResourceStatusCodes](d, t)
				if err != nil {
					return err
				}
				r.Status = v
				r.StatusExt = ext
			case "legalState":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.LegalState = &v
			case "instantiatesCanonical":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.InstantiatesCanonical = &v
			case "instantiatesUri":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.InstantiatesUri = v
				r.InstantiatesUriExt = ext
			case "contentDerivative":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ContentDerivative = &v
			case "issued":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Issued = v
				r.IssuedExt = ext
			case "applies":
				var v Period
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Applies = &v
			case "expirationType":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ExpirationType = &v
			case "subject":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Subject = append(r.Subject, v)
			case "authority":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Authority = append(r.Authority, v)
			case "domain":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Domain = append(r.Domain, v)
			case "site":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Site = append(r.Site, v)
			case "name":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Name = v
				r.NameExt = ext
			case "title":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Title = v
				r.TitleExt = ext
			case "subtitle":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Subtitle = v
				r.SubtitleExt = ext
			case "alias":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.Alias = append(r.Alias, *v)
				}
			case "author":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Author = &v
			case "scope":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Scope = &v
			case "topicCodeableConcept":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.TopicCodeableConcept = &v
			case "topicReference":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.TopicReference = &v
			case "type":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Type = &v
			case "subType":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.SubType = append(r.SubType, v)
			case "contentDefinition":
				var v ContractContentDefinition
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ContentDefinition = &v
			case "term":
				var v ContractTerm
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Term = append(r.Term, v)
			case "supportingInfo":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.SupportingInfo = append(r.SupportingInfo, v)
			case "relevantHistory":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.RelevantHistory = append(r.RelevantHistory, v)
			case "signer":
				var v ContractSigner
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Signer = append(r.Signer, v)
			case "friendly":
				var v ContractFriendly
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Friendly = append(r.Friendly, v)
			case "legal":
				var v ContractLegal
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Legal = append(r.Legal, v)
			case "rule":
				var v ContractRule
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Rule = append(r.Rule, v)
			case "legallyBindingAttachment":
				var v Attachment
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.LegallyBindingAttachment = &v
			case "legallyBindingReference":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.LegallyBindingReference = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// ContractContentDefinition represents the Contract.contentDefinition backbone element.
// Contract precursor content
type ContractContentDefinition struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Content structure and use
	Type CodeableConcept `json:"type,omitempty"`
	// Detailed Content Type Definition
	SubType *CodeableConcept `json:"subType,omitempty"`
	// Publisher Entity
	Publisher *Reference `json:"publisher,omitempty"`
	// When published
	PublicationDate *string `json:"publicationDate,omitempty"`
	// amended | appended | cancelled | disputed | entered-in-error | executable | executed | negotiable | offered | policy | rejected | renewed | revoked | resolved | terminated
	PublicationStatus *ContractResourcePublicationStatusCodes `json:"publicationStatus,omitempty"`
	// Publication Ownership
	Copyright *string `json:"copyright,omitempty"`
}

// MarshalXML serializes ContractContentDefinition to FHIR-conformant XML.
func (b ContractContentDefinition) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Contract.contentDefinition"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
		return err
	}
	if b.SubType != nil {
		if err := b.SubType.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "subType"}}); err != nil {
			return err
		}
	}
	if b.Publisher != nil {
		if err := b.Publisher.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "publisher"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "publicationDate", b.PublicationDate, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveCode(e, "publicationStatus", b.PublicationStatus, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "copyright", b.Copyright, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes ContractContentDefinition from FHIR-conformant XML.
func (r *ContractContentDefinition) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "type":
				if err := r.Type.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "subType":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.SubType = &v
			case "publisher":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Publisher = &v
			case "publicationDate":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.PublicationDate = v
			case "publicationStatus":
				v, _, err := xmlDecodePrimitiveCode[ContractResourcePublicationStatusCodes](d, t)
				if err != nil {
					return err
				}
				r.PublicationStatus = v
			case "copyright":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Copyright = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// ContractFriendly represents the Contract.friendly backbone element.
// Contract Friendly Language
type ContractFriendly struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Easily comprehended representation of this Contract
	ContentAttachment *Attachment `json:"contentAttachment,omitempty"`
	// Easily comprehended representation of this Contract
	ContentReference *Reference `json:"contentReference,omitempty"`
}

// MarshalXML serializes ContractFriendly to FHIR-conformant XML.
func (b ContractFriendly) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Contract.friendly"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.ContentAttachment != nil {
		if err := b.ContentAttachment.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "contentAttachment"}}); err != nil {
			return err
		}
	}
	if b.ContentReference != nil {
		if err := b.ContentReference.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "contentReference"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes ContractFriendly from FHIR-conformant XML.
func (r *ContractFriendly) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "contentAttachment":
				var v Attachment
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ContentAttachment = &v
			case "contentReference":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ContentReference = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// ContractLegal represents the Contract.legal backbone element.
// Contract Legal Language
type ContractLegal struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Contract Legal Text
	ContentAttachment *Attachment `json:"contentAttachment,omitempty"`
	// Contract Legal Text
	ContentReference *Reference `json:"contentReference,omitempty"`
}

// MarshalXML serializes ContractLegal to FHIR-conformant XML.
func (b ContractLegal) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Contract.legal"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.ContentAttachment != nil {
		if err := b.ContentAttachment.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "contentAttachment"}}); err != nil {
			return err
		}
	}
	if b.ContentReference != nil {
		if err := b.ContentReference.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "contentReference"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes ContractLegal from FHIR-conformant XML.
func (r *ContractLegal) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "contentAttachment":
				var v Attachment
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ContentAttachment = &v
			case "contentReference":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ContentReference = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// ContractRule represents the Contract.rule backbone element.
// Computable Contract Language
type ContractRule struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Computable Contract Rules
	ContentAttachment *Attachment `json:"contentAttachment,omitempty"`
	// Computable Contract Rules
	ContentReference *Reference `json:"contentReference,omitempty"`
}

// MarshalXML serializes ContractRule to FHIR-conformant XML.
func (b ContractRule) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Contract.rule"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.ContentAttachment != nil {
		if err := b.ContentAttachment.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "contentAttachment"}}); err != nil {
			return err
		}
	}
	if b.ContentReference != nil {
		if err := b.ContentReference.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "contentReference"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes ContractRule from FHIR-conformant XML.
func (r *ContractRule) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "contentAttachment":
				var v Attachment
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ContentAttachment = &v
			case "contentReference":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ContentReference = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// ContractSigner represents the Contract.signer backbone element.
// Contract Signatory
type ContractSigner struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Contract Signatory Role
	Type Coding `json:"type,omitempty"`
	// Contract Signatory Party
	Party Reference `json:"party,omitempty"`
	// Contract Documentation Signature
	Signature []Signature `json:"signature,omitempty"`
}

// MarshalXML serializes ContractSigner to FHIR-conformant XML.
func (b ContractSigner) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Contract.signer"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
		return err
	}
	if err := b.Party.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "party"}}); err != nil {
		return err
	}
	for _, item := range b.Signature {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "signature"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes ContractSigner from FHIR-conformant XML.
func (r *ContractSigner) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "type":
				if err := r.Type.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "party":
				if err := r.Party.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "signature":
				var v Signature
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Signature = append(r.Signature, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// ContractTerm represents the Contract.term backbone element.
// Contract Term List
type ContractTerm struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Contract Term Number
	Identifier *Identifier `json:"identifier,omitempty"`
	// Contract Term Issue Date Time
	Issued *string `json:"issued,omitempty"`
	// Contract Term Effective Time
	Applies *Period `json:"applies,omitempty"`
	// Term Concern
	TopicCodeableConcept *CodeableConcept `json:"topicCodeableConcept,omitempty"`
	// Term Concern
	TopicReference *Reference `json:"topicReference,omitempty"`
	// Contract Term Type or Form
	Type *CodeableConcept `json:"type,omitempty"`
	// Contract Term Type specific classification
	SubType *CodeableConcept `json:"subType,omitempty"`
	// Term Statement
	Text *string `json:"text,omitempty"`
	// Protection for the Term
	SecurityLabel []ContractTermSecurityLabel `json:"securityLabel,omitempty"`
	// Context of the Contract term
	Offer *ContractTermOffer `json:"offer,omitempty"`
	// Contract Term Asset List
	Asset []ContractTermAsset `json:"asset,omitempty"`
	// Entity being ascribed responsibility
	Action []ContractTermAction `json:"action,omitempty"`
	// Nested Contract Term Group
	Group []ContractTerm `json:"group,omitempty"`
}

// MarshalXML serializes ContractTerm to FHIR-conformant XML.
func (b ContractTerm) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Contract.term"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.Identifier != nil {
		if err := b.Identifier.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "identifier"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "issued", b.Issued, nil); err != nil {
		return err
	}
	if b.Applies != nil {
		if err := b.Applies.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "applies"}}); err != nil {
			return err
		}
	}
	if b.TopicCodeableConcept != nil {
		if err := b.TopicCodeableConcept.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "topicCodeableConcept"}}); err != nil {
			return err
		}
	}
	if b.TopicReference != nil {
		if err := b.TopicReference.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "topicReference"}}); err != nil {
			return err
		}
	}
	if b.Type != nil {
		if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
			return err
		}
	}
	if b.SubType != nil {
		if err := b.SubType.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "subType"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "text", b.Text, nil); err != nil {
		return err
	}
	for _, item := range b.SecurityLabel {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "securityLabel"}}); err != nil {
			return err
		}
	}
	if b.Offer != nil {
		if err := b.Offer.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "offer"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Asset {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "asset"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Action {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "action"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Group {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "group"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes ContractTerm from FHIR-conformant XML.
func (r *ContractTerm) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "identifier":
				var v Identifier
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Identifier = &v
			case "issued":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Issued = v
			case "applies":
				var v Period
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Applies = &v
			case "topicCodeableConcept":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.TopicCodeableConcept = &v
			case "topicReference":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.TopicReference = &v
			case "type":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Type = &v
			case "subType":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.SubType = &v
			case "text":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Text = v
			case "securityLabel":
				var v ContractTermSecurityLabel
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.SecurityLabel = append(r.SecurityLabel, v)
			case "offer":
				var v ContractTermOffer
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Offer = &v
			case "asset":
				var v ContractTermAsset
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Asset = append(r.Asset, v)
			case "action":
				var v ContractTermAction
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Action = append(r.Action, v)
			case "group":
				var v ContractTerm
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Group = append(r.Group, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// ContractTermAction represents the Contract.term.action backbone element.
// Entity being ascribed responsibility
type ContractTermAction struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// True if the term prohibits the  action
	DoNotPerform *bool `json:"doNotPerform,omitempty"`
	// Type or form of the action
	Type CodeableConcept `json:"type,omitempty"`
	// Entity of the action
	Subject []ContractTermActionSubject `json:"subject,omitempty"`
	// Purpose for the Contract Term Action
	Intent CodeableConcept `json:"intent,omitempty"`
	// Pointer to specific item
	LinkId []string `json:"linkId,omitempty"`
	// State of the action
	Status CodeableConcept `json:"status,omitempty"`
	// Episode associated with action
	Context *Reference `json:"context,omitempty"`
	// Pointer to specific item
	ContextLinkId []string `json:"contextLinkId,omitempty"`
	// When action happens
	OccurrenceDateTime *string `json:"occurrenceDateTime,omitempty"`
	// Extension for OccurrenceDateTime
	OccurrenceDateTimeExt *Element `json:"_occurrenceDateTime,omitempty"`
	// When action happens
	OccurrencePeriod *Period `json:"occurrencePeriod,omitempty"`
	// When action happens
	OccurrenceTiming *Timing `json:"occurrenceTiming,omitempty"`
	// Who asked for action
	Requester []Reference `json:"requester,omitempty"`
	// Pointer to specific item
	RequesterLinkId []string `json:"requesterLinkId,omitempty"`
	// Kind of service performer
	PerformerType []CodeableConcept `json:"performerType,omitempty"`
	// Competency of the performer
	PerformerRole *CodeableConcept `json:"performerRole,omitempty"`
	// Actor that wil execute (or not) the action
	Performer *Reference `json:"performer,omitempty"`
	// Pointer to specific item
	PerformerLinkId []string `json:"performerLinkId,omitempty"`
	// Why is action (not) needed?
	ReasonCode []CodeableConcept `json:"reasonCode,omitempty"`
	// Why is action (not) needed?
	ReasonReference []Reference `json:"reasonReference,omitempty"`
	// Why action is to be performed
	Reason []string `json:"reason,omitempty"`
	// Pointer to specific item
	ReasonLinkId []string `json:"reasonLinkId,omitempty"`
	// Comments about the action
	Note []Annotation `json:"note,omitempty"`
	// Action restriction numbers
	SecurityLabelNumber []uint32 `json:"securityLabelNumber,omitempty"`
}

// MarshalXML serializes ContractTermAction to FHIR-conformant XML.
func (b ContractTermAction) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Contract.term.action"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveBool(e, "doNotPerform", b.DoNotPerform, nil); err != nil {
		return err
	}
	if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
		return err
	}
	for _, item := range b.Subject {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "subject"}}); err != nil {
			return err
		}
	}
	if err := b.Intent.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "intent"}}); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveStringArray(e, "linkId", b.LinkId, nil); err != nil {
		return err
	}
	if err := b.Status.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "status"}}); err != nil {
		return err
	}
	if b.Context != nil {
		if err := b.Context.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "context"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveStringArray(e, "contextLinkId", b.ContextLinkId, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "occurrenceDateTime", b.OccurrenceDateTime, nil); err != nil {
		return err
	}
	if b.OccurrencePeriod != nil {
		if err := b.OccurrencePeriod.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "occurrencePeriod"}}); err != nil {
			return err
		}
	}
	if b.OccurrenceTiming != nil {
		if err := b.OccurrenceTiming.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "occurrenceTiming"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Requester {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "requester"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveStringArray(e, "requesterLinkId", b.RequesterLinkId, nil); err != nil {
		return err
	}
	for _, item := range b.PerformerType {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "performerType"}}); err != nil {
			return err
		}
	}
	if b.PerformerRole != nil {
		if err := b.PerformerRole.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "performerRole"}}); err != nil {
			return err
		}
	}
	if b.Performer != nil {
		if err := b.Performer.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "performer"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveStringArray(e, "performerLinkId", b.PerformerLinkId, nil); err != nil {
		return err
	}
	for _, item := range b.ReasonCode {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "reasonCode"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ReasonReference {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "reasonReference"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveStringArray(e, "reason", b.Reason, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveStringArray(e, "reasonLinkId", b.ReasonLinkId, nil); err != nil {
		return err
	}
	for _, item := range b.Note {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "note"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveUint32Array(e, "securityLabelNumber", b.SecurityLabelNumber, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes ContractTermAction from FHIR-conformant XML.
func (r *ContractTermAction) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "doNotPerform":
				v, _, err := xmlDecodePrimitiveBool(d, t)
				if err != nil {
					return err
				}
				r.DoNotPerform = v
			case "type":
				if err := r.Type.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "subject":
				var v ContractTermActionSubject
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Subject = append(r.Subject, v)
			case "intent":
				if err := r.Intent.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "linkId":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.LinkId = append(r.LinkId, *v)
				}
			case "status":
				if err := r.Status.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "context":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Context = &v
			case "contextLinkId":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.ContextLinkId = append(r.ContextLinkId, *v)
				}
			case "occurrenceDateTime":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.OccurrenceDateTime = v
			case "occurrencePeriod":
				var v Period
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.OccurrencePeriod = &v
			case "occurrenceTiming":
				var v Timing
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.OccurrenceTiming = &v
			case "requester":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Requester = append(r.Requester, v)
			case "requesterLinkId":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.RequesterLinkId = append(r.RequesterLinkId, *v)
				}
			case "performerType":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.PerformerType = append(r.PerformerType, v)
			case "performerRole":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.PerformerRole = &v
			case "performer":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Performer = &v
			case "performerLinkId":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.PerformerLinkId = append(r.PerformerLinkId, *v)
				}
			case "reasonCode":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ReasonCode = append(r.ReasonCode, v)
			case "reasonReference":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ReasonReference = append(r.ReasonReference, v)
			case "reason":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.Reason = append(r.Reason, *v)
				}
			case "reasonLinkId":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.ReasonLinkId = append(r.ReasonLinkId, *v)
				}
			case "note":
				var v Annotation
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Note = append(r.Note, v)
			case "securityLabelNumber":
				v, _, err := xmlDecodePrimitiveUint32(d, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.SecurityLabelNumber = append(r.SecurityLabelNumber, *v)
				}
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// ContractTermActionSubject represents the Contract.term.action.subject backbone element.
// Entity of the action
type ContractTermActionSubject struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Entity of the action
	Reference []Reference `json:"reference,omitempty"`
	// Role type of the agent
	Role *CodeableConcept `json:"role,omitempty"`
}

// MarshalXML serializes ContractTermActionSubject to FHIR-conformant XML.
func (b ContractTermActionSubject) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Contract.term.action.subject"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Reference {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "reference"}}); err != nil {
			return err
		}
	}
	if b.Role != nil {
		if err := b.Role.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "role"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes ContractTermActionSubject from FHIR-conformant XML.
func (r *ContractTermActionSubject) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "reference":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Reference = append(r.Reference, v)
			case "role":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Role = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// ContractTermAsset represents the Contract.term.asset backbone element.
// Contract Term Asset List
type ContractTermAsset struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Range of asset
	Scope *CodeableConcept `json:"scope,omitempty"`
	// Asset category
	Type []CodeableConcept `json:"type,omitempty"`
	// Associated entities
	TypeReference []Reference `json:"typeReference,omitempty"`
	// Asset sub-category
	Subtype []CodeableConcept `json:"subtype,omitempty"`
	// Kinship of the asset
	Relationship *Coding `json:"relationship,omitempty"`
	// Circumstance of the asset
	Context []ContractTermAssetContext `json:"context,omitempty"`
	// Quality desctiption of asset
	Condition *string `json:"condition,omitempty"`
	// Asset availability types
	PeriodType []CodeableConcept `json:"periodType,omitempty"`
	// Time period of the asset
	Period []Period `json:"period,omitempty"`
	// Time period
	UsePeriod []Period `json:"usePeriod,omitempty"`
	// Asset clause or question text
	Text *string `json:"text,omitempty"`
	// Pointer to asset text
	LinkId []string `json:"linkId,omitempty"`
	// Response to assets
	Answer []ContractTermOfferAnswer `json:"answer,omitempty"`
	// Asset restriction numbers
	SecurityLabelNumber []uint32 `json:"securityLabelNumber,omitempty"`
	// Contract Valued Item List
	ValuedItem []ContractTermAssetValuedItem `json:"valuedItem,omitempty"`
}

// MarshalXML serializes ContractTermAsset to FHIR-conformant XML.
func (b ContractTermAsset) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Contract.term.asset"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.Scope != nil {
		if err := b.Scope.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "scope"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Type {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
			return err
		}
	}
	for _, item := range b.TypeReference {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "typeReference"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Subtype {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "subtype"}}); err != nil {
			return err
		}
	}
	if b.Relationship != nil {
		if err := b.Relationship.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "relationship"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Context {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "context"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "condition", b.Condition, nil); err != nil {
		return err
	}
	for _, item := range b.PeriodType {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "periodType"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Period {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "period"}}); err != nil {
			return err
		}
	}
	for _, item := range b.UsePeriod {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "usePeriod"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "text", b.Text, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveStringArray(e, "linkId", b.LinkId, nil); err != nil {
		return err
	}
	for _, item := range b.Answer {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "answer"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveUint32Array(e, "securityLabelNumber", b.SecurityLabelNumber, nil); err != nil {
		return err
	}
	for _, item := range b.ValuedItem {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valuedItem"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes ContractTermAsset from FHIR-conformant XML.
func (r *ContractTermAsset) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "scope":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Scope = &v
			case "type":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Type = append(r.Type, v)
			case "typeReference":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.TypeReference = append(r.TypeReference, v)
			case "subtype":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Subtype = append(r.Subtype, v)
			case "relationship":
				var v Coding
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Relationship = &v
			case "context":
				var v ContractTermAssetContext
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Context = append(r.Context, v)
			case "condition":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Condition = v
			case "periodType":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.PeriodType = append(r.PeriodType, v)
			case "period":
				var v Period
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Period = append(r.Period, v)
			case "usePeriod":
				var v Period
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.UsePeriod = append(r.UsePeriod, v)
			case "text":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Text = v
			case "linkId":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.LinkId = append(r.LinkId, *v)
				}
			case "answer":
				var v ContractTermOfferAnswer
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Answer = append(r.Answer, v)
			case "securityLabelNumber":
				v, _, err := xmlDecodePrimitiveUint32(d, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.SecurityLabelNumber = append(r.SecurityLabelNumber, *v)
				}
			case "valuedItem":
				var v ContractTermAssetValuedItem
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValuedItem = append(r.ValuedItem, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// ContractTermAssetContext represents the Contract.term.asset.context backbone element.
// Circumstance of the asset
type ContractTermAssetContext struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Creator,custodian or owner
	Reference *Reference `json:"reference,omitempty"`
	// Codeable asset context
	Code []CodeableConcept `json:"code,omitempty"`
	// Context description
	Text *string `json:"text,omitempty"`
}

// MarshalXML serializes ContractTermAssetContext to FHIR-conformant XML.
func (b ContractTermAssetContext) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Contract.term.asset.context"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.Reference != nil {
		if err := b.Reference.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "reference"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Code {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "code"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "text", b.Text, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes ContractTermAssetContext from FHIR-conformant XML.
func (r *ContractTermAssetContext) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "reference":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Reference = &v
			case "code":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Code = append(r.Code, v)
			case "text":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Text = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// ContractTermAssetValuedItem represents the Contract.term.asset.valuedItem backbone element.
// Contract Valued Item List
type ContractTermAssetValuedItem struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Contract Valued Item Type
	EntityCodeableConcept *CodeableConcept `json:"entityCodeableConcept,omitempty"`
	// Contract Valued Item Type
	EntityReference *Reference `json:"entityReference,omitempty"`
	// Contract Valued Item Number
	Identifier *Identifier `json:"identifier,omitempty"`
	// Contract Valued Item Effective Tiem
	EffectiveTime *string `json:"effectiveTime,omitempty"`
	// Count of Contract Valued Items
	Quantity *Quantity `json:"quantity,omitempty"`
	// Contract Valued Item fee, charge, or cost
	UnitPrice *Money `json:"unitPrice,omitempty"`
	// Contract Valued Item Price Scaling Factor
	Factor *Decimal `json:"factor,omitempty"`
	// Contract Valued Item Difficulty Scaling Factor
	Points *Decimal `json:"points,omitempty"`
	// Total Contract Valued Item Value
	Net *Money `json:"net,omitempty"`
	// Terms of valuation
	Payment *string `json:"payment,omitempty"`
	// When payment is due
	PaymentDate *string `json:"paymentDate,omitempty"`
	// Who will make payment
	Responsible *Reference `json:"responsible,omitempty"`
	// Who will receive payment
	Recipient *Reference `json:"recipient,omitempty"`
	// Pointer to specific item
	LinkId []string `json:"linkId,omitempty"`
	// Security Labels that define affected terms
	SecurityLabelNumber []uint32 `json:"securityLabelNumber,omitempty"`
}

// MarshalXML serializes ContractTermAssetValuedItem to FHIR-conformant XML.
func (b ContractTermAssetValuedItem) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Contract.term.asset.valuedItem"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.EntityCodeableConcept != nil {
		if err := b.EntityCodeableConcept.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "entityCodeableConcept"}}); err != nil {
			return err
		}
	}
	if b.EntityReference != nil {
		if err := b.EntityReference.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "entityReference"}}); err != nil {
			return err
		}
	}
	if b.Identifier != nil {
		if err := b.Identifier.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "identifier"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "effectiveTime", b.EffectiveTime, nil); err != nil {
		return err
	}
	if b.Quantity != nil {
		if err := b.Quantity.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "quantity"}}); err != nil {
			return err
		}
	}
	if b.UnitPrice != nil {
		if err := b.UnitPrice.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "unitPrice"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveDecimal(e, "factor", b.Factor, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveDecimal(e, "points", b.Points, nil); err != nil {
		return err
	}
	if b.Net != nil {
		if err := b.Net.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "net"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "payment", b.Payment, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "paymentDate", b.PaymentDate, nil); err != nil {
		return err
	}
	if b.Responsible != nil {
		if err := b.Responsible.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "responsible"}}); err != nil {
			return err
		}
	}
	if b.Recipient != nil {
		if err := b.Recipient.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "recipient"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveStringArray(e, "linkId", b.LinkId, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveUint32Array(e, "securityLabelNumber", b.SecurityLabelNumber, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes ContractTermAssetValuedItem from FHIR-conformant XML.
func (r *ContractTermAssetValuedItem) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "entityCodeableConcept":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.EntityCodeableConcept = &v
			case "entityReference":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.EntityReference = &v
			case "identifier":
				var v Identifier
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Identifier = &v
			case "effectiveTime":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.EffectiveTime = v
			case "quantity":
				var v Quantity
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Quantity = &v
			case "unitPrice":
				var v Money
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.UnitPrice = &v
			case "factor":
				v, _, err := xmlDecodePrimitiveDecimal(d, t)
				if err != nil {
					return err
				}
				r.Factor = v
			case "points":
				v, _, err := xmlDecodePrimitiveDecimal(d, t)
				if err != nil {
					return err
				}
				r.Points = v
			case "net":
				var v Money
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Net = &v
			case "payment":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Payment = v
			case "paymentDate":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.PaymentDate = v
			case "responsible":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Responsible = &v
			case "recipient":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Recipient = &v
			case "linkId":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.LinkId = append(r.LinkId, *v)
				}
			case "securityLabelNumber":
				v, _, err := xmlDecodePrimitiveUint32(d, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.SecurityLabelNumber = append(r.SecurityLabelNumber, *v)
				}
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// ContractTermOffer represents the Contract.term.offer backbone element.
// Context of the Contract term
type ContractTermOffer struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Offer business ID
	Identifier []Identifier `json:"identifier,omitempty"`
	// Offer Recipient
	Party []ContractTermOfferParty `json:"party,omitempty"`
	// Negotiable offer asset
	Topic *Reference `json:"topic,omitempty"`
	// Contract Offer Type or Form
	Type *CodeableConcept `json:"type,omitempty"`
	// Accepting party choice
	Decision *CodeableConcept `json:"decision,omitempty"`
	// How decision is conveyed
	DecisionMode []CodeableConcept `json:"decisionMode,omitempty"`
	// Response to offer text
	Answer []ContractTermOfferAnswer `json:"answer,omitempty"`
	// Human readable offer text
	Text *string `json:"text,omitempty"`
	// Pointer to text
	LinkId []string `json:"linkId,omitempty"`
	// Offer restriction numbers
	SecurityLabelNumber []uint32 `json:"securityLabelNumber,omitempty"`
}

// MarshalXML serializes ContractTermOffer to FHIR-conformant XML.
func (b ContractTermOffer) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Contract.term.offer"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Identifier {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "identifier"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Party {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "party"}}); err != nil {
			return err
		}
	}
	if b.Topic != nil {
		if err := b.Topic.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "topic"}}); err != nil {
			return err
		}
	}
	if b.Type != nil {
		if err := b.Type.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "type"}}); err != nil {
			return err
		}
	}
	if b.Decision != nil {
		if err := b.Decision.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "decision"}}); err != nil {
			return err
		}
	}
	for _, item := range b.DecisionMode {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "decisionMode"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Answer {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "answer"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "text", b.Text, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveStringArray(e, "linkId", b.LinkId, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveUint32Array(e, "securityLabelNumber", b.SecurityLabelNumber, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes ContractTermOffer from FHIR-conformant XML.
func (r *ContractTermOffer) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "identifier":
				var v Identifier
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Identifier = append(r.Identifier, v)
			case "party":
				var v ContractTermOfferParty
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Party = append(r.Party, v)
			case "topic":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Topic = &v
			case "type":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Type = &v
			case "decision":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Decision = &v
			case "decisionMode":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.DecisionMode = append(r.DecisionMode, v)
			case "answer":
				var v ContractTermOfferAnswer
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Answer = append(r.Answer, v)
			case "text":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Text = v
			case "linkId":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.LinkId = append(r.LinkId, *v)
				}
			case "securityLabelNumber":
				v, _, err := xmlDecodePrimitiveUint32(d, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.SecurityLabelNumber = append(r.SecurityLabelNumber, *v)
				}
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// ContractTermOfferAnswer represents the Contract.term.offer.answer backbone element.
// Response to offer text
type ContractTermOfferAnswer struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The actual answer response
	ValueBoolean *bool `json:"valueBoolean,omitempty"`
	// Extension for ValueBoolean
	ValueBooleanExt *Element `json:"_valueBoolean,omitempty"`
	// The actual answer response
	ValueDecimal *Decimal `json:"valueDecimal,omitempty"`
	// Extension for ValueDecimal
	ValueDecimalExt *Element `json:"_valueDecimal,omitempty"`
	// The actual answer response
	ValueInteger *int `json:"valueInteger,omitempty"`
	// Extension for ValueInteger
	ValueIntegerExt *Element `json:"_valueInteger,omitempty"`
	// The actual answer response
	ValueDate *string `json:"valueDate,omitempty"`
	// Extension for ValueDate
	ValueDateExt *Element `json:"_valueDate,omitempty"`
	// The actual answer response
	ValueDateTime *string `json:"valueDateTime,omitempty"`
	// Extension for ValueDateTime
	ValueDateTimeExt *Element `json:"_valueDateTime,omitempty"`
	// The actual answer response
	ValueTime *string `json:"valueTime,omitempty"`
	// Extension for ValueTime
	ValueTimeExt *Element `json:"_valueTime,omitempty"`
	// The actual answer response
	ValueString *string `json:"valueString,omitempty"`
	// Extension for ValueString
	ValueStringExt *Element `json:"_valueString,omitempty"`
	// The actual answer response
	ValueUri *string `json:"valueUri,omitempty"`
	// Extension for ValueUri
	ValueUriExt *Element `json:"_valueUri,omitempty"`
	// The actual answer response
	ValueAttachment *Attachment `json:"valueAttachment,omitempty"`
	// The actual answer response
	ValueCoding *Coding `json:"valueCoding,omitempty"`
	// The actual answer response
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`
	// The actual answer response
	ValueReference *Reference `json:"valueReference,omitempty"`
}

// MarshalXML serializes ContractTermOfferAnswer to FHIR-conformant XML.
func (b ContractTermOfferAnswer) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Contract.term.offer.answer"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveBool(e, "valueBoolean", b.ValueBoolean, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveDecimal(e, "valueDecimal", b.ValueDecimal, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveInt(e, "valueInteger", b.ValueInteger, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "valueDate", b.ValueDate, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "valueDateTime", b.ValueDateTime, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "valueTime", b.ValueTime, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "valueString", b.ValueString, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "valueUri", b.ValueUri, nil); err != nil {
		return err
	}
	if b.ValueAttachment != nil {
		if err := b.ValueAttachment.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueAttachment"}}); err != nil {
			return err
		}
	}
	if b.ValueCoding != nil {
		if err := b.ValueCoding.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueCoding"}}); err != nil {
			return err
		}
	}
	if b.ValueQuantity != nil {
		if err := b.ValueQuantity.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueQuantity"}}); err != nil {
			return err
		}
	}
	if b.ValueReference != nil {
		if err := b.ValueReference.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "valueReference"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes ContractTermOfferAnswer from FHIR-conformant XML.
func (r *ContractTermOfferAnswer) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "valueBoolean":
				v, _, err := xmlDecodePrimitiveBool(d, t)
				if err != nil {
					return err
				}
				r.ValueBoolean = v
			case "valueDecimal":
				v, _, err := xmlDecodePrimitiveDecimal(d, t)
				if err != nil {
					return err
				}
				r.ValueDecimal = v
			case "valueInteger":
				v, _, err := xmlDecodePrimitiveInt(d, t)
				if err != nil {
					return err
				}
				r.ValueInteger = v
			case "valueDate":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ValueDate = v
			case "valueDateTime":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ValueDateTime = v
			case "valueTime":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ValueTime = v
			case "valueString":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ValueString = v
			case "valueUri":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ValueUri = v
			case "valueAttachment":
				var v Attachment
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueAttachment = &v
			case "valueCoding":
				var v Coding
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueCoding = &v
			case "valueQuantity":
				var v Quantity
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueQuantity = &v
			case "valueReference":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ValueReference = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// ContractTermOfferParty represents the Contract.term.offer.party backbone element.
// Offer Recipient
type ContractTermOfferParty struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Referenced entity
	Reference []Reference `json:"reference,omitempty"`
	// Participant engagement type
	Role CodeableConcept `json:"role,omitempty"`
}

// MarshalXML serializes ContractTermOfferParty to FHIR-conformant XML.
func (b ContractTermOfferParty) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Contract.term.offer.party"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Reference {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "reference"}}); err != nil {
			return err
		}
	}
	if err := b.Role.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "role"}}); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes ContractTermOfferParty from FHIR-conformant XML.
func (r *ContractTermOfferParty) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "reference":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Reference = append(r.Reference, v)
			case "role":
				if err := r.Role.UnmarshalXML(d, t); err != nil {
					return err
				}
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// ContractTermSecurityLabel represents the Contract.term.securityLabel backbone element.
// Protection for the Term
type ContractTermSecurityLabel struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Link to Security Labels
	Number []uint32 `json:"number,omitempty"`
	// Confidentiality Protection
	Classification Coding `json:"classification,omitempty"`
	// Applicable Policy
	Category []Coding `json:"category,omitempty"`
	// Handling Instructions
	Control []Coding `json:"control,omitempty"`
}

// MarshalXML serializes ContractTermSecurityLabel to FHIR-conformant XML.
func (b ContractTermSecurityLabel) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "Contract.term.securityLabel"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveUint32Array(e, "number", b.Number, nil); err != nil {
		return err
	}
	if err := b.Classification.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "classification"}}); err != nil {
		return err
	}
	for _, item := range b.Category {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "category"}}); err != nil {
			return err
		}
	}
	for _, item := range b.Control {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "control"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes ContractTermSecurityLabel from FHIR-conformant XML.
func (r *ContractTermSecurityLabel) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "number":
				v, _, err := xmlDecodePrimitiveUint32(d, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.Number = append(r.Number, *v)
				}
			case "classification":
				if err := r.Classification.UnmarshalXML(d, t); err != nil {
					return err
				}
			case "category":
				var v Coding
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Category = append(r.Category, v)
			case "control":
				var v Coding
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Control = append(r.Control, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// =============================================================================
// Contract - Fluent Builder
// =============================================================================

// ContractBuilder provides a fluent API for constructing Contract resources.
type ContractBuilder struct {
	contract *Contract
}

// NewContractBuilder creates a new ContractBuilder.
func NewContractBuilder() *ContractBuilder {
	return &ContractBuilder{
		contract: &Contract{},
	}
}

// Build returns the constructed Contract resource.
func (b *ContractBuilder) Build() *Contract {
	return b.contract
}

// SetId sets the Id field.
func (b *ContractBuilder) SetId(v string) *ContractBuilder {
	b.contract.Id = &v
	return b
}

// SetMeta sets the Meta field.
func (b *ContractBuilder) SetMeta(v Meta) *ContractBuilder {
	b.contract.Meta = &v
	return b
}

// SetImplicitRules sets the ImplicitRules field.
func (b *ContractBuilder) SetImplicitRules(v string) *ContractBuilder {
	b.contract.ImplicitRules = &v
	return b
}

// SetLanguage sets the Language field.
func (b *ContractBuilder) SetLanguage(v string) *ContractBuilder {
	b.contract.Language = &v
	return b
}

// SetText sets the Text field.
func (b *ContractBuilder) SetText(v Narrative) *ContractBuilder {
	b.contract.Text = &v
	return b
}

// AddContained adds a Contained element.
func (b *ContractBuilder) AddContained(v Resource) *ContractBuilder {
	b.contract.Contained = append(b.contract.Contained, v)
	return b
}

// AddExtension adds a Extension element.
func (b *ContractBuilder) AddExtension(v Extension) *ContractBuilder {
	b.contract.Extension = append(b.contract.Extension, v)
	return b
}

// AddModifierExtension adds a ModifierExtension element.
func (b *ContractBuilder) AddModifierExtension(v Extension) *ContractBuilder {
	b.contract.ModifierExtension = append(b.contract.ModifierExtension, v)
	return b
}

// AddIdentifier adds a Identifier element.
func (b *ContractBuilder) AddIdentifier(v Identifier) *ContractBuilder {
	b.contract.Identifier = append(b.contract.Identifier, v)
	return b
}

// SetUrl sets the Url field.
func (b *ContractBuilder) SetUrl(v string) *ContractBuilder {
	b.contract.Url = &v
	return b
}

// SetVersion sets the Version field.
func (b *ContractBuilder) SetVersion(v string) *ContractBuilder {
	b.contract.Version = &v
	return b
}

// SetStatus sets the Status field.
func (b *ContractBuilder) SetStatus(v ContractResourceStatusCodes) *ContractBuilder {
	b.contract.Status = &v
	return b
}

// SetLegalState sets the LegalState field.
func (b *ContractBuilder) SetLegalState(v CodeableConcept) *ContractBuilder {
	b.contract.LegalState = &v
	return b
}

// SetInstantiatesCanonical sets the InstantiatesCanonical field.
func (b *ContractBuilder) SetInstantiatesCanonical(v Reference) *ContractBuilder {
	b.contract.InstantiatesCanonical = &v
	return b
}

// SetInstantiatesUri sets the InstantiatesUri field.
func (b *ContractBuilder) SetInstantiatesUri(v string) *ContractBuilder {
	b.contract.InstantiatesUri = &v
	return b
}

// SetContentDerivative sets the ContentDerivative field.
func (b *ContractBuilder) SetContentDerivative(v CodeableConcept) *ContractBuilder {
	b.contract.ContentDerivative = &v
	return b
}

// SetIssued sets the Issued field.
func (b *ContractBuilder) SetIssued(v string) *ContractBuilder {
	b.contract.Issued = &v
	return b
}

// SetApplies sets the Applies field.
func (b *ContractBuilder) SetApplies(v Period) *ContractBuilder {
	b.contract.Applies = &v
	return b
}

// SetExpirationType sets the ExpirationType field.
func (b *ContractBuilder) SetExpirationType(v CodeableConcept) *ContractBuilder {
	b.contract.ExpirationType = &v
	return b
}

// AddSubject adds a Subject element.
func (b *ContractBuilder) AddSubject(v Reference) *ContractBuilder {
	b.contract.Subject = append(b.contract.Subject, v)
	return b
}

// AddAuthority adds a Authority element.
func (b *ContractBuilder) AddAuthority(v Reference) *ContractBuilder {
	b.contract.Authority = append(b.contract.Authority, v)
	return b
}

// AddDomain adds a Domain element.
func (b *ContractBuilder) AddDomain(v Reference) *ContractBuilder {
	b.contract.Domain = append(b.contract.Domain, v)
	return b
}

// AddSite adds a Site element.
func (b *ContractBuilder) AddSite(v Reference) *ContractBuilder {
	b.contract.Site = append(b.contract.Site, v)
	return b
}

// SetName sets the Name field.
func (b *ContractBuilder) SetName(v string) *ContractBuilder {
	b.contract.Name = &v
	return b
}

// SetTitle sets the Title field.
func (b *ContractBuilder) SetTitle(v string) *ContractBuilder {
	b.contract.Title = &v
	return b
}

// SetSubtitle sets the Subtitle field.
func (b *ContractBuilder) SetSubtitle(v string) *ContractBuilder {
	b.contract.Subtitle = &v
	return b
}

// AddAlias adds a Alias element.
func (b *ContractBuilder) AddAlias(v string) *ContractBuilder {
	b.contract.Alias = append(b.contract.Alias, v)
	return b
}

// SetAuthor sets the Author field.
func (b *ContractBuilder) SetAuthor(v Reference) *ContractBuilder {
	b.contract.Author = &v
	return b
}

// SetScope sets the Scope field.
func (b *ContractBuilder) SetScope(v CodeableConcept) *ContractBuilder {
	b.contract.Scope = &v
	return b
}

// SetTopicCodeableConcept sets the TopicCodeableConcept field.
func (b *ContractBuilder) SetTopicCodeableConcept(v CodeableConcept) *ContractBuilder {
	b.contract.TopicCodeableConcept = &v
	return b
}

// SetTopicReference sets the TopicReference field.
func (b *ContractBuilder) SetTopicReference(v Reference) *ContractBuilder {
	b.contract.TopicReference = &v
	return b
}

// SetType sets the Type field.
func (b *ContractBuilder) SetType(v CodeableConcept) *ContractBuilder {
	b.contract.Type = &v
	return b
}

// AddSubType adds a SubType element.
func (b *ContractBuilder) AddSubType(v CodeableConcept) *ContractBuilder {
	b.contract.SubType = append(b.contract.SubType, v)
	return b
}

// SetContentDefinition sets the ContentDefinition field.
func (b *ContractBuilder) SetContentDefinition(v ContractContentDefinition) *ContractBuilder {
	b.contract.ContentDefinition = &v
	return b
}

// AddTerm adds a Term element.
func (b *ContractBuilder) AddTerm(v ContractTerm) *ContractBuilder {
	b.contract.Term = append(b.contract.Term, v)
	return b
}

// AddSupportingInfo adds a SupportingInfo element.
func (b *ContractBuilder) AddSupportingInfo(v Reference) *ContractBuilder {
	b.contract.SupportingInfo = append(b.contract.SupportingInfo, v)
	return b
}

// AddRelevantHistory adds a RelevantHistory element.
func (b *ContractBuilder) AddRelevantHistory(v Reference) *ContractBuilder {
	b.contract.RelevantHistory = append(b.contract.RelevantHistory, v)
	return b
}

// AddSigner adds a Signer element.
func (b *ContractBuilder) AddSigner(v ContractSigner) *ContractBuilder {
	b.contract.Signer = append(b.contract.Signer, v)
	return b
}

// AddFriendly adds a Friendly element.
func (b *ContractBuilder) AddFriendly(v ContractFriendly) *ContractBuilder {
	b.contract.Friendly = append(b.contract.Friendly, v)
	return b
}

// AddLegal adds a Legal element.
func (b *ContractBuilder) AddLegal(v ContractLegal) *ContractBuilder {
	b.contract.Legal = append(b.contract.Legal, v)
	return b
}

// AddRule adds a Rule element.
func (b *ContractBuilder) AddRule(v ContractRule) *ContractBuilder {
	b.contract.Rule = append(b.contract.Rule, v)
	return b
}

// SetLegallyBindingAttachment sets the LegallyBindingAttachment field.
func (b *ContractBuilder) SetLegallyBindingAttachment(v Attachment) *ContractBuilder {
	b.contract.LegallyBindingAttachment = &v
	return b
}

// SetLegallyBindingReference sets the LegallyBindingReference field.
func (b *ContractBuilder) SetLegallyBindingReference(v Reference) *ContractBuilder {
	b.contract.LegallyBindingReference = &v
	return b
}

// =============================================================================
// Contract - Functional Options
// =============================================================================

// ContractOption is a functional option for configuring a Contract.
type ContractOption func(*Contract)

// NewContract creates a new Contract with the given options.
func NewContract(opts ...ContractOption) *Contract {
	r := &Contract{}
	for _, opt := range opts {
		opt(r)
	}
	return r
}

// WithContractId sets the Id field.
func WithContractId(v string) ContractOption {
	return func(r *Contract) {
		r.Id = &v
	}
}

// WithContractMeta sets the Meta field.
func WithContractMeta(v Meta) ContractOption {
	return func(r *Contract) {
		r.Meta = &v
	}
}

// WithContractImplicitRules sets the ImplicitRules field.
func WithContractImplicitRules(v string) ContractOption {
	return func(r *Contract) {
		r.ImplicitRules = &v
	}
}

// WithContractLanguage sets the Language field.
func WithContractLanguage(v string) ContractOption {
	return func(r *Contract) {
		r.Language = &v
	}
}

// WithContractText sets the Text field.
func WithContractText(v Narrative) ContractOption {
	return func(r *Contract) {
		r.Text = &v
	}
}

// WithContractContained adds a Contained to the Contract.
func WithContractContained(v Resource) ContractOption {
	return func(r *Contract) {
		r.Contained = append(r.Contained, v)
	}
}

// WithContractExtension adds a Extension to the Contract.
func WithContractExtension(v Extension) ContractOption {
	return func(r *Contract) {
		r.Extension = append(r.Extension, v)
	}
}

// WithContractModifierExtension adds a ModifierExtension to the Contract.
func WithContractModifierExtension(v Extension) ContractOption {
	return func(r *Contract) {
		r.ModifierExtension = append(r.ModifierExtension, v)
	}
}

// WithContractIdentifier adds a Identifier to the Contract.
func WithContractIdentifier(v Identifier) ContractOption {
	return func(r *Contract) {
		r.Identifier = append(r.Identifier, v)
	}
}

// WithContractUrl sets the Url field.
func WithContractUrl(v string) ContractOption {
	return func(r *Contract) {
		r.Url = &v
	}
}

// WithContractVersion sets the Version field.
func WithContractVersion(v string) ContractOption {
	return func(r *Contract) {
		r.Version = &v
	}
}

// WithContractStatus sets the Status field.
func WithContractStatus(v ContractResourceStatusCodes) ContractOption {
	return func(r *Contract) {
		r.Status = &v
	}
}

// WithContractLegalState sets the LegalState field.
func WithContractLegalState(v CodeableConcept) ContractOption {
	return func(r *Contract) {
		r.LegalState = &v
	}
}

// WithContractInstantiatesCanonical sets the InstantiatesCanonical field.
func WithContractInstantiatesCanonical(v Reference) ContractOption {
	return func(r *Contract) {
		r.InstantiatesCanonical = &v
	}
}

// WithContractInstantiatesUri sets the InstantiatesUri field.
func WithContractInstantiatesUri(v string) ContractOption {
	return func(r *Contract) {
		r.InstantiatesUri = &v
	}
}

// WithContractContentDerivative sets the ContentDerivative field.
func WithContractContentDerivative(v CodeableConcept) ContractOption {
	return func(r *Contract) {
		r.ContentDerivative = &v
	}
}

// WithContractIssued sets the Issued field.
func WithContractIssued(v string) ContractOption {
	return func(r *Contract) {
		r.Issued = &v
	}
}

// WithContractApplies sets the Applies field.
func WithContractApplies(v Period) ContractOption {
	return func(r *Contract) {
		r.Applies = &v
	}
}

// WithContractExpirationType sets the ExpirationType field.
func WithContractExpirationType(v CodeableConcept) ContractOption {
	return func(r *Contract) {
		r.ExpirationType = &v
	}
}

// WithContractSubject adds a Subject to the Contract.
func WithContractSubject(v Reference) ContractOption {
	return func(r *Contract) {
		r.Subject = append(r.Subject, v)
	}
}

// WithContractAuthority adds a Authority to the Contract.
func WithContractAuthority(v Reference) ContractOption {
	return func(r *Contract) {
		r.Authority = append(r.Authority, v)
	}
}

// WithContractDomain adds a Domain to the Contract.
func WithContractDomain(v Reference) ContractOption {
	return func(r *Contract) {
		r.Domain = append(r.Domain, v)
	}
}

// WithContractSite adds a Site to the Contract.
func WithContractSite(v Reference) ContractOption {
	return func(r *Contract) {
		r.Site = append(r.Site, v)
	}
}

// WithContractName sets the Name field.
func WithContractName(v string) ContractOption {
	return func(r *Contract) {
		r.Name = &v
	}
}

// WithContractTitle sets the Title field.
func WithContractTitle(v string) ContractOption {
	return func(r *Contract) {
		r.Title = &v
	}
}

// WithContractSubtitle sets the Subtitle field.
func WithContractSubtitle(v string) ContractOption {
	return func(r *Contract) {
		r.Subtitle = &v
	}
}

// WithContractAlias adds a Alias to the Contract.
func WithContractAlias(v string) ContractOption {
	return func(r *Contract) {
		r.Alias = append(r.Alias, v)
	}
}

// WithContractAuthor sets the Author field.
func WithContractAuthor(v Reference) ContractOption {
	return func(r *Contract) {
		r.Author = &v
	}
}

// WithContractScope sets the Scope field.
func WithContractScope(v CodeableConcept) ContractOption {
	return func(r *Contract) {
		r.Scope = &v
	}
}

// WithContractTopicCodeableConcept sets the TopicCodeableConcept field.
func WithContractTopicCodeableConcept(v CodeableConcept) ContractOption {
	return func(r *Contract) {
		r.TopicCodeableConcept = &v
	}
}

// WithContractTopicReference sets the TopicReference field.
func WithContractTopicReference(v Reference) ContractOption {
	return func(r *Contract) {
		r.TopicReference = &v
	}
}

// WithContractType sets the Type field.
func WithContractType(v CodeableConcept) ContractOption {
	return func(r *Contract) {
		r.Type = &v
	}
}

// WithContractSubType adds a SubType to the Contract.
func WithContractSubType(v CodeableConcept) ContractOption {
	return func(r *Contract) {
		r.SubType = append(r.SubType, v)
	}
}

// WithContractContentDefinition sets the ContentDefinition field.
func WithContractContentDefinition(v ContractContentDefinition) ContractOption {
	return func(r *Contract) {
		r.ContentDefinition = &v
	}
}

// WithContractTerm adds a Term to the Contract.
func WithContractTerm(v ContractTerm) ContractOption {
	return func(r *Contract) {
		r.Term = append(r.Term, v)
	}
}

// WithContractSupportingInfo adds a SupportingInfo to the Contract.
func WithContractSupportingInfo(v Reference) ContractOption {
	return func(r *Contract) {
		r.SupportingInfo = append(r.SupportingInfo, v)
	}
}

// WithContractRelevantHistory adds a RelevantHistory to the Contract.
func WithContractRelevantHistory(v Reference) ContractOption {
	return func(r *Contract) {
		r.RelevantHistory = append(r.RelevantHistory, v)
	}
}

// WithContractSigner adds a Signer to the Contract.
func WithContractSigner(v ContractSigner) ContractOption {
	return func(r *Contract) {
		r.Signer = append(r.Signer, v)
	}
}

// WithContractFriendly adds a Friendly to the Contract.
func WithContractFriendly(v ContractFriendly) ContractOption {
	return func(r *Contract) {
		r.Friendly = append(r.Friendly, v)
	}
}

// WithContractLegal adds a Legal to the Contract.
func WithContractLegal(v ContractLegal) ContractOption {
	return func(r *Contract) {
		r.Legal = append(r.Legal, v)
	}
}

// WithContractRule adds a Rule to the Contract.
func WithContractRule(v ContractRule) ContractOption {
	return func(r *Contract) {
		r.Rule = append(r.Rule, v)
	}
}

// WithContractLegallyBindingAttachment sets the LegallyBindingAttachment field.
func WithContractLegallyBindingAttachment(v Attachment) ContractOption {
	return func(r *Contract) {
		r.LegallyBindingAttachment = &v
	}
}

// WithContractLegallyBindingReference sets the LegallyBindingReference field.
func WithContractLegallyBindingReference(v Reference) ContractOption {
	return func(r *Contract) {
		r.LegallyBindingReference = &v
	}
}
