// Code generated by gofhir. DO NOT EDIT.
// Source: FHIR decimal type
// Package: r4b

package r4b

import (
	"fmt"
	"math"
	"strconv"
)

// Decimal represents a FHIR decimal value with precision preservation.
// Unlike float64, Decimal preserves the exact textual representation (e.g., "1.50"
// retains the trailing zero) as required by the FHIR specification.
type Decimal struct {
	value string
}

// NewDecimalFromFloat64 creates a Decimal from a float64 value.
// Note: precision may be lost during float64 conversion (e.g., 1.50 becomes "1.5").
// Use NewDecimalFromString for precision-preserving construction.
func NewDecimalFromFloat64(f float64) *Decimal {
	return &Decimal{value: strconv.FormatFloat(f, 'f', -1, 64)}
}

// NewDecimalFromString creates a Decimal from a string representation.
// The string must be a valid decimal number (e.g., "1.50", "-3.14", "100").
// Returns an error if the string is not a valid decimal.
func NewDecimalFromString(s string) (*Decimal, error) {
	if s == "" {
		return nil, fmt.Errorf("empty decimal string")
	}
	f, err := strconv.ParseFloat(s, 64)
	if err != nil {
		return nil, fmt.Errorf("invalid decimal %q: %w", s, err)
	}
	if math.IsNaN(f) || math.IsInf(f, 0) {
		return nil, fmt.Errorf("invalid decimal %q: NaN and Infinity are not allowed", s)
	}
	return &Decimal{value: s}, nil
}

// MustDecimal creates a Decimal from a string, panicking on invalid input.
// Use only for compile-time constant values.
func MustDecimal(s string) *Decimal {
	d, err := NewDecimalFromString(s)
	if err != nil {
		panic(err)
	}
	return d
}

// NewDecimalFromInt creates a Decimal from an int value.
func NewDecimalFromInt(i int) *Decimal {
	return &Decimal{value: strconv.Itoa(i)}
}

// NewDecimalFromInt64 creates a Decimal from an int64 value.
func NewDecimalFromInt64(i int64) *Decimal {
	return &Decimal{value: strconv.FormatInt(i, 10)}
}

// String returns the exact textual representation of the decimal.
func (d Decimal) String() string {
	return d.value
}

// Float64 returns the decimal as a float64 value.
// Precision may be lost in the conversion.
func (d Decimal) Float64() float64 {
	f, _ := strconv.ParseFloat(d.value, 64)
	return f
}

// IsZero returns true if the decimal value is zero or empty.
func (d Decimal) IsZero() bool {
	if d.value == "" {
		return true
	}
	f, err := strconv.ParseFloat(d.value, 64)
	if err != nil {
		return false
	}
	return f == 0
}

// Equal returns true if two Decimal values represent the same numeric value.
// This compares numeric values, not textual representation (e.g., "1.0" equals "1.00").
func (d Decimal) Equal(other Decimal) bool {
	return d.Float64() == other.Float64()
}

// MarshalJSON implements json.Marshaler.
// Emits the decimal as a bare JSON number, preserving the original precision
// (e.g., Decimal("1.50") marshals as 1.50, not "1.50" or 1.5).
func (d Decimal) MarshalJSON() ([]byte, error) {
	if d.value == "" {
		return []byte("0"), nil
	}
	return []byte(d.value), nil
}

// UnmarshalJSON implements json.Unmarshaler.
// Accepts a bare JSON number and stores the exact byte representation,
// preserving precision (e.g., 1.50 is stored as "1.50").
func (d *Decimal) UnmarshalJSON(data []byte) error {
	if string(data) == "null" {
		return nil
	}
	s := string(data)
	// Strip quotes if present (some encoders may quote numbers)
	if len(s) >= 2 && s[0] == '"' && s[len(s)-1] == '"' {
		s = s[1 : len(s)-1]
	}
	f, err := strconv.ParseFloat(s, 64)
	if err != nil {
		return fmt.Errorf("invalid decimal %q: %w", s, err)
	}
	if math.IsNaN(f) || math.IsInf(f, 0) {
		return fmt.Errorf("invalid decimal %q: NaN and Infinity are not allowed", s)
	}
	d.value = s
	return nil
}
