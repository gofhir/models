// Code generated by gofhir. DO NOT EDIT.
// Source: FHIR StructureDefinitions (consolidated resource)
// Package: r4b

package r4b

import (
	"bytes"
	"encoding/json"
	"encoding/xml"
	"fmt"
)

// =============================================================================
// MolecularSequence Resource
// =============================================================================

// MolecularSequence represents FHIR MolecularSequence.
type MolecularSequence struct {
	// FHIR resource type
	ResourceType string `json:"resourceType"`
	// Logical id of this artifact
	Id *string `json:"id,omitempty"`
	// Metadata about the resource
	Meta *Meta `json:"meta,omitempty"`
	// A set of rules under which this content was created
	ImplicitRules *string `json:"implicitRules,omitempty"`
	// Extension for ImplicitRules
	ImplicitRulesExt *Element `json:"_implicitRules,omitempty"`
	// Language of the resource content
	Language *string `json:"language,omitempty"`
	// Extension for Language
	LanguageExt *Element `json:"_language,omitempty"`
	// Text summary of the resource, for human interpretation
	Text *Narrative `json:"text,omitempty"`
	// Contained, inline Resources
	Contained []Resource `json:"contained,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Unique ID for this particular sequence. This is a FHIR-defined id
	Identifier []Identifier `json:"identifier,omitempty"`
	// aa | dna | rna
	Type *SequenceType `json:"type,omitempty"`
	// Extension for Type
	TypeExt *Element `json:"_type,omitempty"`
	// Base number of coordinate system (0 for 0-based numbering or coordinates, inclusive start, exclusive end, 1 for 1-based numbering, inclusive start, inclusive end)
	CoordinateSystem *int `json:"coordinateSystem,omitempty"`
	// Extension for CoordinateSystem
	CoordinateSystemExt *Element `json:"_coordinateSystem,omitempty"`
	// Who and/or what this is about
	Patient *Reference `json:"patient,omitempty"`
	// Specimen used for sequencing
	Specimen *Reference `json:"specimen,omitempty"`
	// The method for sequencing
	Device *Reference `json:"device,omitempty"`
	// Who should be responsible for test result
	Performer *Reference `json:"performer,omitempty"`
	// The number of copies of the sequence of interest.  (RNASeq)
	Quantity *Quantity `json:"quantity,omitempty"`
	// A sequence used as reference
	ReferenceSeq *MolecularSequenceReferenceSeq `json:"referenceSeq,omitempty"`
	// Variant in sequence
	Variant []MolecularSequenceVariant `json:"variant,omitempty"`
	// Sequence that was observed
	ObservedSeq *string `json:"observedSeq,omitempty"`
	// Extension for ObservedSeq
	ObservedSeqExt *Element `json:"_observedSeq,omitempty"`
	// An set of value as quality of sequence
	Quality []MolecularSequenceQuality `json:"quality,omitempty"`
	// Average number of reads representing a given nucleotide in the reconstructed sequence
	ReadCoverage *int `json:"readCoverage,omitempty"`
	// Extension for ReadCoverage
	ReadCoverageExt *Element `json:"_readCoverage,omitempty"`
	// External repository which contains detailed report related with observedSeq in this resource
	Repository []MolecularSequenceRepository `json:"repository,omitempty"`
	// Pointer to next atomic sequence
	Pointer []Reference `json:"pointer,omitempty"`
	// Structural variant
	StructureVariant []MolecularSequenceStructureVariant `json:"structureVariant,omitempty"`
}

// GetResourceType returns the FHIR resource type.
func (r *MolecularSequence) GetResourceType() string {
	return "MolecularSequence"
}

// GetId returns the resource's logical ID.
func (r *MolecularSequence) GetId() *string {
	return r.Id
}

// SetId sets the resource's logical ID.
func (r *MolecularSequence) SetId(id string) {
	r.Id = &id
}

// GetMeta returns the resource's Meta element.
func (r *MolecularSequence) GetMeta() *Meta {
	return r.Meta
}

// SetMeta sets the resource's Meta element.
func (r *MolecularSequence) SetMeta(m *Meta) {
	r.Meta = m
}

// GetText returns the resource's narrative text.
func (r *MolecularSequence) GetText() *Narrative {
	return r.Text
}

// SetText sets the resource's narrative text.
func (r *MolecularSequence) SetText(t *Narrative) {
	r.Text = t
}

// GetContained returns the resource's contained resources.
func (r *MolecularSequence) GetContained() []Resource {
	return r.Contained
}

// GetExtension returns the resource's extensions.
func (r *MolecularSequence) GetExtension() []Extension {
	return r.Extension
}

// GetModifierExtension returns the resource's modifier extensions.
func (r *MolecularSequence) GetModifierExtension() []Extension {
	return r.ModifierExtension
}

// MarshalJSON ensures resourceType is always included in JSON output.
// HTML escaping is disabled to preserve FHIR narrative XHTML content.
//
// Note: Use the package-level Marshal function instead of json.Marshal
// to ensure HTML in narrative text.div fields is not escaped.
func (r MolecularSequence) MarshalJSON() ([]byte, error) {
	r.ResourceType = "MolecularSequence"
	type Alias MolecularSequence
	var buf bytes.Buffer
	enc := json.NewEncoder(&buf)
	enc.SetEscapeHTML(false)
	if err := enc.Encode((Alias)(r)); err != nil {
		return nil, err
	}
	b := buf.Bytes()
	if len(b) > 0 && b[len(b)-1] == '\n' {
		b = b[:len(b)-1]
	}
	return b, nil
}

// UnmarshalJSON handles deserialization of polymorphic contained resources.
func (r *MolecularSequence) UnmarshalJSON(data []byte) error {
	// Use an alias to avoid infinite recursion
	type Alias MolecularSequence
	aux := &struct {
		Contained []json.RawMessage `json:"contained,omitempty"`
		*Alias
	}{
		Alias: (*Alias)(r),
	}

	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}

	// Unmarshal each contained resource using the dispatcher
	if len(aux.Contained) > 0 {
		r.Contained = make([]Resource, len(aux.Contained))
		for i, raw := range aux.Contained {
			resource, err := UnmarshalResource(raw)
			if err != nil {
				return fmt.Errorf("failed to unmarshal contained[%d]: %w", i, err)
			}
			r.Contained[i] = resource
		}
	}

	return nil
}

// MarshalXML serializes MolecularSequence to FHIR-conformant XML.
func (r MolecularSequence) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MolecularSequence"
		start.Name.Space = fhirNamespace
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	if err := xmlEncodePrimitiveString(e, "id", r.Id, nil); err != nil {
		return err
	}
	if r.Meta != nil {
		if err := r.Meta.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "meta"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "implicitRules", r.ImplicitRules, r.ImplicitRulesExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "language", r.Language, r.LanguageExt); err != nil {
		return err
	}
	if r.Text != nil {
		if err := r.Text.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "text"}}); err != nil {
			return err
		}
	}
	for _, c := range r.Contained {
		if c != nil {
			if err := xmlEncodeContainedResource(e, c); err != nil {
				return err
			}
		}
	}
	for _, item := range r.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range r.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Identifier {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "identifier"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveCode(e, "type", r.Type, r.TypeExt); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveInt(e, "coordinateSystem", r.CoordinateSystem, r.CoordinateSystemExt); err != nil {
		return err
	}
	if r.Patient != nil {
		if err := r.Patient.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "patient"}}); err != nil {
			return err
		}
	}
	if r.Specimen != nil {
		if err := r.Specimen.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "specimen"}}); err != nil {
			return err
		}
	}
	if r.Device != nil {
		if err := r.Device.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "device"}}); err != nil {
			return err
		}
	}
	if r.Performer != nil {
		if err := r.Performer.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "performer"}}); err != nil {
			return err
		}
	}
	if r.Quantity != nil {
		if err := r.Quantity.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "quantity"}}); err != nil {
			return err
		}
	}
	if r.ReferenceSeq != nil {
		if err := r.ReferenceSeq.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "referenceSeq"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Variant {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "variant"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "observedSeq", r.ObservedSeq, r.ObservedSeqExt); err != nil {
		return err
	}
	for _, item := range r.Quality {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "quality"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveInt(e, "readCoverage", r.ReadCoverage, r.ReadCoverageExt); err != nil {
		return err
	}
	for _, item := range r.Repository {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "repository"}}); err != nil {
			return err
		}
	}
	for _, item := range r.Pointer {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "pointer"}}); err != nil {
			return err
		}
	}
	for _, item := range r.StructureVariant {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "structureVariant"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MolecularSequence from FHIR-conformant XML.
func (r *MolecularSequence) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "id":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Id = v
			case "meta":
				var v Meta
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Meta = &v
			case "implicitRules":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ImplicitRules = v
				r.ImplicitRulesExt = ext
			case "language":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Language = v
				r.LanguageExt = ext
			case "text":
				var v Narrative
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Text = &v
			case "contained":
				res, err := xmlDecodeContainedResource(d, t)
				if err != nil {
					return err
				}
				if res != nil {
					r.Contained = append(r.Contained, res)
				}
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "identifier":
				var v Identifier
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Identifier = append(r.Identifier, v)
			case "type":
				v, ext, err := xmlDecodePrimitiveCode[SequenceType](d, t)
				if err != nil {
					return err
				}
				r.Type = v
				r.TypeExt = ext
			case "coordinateSystem":
				v, ext, err := xmlDecodePrimitiveInt(d, t)
				if err != nil {
					return err
				}
				r.CoordinateSystem = v
				r.CoordinateSystemExt = ext
			case "patient":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Patient = &v
			case "specimen":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Specimen = &v
			case "device":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Device = &v
			case "performer":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Performer = &v
			case "quantity":
				var v Quantity
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Quantity = &v
			case "referenceSeq":
				var v MolecularSequenceReferenceSeq
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ReferenceSeq = &v
			case "variant":
				var v MolecularSequenceVariant
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Variant = append(r.Variant, v)
			case "observedSeq":
				v, ext, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ObservedSeq = v
				r.ObservedSeqExt = ext
			case "quality":
				var v MolecularSequenceQuality
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Quality = append(r.Quality, v)
			case "readCoverage":
				v, ext, err := xmlDecodePrimitiveInt(d, t)
				if err != nil {
					return err
				}
				r.ReadCoverage = v
				r.ReadCoverageExt = ext
			case "repository":
				var v MolecularSequenceRepository
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Repository = append(r.Repository, v)
			case "pointer":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Pointer = append(r.Pointer, v)
			case "structureVariant":
				var v MolecularSequenceStructureVariant
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.StructureVariant = append(r.StructureVariant, v)
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MolecularSequenceQuality represents the MolecularSequence.quality backbone element.
// An set of value as quality of sequence
type MolecularSequenceQuality struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// indel | snp | unknown
	Type *QualityType `json:"type,omitempty"`
	// Standard sequence for comparison
	StandardSequence *CodeableConcept `json:"standardSequence,omitempty"`
	// Start position of the sequence
	Start *int `json:"start,omitempty"`
	// End position of the sequence
	End *int `json:"end,omitempty"`
	// Quality score for the comparison
	Score *Quantity `json:"score,omitempty"`
	// Method to get quality
	Method *CodeableConcept `json:"method,omitempty"`
	// True positives from the perspective of the truth data
	TruthTP *Decimal `json:"truthTP,omitempty"`
	// True positives from the perspective of the query data
	QueryTP *Decimal `json:"queryTP,omitempty"`
	// False negatives
	TruthFN *Decimal `json:"truthFN,omitempty"`
	// False positives
	QueryFP *Decimal `json:"queryFP,omitempty"`
	// False positives where the non-REF alleles in the Truth and Query Call Sets match
	GtFP *Decimal `json:"gtFP,omitempty"`
	// Precision of comparison
	Precision *Decimal `json:"precision,omitempty"`
	// Recall of comparison
	Recall *Decimal `json:"recall,omitempty"`
	// F-score
	FScore *Decimal `json:"fScore,omitempty"`
	// Receiver Operator Characteristic (ROC) Curve
	Roc *MolecularSequenceQualityRoc `json:"roc,omitempty"`
}

// MarshalXML serializes MolecularSequenceQuality to FHIR-conformant XML.
func (b MolecularSequenceQuality) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MolecularSequence.quality"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveCode(e, "type", b.Type, nil); err != nil {
		return err
	}
	if b.StandardSequence != nil {
		if err := b.StandardSequence.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "standardSequence"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveInt(e, "start", b.Start, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveInt(e, "end", b.End, nil); err != nil {
		return err
	}
	if b.Score != nil {
		if err := b.Score.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "score"}}); err != nil {
			return err
		}
	}
	if b.Method != nil {
		if err := b.Method.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "method"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveDecimal(e, "truthTP", b.TruthTP, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveDecimal(e, "queryTP", b.QueryTP, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveDecimal(e, "truthFN", b.TruthFN, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveDecimal(e, "queryFP", b.QueryFP, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveDecimal(e, "gtFP", b.GtFP, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveDecimal(e, "precision", b.Precision, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveDecimal(e, "recall", b.Recall, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveDecimal(e, "fScore", b.FScore, nil); err != nil {
		return err
	}
	if b.Roc != nil {
		if err := b.Roc.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "roc"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MolecularSequenceQuality from FHIR-conformant XML.
func (r *MolecularSequenceQuality) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "type":
				v, _, err := xmlDecodePrimitiveCode[QualityType](d, t)
				if err != nil {
					return err
				}
				r.Type = v
			case "standardSequence":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.StandardSequence = &v
			case "start":
				v, _, err := xmlDecodePrimitiveInt(d, t)
				if err != nil {
					return err
				}
				r.Start = v
			case "end":
				v, _, err := xmlDecodePrimitiveInt(d, t)
				if err != nil {
					return err
				}
				r.End = v
			case "score":
				var v Quantity
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Score = &v
			case "method":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Method = &v
			case "truthTP":
				v, _, err := xmlDecodePrimitiveDecimal(d, t)
				if err != nil {
					return err
				}
				r.TruthTP = v
			case "queryTP":
				v, _, err := xmlDecodePrimitiveDecimal(d, t)
				if err != nil {
					return err
				}
				r.QueryTP = v
			case "truthFN":
				v, _, err := xmlDecodePrimitiveDecimal(d, t)
				if err != nil {
					return err
				}
				r.TruthFN = v
			case "queryFP":
				v, _, err := xmlDecodePrimitiveDecimal(d, t)
				if err != nil {
					return err
				}
				r.QueryFP = v
			case "gtFP":
				v, _, err := xmlDecodePrimitiveDecimal(d, t)
				if err != nil {
					return err
				}
				r.GtFP = v
			case "precision":
				v, _, err := xmlDecodePrimitiveDecimal(d, t)
				if err != nil {
					return err
				}
				r.Precision = v
			case "recall":
				v, _, err := xmlDecodePrimitiveDecimal(d, t)
				if err != nil {
					return err
				}
				r.Recall = v
			case "fScore":
				v, _, err := xmlDecodePrimitiveDecimal(d, t)
				if err != nil {
					return err
				}
				r.FScore = v
			case "roc":
				var v MolecularSequenceQualityRoc
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Roc = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MolecularSequenceQualityRoc represents the MolecularSequence.quality.roc backbone element.
// Receiver Operator Characteristic (ROC) Curve
type MolecularSequenceQualityRoc struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Genotype quality score
	Score []int `json:"score,omitempty"`
	// Roc score true positive numbers
	NumTP []int `json:"numTP,omitempty"`
	// Roc score false positive numbers
	NumFP []int `json:"numFP,omitempty"`
	// Roc score false negative numbers
	NumFN []int `json:"numFN,omitempty"`
	// Precision of the GQ score
	Precision []Decimal `json:"precision,omitempty"`
	// Sensitivity of the GQ score
	Sensitivity []Decimal `json:"sensitivity,omitempty"`
	// FScore of the GQ score
	FMeasure []Decimal `json:"fMeasure,omitempty"`
}

// MarshalXML serializes MolecularSequenceQualityRoc to FHIR-conformant XML.
func (b MolecularSequenceQualityRoc) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MolecularSequence.quality.roc"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveIntArray(e, "score", b.Score, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveIntArray(e, "numTP", b.NumTP, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveIntArray(e, "numFP", b.NumFP, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveIntArray(e, "numFN", b.NumFN, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveDecimalArray(e, "precision", b.Precision, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveDecimalArray(e, "sensitivity", b.Sensitivity, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveDecimalArray(e, "fMeasure", b.FMeasure, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MolecularSequenceQualityRoc from FHIR-conformant XML.
func (r *MolecularSequenceQualityRoc) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "score":
				v, _, err := xmlDecodePrimitiveInt(d, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.Score = append(r.Score, *v)
				}
			case "numTP":
				v, _, err := xmlDecodePrimitiveInt(d, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.NumTP = append(r.NumTP, *v)
				}
			case "numFP":
				v, _, err := xmlDecodePrimitiveInt(d, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.NumFP = append(r.NumFP, *v)
				}
			case "numFN":
				v, _, err := xmlDecodePrimitiveInt(d, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.NumFN = append(r.NumFN, *v)
				}
			case "precision":
				v, _, err := xmlDecodePrimitiveDecimal(d, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.Precision = append(r.Precision, *v)
				}
			case "sensitivity":
				v, _, err := xmlDecodePrimitiveDecimal(d, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.Sensitivity = append(r.Sensitivity, *v)
				}
			case "fMeasure":
				v, _, err := xmlDecodePrimitiveDecimal(d, t)
				if err != nil {
					return err
				}
				if v != nil {
					r.FMeasure = append(r.FMeasure, *v)
				}
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MolecularSequenceReferenceSeq represents the MolecularSequence.referenceSeq backbone element.
// A sequence used as reference
type MolecularSequenceReferenceSeq struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Chromosome containing genetic finding
	Chromosome *CodeableConcept `json:"chromosome,omitempty"`
	// The Genome Build used for reference, following GRCh build versions e.g. 'GRCh 37'
	GenomeBuild *string `json:"genomeBuild,omitempty"`
	// sense | antisense
	Orientation *OrientationType `json:"orientation,omitempty"`
	// Reference identifier
	ReferenceSeqId *CodeableConcept `json:"referenceSeqId,omitempty"`
	// A pointer to another MolecularSequence entity as reference sequence
	ReferenceSeqPointer *Reference `json:"referenceSeqPointer,omitempty"`
	// A string to represent reference sequence
	ReferenceSeqString *string `json:"referenceSeqString,omitempty"`
	// watson | crick
	Strand *StrandType `json:"strand,omitempty"`
	// Start position of the window on the  reference sequence
	WindowStart *int `json:"windowStart,omitempty"`
	// End position of the window on the reference sequence
	WindowEnd *int `json:"windowEnd,omitempty"`
}

// MarshalXML serializes MolecularSequenceReferenceSeq to FHIR-conformant XML.
func (b MolecularSequenceReferenceSeq) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MolecularSequence.referenceSeq"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.Chromosome != nil {
		if err := b.Chromosome.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "chromosome"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "genomeBuild", b.GenomeBuild, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveCode(e, "orientation", b.Orientation, nil); err != nil {
		return err
	}
	if b.ReferenceSeqId != nil {
		if err := b.ReferenceSeqId.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "referenceSeqId"}}); err != nil {
			return err
		}
	}
	if b.ReferenceSeqPointer != nil {
		if err := b.ReferenceSeqPointer.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "referenceSeqPointer"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveString(e, "referenceSeqString", b.ReferenceSeqString, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveCode(e, "strand", b.Strand, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveInt(e, "windowStart", b.WindowStart, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveInt(e, "windowEnd", b.WindowEnd, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MolecularSequenceReferenceSeq from FHIR-conformant XML.
func (r *MolecularSequenceReferenceSeq) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "chromosome":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Chromosome = &v
			case "genomeBuild":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.GenomeBuild = v
			case "orientation":
				v, _, err := xmlDecodePrimitiveCode[OrientationType](d, t)
				if err != nil {
					return err
				}
				r.Orientation = v
			case "referenceSeqId":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ReferenceSeqId = &v
			case "referenceSeqPointer":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ReferenceSeqPointer = &v
			case "referenceSeqString":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ReferenceSeqString = v
			case "strand":
				v, _, err := xmlDecodePrimitiveCode[StrandType](d, t)
				if err != nil {
					return err
				}
				r.Strand = v
			case "windowStart":
				v, _, err := xmlDecodePrimitiveInt(d, t)
				if err != nil {
					return err
				}
				r.WindowStart = v
			case "windowEnd":
				v, _, err := xmlDecodePrimitiveInt(d, t)
				if err != nil {
					return err
				}
				r.WindowEnd = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MolecularSequenceRepository represents the MolecularSequence.repository backbone element.
// External repository which contains detailed report related with observedSeq in this resource
type MolecularSequenceRepository struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// directlink | openapi | login | oauth | other
	Type *RepositoryType `json:"type,omitempty"`
	// URI of the repository
	Url *string `json:"url,omitempty"`
	// Repository's name
	Name *string `json:"name,omitempty"`
	// Id of the dataset that used to call for dataset in repository
	DatasetId *string `json:"datasetId,omitempty"`
	// Id of the variantset that used to call for variantset in repository
	VariantsetId *string `json:"variantsetId,omitempty"`
	// Id of the read
	ReadsetId *string `json:"readsetId,omitempty"`
}

// MarshalXML serializes MolecularSequenceRepository to FHIR-conformant XML.
func (b MolecularSequenceRepository) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MolecularSequence.repository"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveCode(e, "type", b.Type, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "url", b.Url, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "name", b.Name, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "datasetId", b.DatasetId, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "variantsetId", b.VariantsetId, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "readsetId", b.ReadsetId, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MolecularSequenceRepository from FHIR-conformant XML.
func (r *MolecularSequenceRepository) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "type":
				v, _, err := xmlDecodePrimitiveCode[RepositoryType](d, t)
				if err != nil {
					return err
				}
				r.Type = v
			case "url":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Url = v
			case "name":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Name = v
			case "datasetId":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.DatasetId = v
			case "variantsetId":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.VariantsetId = v
			case "readsetId":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ReadsetId = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MolecularSequenceStructureVariant represents the MolecularSequence.structureVariant backbone element.
// Structural variant
type MolecularSequenceStructureVariant struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Structural variant change type
	VariantType *CodeableConcept `json:"variantType,omitempty"`
	// Does the structural variant have base pair resolution breakpoints?
	Exact *bool `json:"exact,omitempty"`
	// Structural variant length
	Length *int `json:"length,omitempty"`
	// Structural variant outer
	Outer *MolecularSequenceStructureVariantOuter `json:"outer,omitempty"`
	// Structural variant inner
	Inner *MolecularSequenceStructureVariantInner `json:"inner,omitempty"`
}

// MarshalXML serializes MolecularSequenceStructureVariant to FHIR-conformant XML.
func (b MolecularSequenceStructureVariant) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MolecularSequence.structureVariant"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if b.VariantType != nil {
		if err := b.VariantType.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "variantType"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveBool(e, "exact", b.Exact, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveInt(e, "length", b.Length, nil); err != nil {
		return err
	}
	if b.Outer != nil {
		if err := b.Outer.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "outer"}}); err != nil {
			return err
		}
	}
	if b.Inner != nil {
		if err := b.Inner.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "inner"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MolecularSequenceStructureVariant from FHIR-conformant XML.
func (r *MolecularSequenceStructureVariant) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "variantType":
				var v CodeableConcept
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.VariantType = &v
			case "exact":
				v, _, err := xmlDecodePrimitiveBool(d, t)
				if err != nil {
					return err
				}
				r.Exact = v
			case "length":
				v, _, err := xmlDecodePrimitiveInt(d, t)
				if err != nil {
					return err
				}
				r.Length = v
			case "outer":
				var v MolecularSequenceStructureVariantOuter
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Outer = &v
			case "inner":
				var v MolecularSequenceStructureVariantInner
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Inner = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MolecularSequenceStructureVariantInner represents the MolecularSequence.structureVariant.inner backbone element.
// Structural variant inner
type MolecularSequenceStructureVariantInner struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Structural variant inner start
	Start *int `json:"start,omitempty"`
	// Structural variant inner end
	End *int `json:"end,omitempty"`
}

// MarshalXML serializes MolecularSequenceStructureVariantInner to FHIR-conformant XML.
func (b MolecularSequenceStructureVariantInner) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MolecularSequence.structureVariant.inner"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveInt(e, "start", b.Start, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveInt(e, "end", b.End, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MolecularSequenceStructureVariantInner from FHIR-conformant XML.
func (r *MolecularSequenceStructureVariantInner) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "start":
				v, _, err := xmlDecodePrimitiveInt(d, t)
				if err != nil {
					return err
				}
				r.Start = v
			case "end":
				v, _, err := xmlDecodePrimitiveInt(d, t)
				if err != nil {
					return err
				}
				r.End = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MolecularSequenceStructureVariantOuter represents the MolecularSequence.structureVariant.outer backbone element.
// Structural variant outer
type MolecularSequenceStructureVariantOuter struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Structural variant outer start
	Start *int `json:"start,omitempty"`
	// Structural variant outer end
	End *int `json:"end,omitempty"`
}

// MarshalXML serializes MolecularSequenceStructureVariantOuter to FHIR-conformant XML.
func (b MolecularSequenceStructureVariantOuter) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MolecularSequence.structureVariant.outer"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveInt(e, "start", b.Start, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveInt(e, "end", b.End, nil); err != nil {
		return err
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MolecularSequenceStructureVariantOuter from FHIR-conformant XML.
func (r *MolecularSequenceStructureVariantOuter) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "start":
				v, _, err := xmlDecodePrimitiveInt(d, t)
				if err != nil {
					return err
				}
				r.Start = v
			case "end":
				v, _, err := xmlDecodePrimitiveInt(d, t)
				if err != nil {
					return err
				}
				r.End = v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// MolecularSequenceVariant represents the MolecularSequence.variant backbone element.
// Variant in sequence
type MolecularSequenceVariant struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Start position of the variant on the  reference sequence
	Start *int `json:"start,omitempty"`
	// End position of the variant on the reference sequence
	End *int `json:"end,omitempty"`
	// Allele that was observed
	ObservedAllele *string `json:"observedAllele,omitempty"`
	// Allele in the reference sequence
	ReferenceAllele *string `json:"referenceAllele,omitempty"`
	// Extended CIGAR string for aligning the sequence with reference bases
	Cigar *string `json:"cigar,omitempty"`
	// Pointer to observed variant information
	VariantPointer *Reference `json:"variantPointer,omitempty"`
}

// MarshalXML serializes MolecularSequenceVariant to FHIR-conformant XML.
func (b MolecularSequenceVariant) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if start.Name.Local == "" {
		start.Name.Local = "MolecularSequence.variant"
	}
	if b.Id != nil {
		start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "id"}, Value: *b.Id})
	}
	if err := e.EncodeToken(start); err != nil {
		return err
	}

	for _, item := range b.Extension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "extension"}}); err != nil {
			return err
		}
	}
	for _, item := range b.ModifierExtension {
		if err := item.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "modifierExtension"}}); err != nil {
			return err
		}
	}
	if err := xmlEncodePrimitiveInt(e, "start", b.Start, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveInt(e, "end", b.End, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "observedAllele", b.ObservedAllele, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "referenceAllele", b.ReferenceAllele, nil); err != nil {
		return err
	}
	if err := xmlEncodePrimitiveString(e, "cigar", b.Cigar, nil); err != nil {
		return err
	}
	if b.VariantPointer != nil {
		if err := b.VariantPointer.MarshalXML(e, xml.StartElement{Name: xml.Name{Local: "variantPointer"}}); err != nil {
			return err
		}
	}

	return e.EncodeToken(start.End())
}

// UnmarshalXML deserializes MolecularSequenceVariant from FHIR-conformant XML.
func (r *MolecularSequenceVariant) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	for _, attr := range start.Attr {
		if attr.Name.Local == "id" {
			v := attr.Value
			r.Id = &v
		}
	}

	for {
		tok, err := d.Token()
		if err != nil {
			return err
		}
		switch t := tok.(type) {
		case xml.StartElement:
			switch t.Name.Local {
			case "extension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.Extension = append(r.Extension, v)
			case "modifierExtension":
				var v Extension
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.ModifierExtension = append(r.ModifierExtension, v)
			case "start":
				v, _, err := xmlDecodePrimitiveInt(d, t)
				if err != nil {
					return err
				}
				r.Start = v
			case "end":
				v, _, err := xmlDecodePrimitiveInt(d, t)
				if err != nil {
					return err
				}
				r.End = v
			case "observedAllele":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ObservedAllele = v
			case "referenceAllele":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.ReferenceAllele = v
			case "cigar":
				v, _, err := xmlDecodePrimitiveString(d, t)
				if err != nil {
					return err
				}
				r.Cigar = v
			case "variantPointer":
				var v Reference
				if err := v.UnmarshalXML(d, t); err != nil {
					return err
				}
				r.VariantPointer = &v
			default:
				if err := d.Skip(); err != nil {
					return err
				}
			}
		case xml.EndElement:
			return nil
		}
	}
}

// =============================================================================
// MolecularSequence - Fluent Builder
// =============================================================================

// MolecularSequenceBuilder provides a fluent API for constructing MolecularSequence resources.
type MolecularSequenceBuilder struct {
	molecularSequence *MolecularSequence
}

// NewMolecularSequenceBuilder creates a new MolecularSequenceBuilder.
func NewMolecularSequenceBuilder() *MolecularSequenceBuilder {
	return &MolecularSequenceBuilder{
		molecularSequence: &MolecularSequence{},
	}
}

// Build returns the constructed MolecularSequence resource.
func (b *MolecularSequenceBuilder) Build() *MolecularSequence {
	return b.molecularSequence
}

// SetId sets the Id field.
func (b *MolecularSequenceBuilder) SetId(v string) *MolecularSequenceBuilder {
	b.molecularSequence.Id = &v
	return b
}

// SetMeta sets the Meta field.
func (b *MolecularSequenceBuilder) SetMeta(v Meta) *MolecularSequenceBuilder {
	b.molecularSequence.Meta = &v
	return b
}

// SetImplicitRules sets the ImplicitRules field.
func (b *MolecularSequenceBuilder) SetImplicitRules(v string) *MolecularSequenceBuilder {
	b.molecularSequence.ImplicitRules = &v
	return b
}

// SetLanguage sets the Language field.
func (b *MolecularSequenceBuilder) SetLanguage(v string) *MolecularSequenceBuilder {
	b.molecularSequence.Language = &v
	return b
}

// SetText sets the Text field.
func (b *MolecularSequenceBuilder) SetText(v Narrative) *MolecularSequenceBuilder {
	b.molecularSequence.Text = &v
	return b
}

// AddContained adds a Contained element.
func (b *MolecularSequenceBuilder) AddContained(v Resource) *MolecularSequenceBuilder {
	b.molecularSequence.Contained = append(b.molecularSequence.Contained, v)
	return b
}

// AddExtension adds a Extension element.
func (b *MolecularSequenceBuilder) AddExtension(v Extension) *MolecularSequenceBuilder {
	b.molecularSequence.Extension = append(b.molecularSequence.Extension, v)
	return b
}

// AddModifierExtension adds a ModifierExtension element.
func (b *MolecularSequenceBuilder) AddModifierExtension(v Extension) *MolecularSequenceBuilder {
	b.molecularSequence.ModifierExtension = append(b.molecularSequence.ModifierExtension, v)
	return b
}

// AddIdentifier adds a Identifier element.
func (b *MolecularSequenceBuilder) AddIdentifier(v Identifier) *MolecularSequenceBuilder {
	b.molecularSequence.Identifier = append(b.molecularSequence.Identifier, v)
	return b
}

// SetType sets the Type field.
func (b *MolecularSequenceBuilder) SetType(v SequenceType) *MolecularSequenceBuilder {
	b.molecularSequence.Type = &v
	return b
}

// SetCoordinateSystem sets the CoordinateSystem field.
func (b *MolecularSequenceBuilder) SetCoordinateSystem(v int) *MolecularSequenceBuilder {
	b.molecularSequence.CoordinateSystem = &v
	return b
}

// SetPatient sets the Patient field.
func (b *MolecularSequenceBuilder) SetPatient(v Reference) *MolecularSequenceBuilder {
	b.molecularSequence.Patient = &v
	return b
}

// SetSpecimen sets the Specimen field.
func (b *MolecularSequenceBuilder) SetSpecimen(v Reference) *MolecularSequenceBuilder {
	b.molecularSequence.Specimen = &v
	return b
}

// SetDevice sets the Device field.
func (b *MolecularSequenceBuilder) SetDevice(v Reference) *MolecularSequenceBuilder {
	b.molecularSequence.Device = &v
	return b
}

// SetPerformer sets the Performer field.
func (b *MolecularSequenceBuilder) SetPerformer(v Reference) *MolecularSequenceBuilder {
	b.molecularSequence.Performer = &v
	return b
}

// SetQuantity sets the Quantity field.
func (b *MolecularSequenceBuilder) SetQuantity(v Quantity) *MolecularSequenceBuilder {
	b.molecularSequence.Quantity = &v
	return b
}

// SetReferenceSeq sets the ReferenceSeq field.
func (b *MolecularSequenceBuilder) SetReferenceSeq(v MolecularSequenceReferenceSeq) *MolecularSequenceBuilder {
	b.molecularSequence.ReferenceSeq = &v
	return b
}

// AddVariant adds a Variant element.
func (b *MolecularSequenceBuilder) AddVariant(v MolecularSequenceVariant) *MolecularSequenceBuilder {
	b.molecularSequence.Variant = append(b.molecularSequence.Variant, v)
	return b
}

// SetObservedSeq sets the ObservedSeq field.
func (b *MolecularSequenceBuilder) SetObservedSeq(v string) *MolecularSequenceBuilder {
	b.molecularSequence.ObservedSeq = &v
	return b
}

// AddQuality adds a Quality element.
func (b *MolecularSequenceBuilder) AddQuality(v MolecularSequenceQuality) *MolecularSequenceBuilder {
	b.molecularSequence.Quality = append(b.molecularSequence.Quality, v)
	return b
}

// SetReadCoverage sets the ReadCoverage field.
func (b *MolecularSequenceBuilder) SetReadCoverage(v int) *MolecularSequenceBuilder {
	b.molecularSequence.ReadCoverage = &v
	return b
}

// AddRepository adds a Repository element.
func (b *MolecularSequenceBuilder) AddRepository(v MolecularSequenceRepository) *MolecularSequenceBuilder {
	b.molecularSequence.Repository = append(b.molecularSequence.Repository, v)
	return b
}

// AddPointer adds a Pointer element.
func (b *MolecularSequenceBuilder) AddPointer(v Reference) *MolecularSequenceBuilder {
	b.molecularSequence.Pointer = append(b.molecularSequence.Pointer, v)
	return b
}

// AddStructureVariant adds a StructureVariant element.
func (b *MolecularSequenceBuilder) AddStructureVariant(v MolecularSequenceStructureVariant) *MolecularSequenceBuilder {
	b.molecularSequence.StructureVariant = append(b.molecularSequence.StructureVariant, v)
	return b
}

// =============================================================================
// MolecularSequence - Functional Options
// =============================================================================

// MolecularSequenceOption is a functional option for configuring a MolecularSequence.
type MolecularSequenceOption func(*MolecularSequence)

// NewMolecularSequence creates a new MolecularSequence with the given options.
func NewMolecularSequence(opts ...MolecularSequenceOption) *MolecularSequence {
	r := &MolecularSequence{}
	for _, opt := range opts {
		opt(r)
	}
	return r
}

// WithMolecularSequenceId sets the Id field.
func WithMolecularSequenceId(v string) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.Id = &v
	}
}

// WithMolecularSequenceMeta sets the Meta field.
func WithMolecularSequenceMeta(v Meta) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.Meta = &v
	}
}

// WithMolecularSequenceImplicitRules sets the ImplicitRules field.
func WithMolecularSequenceImplicitRules(v string) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.ImplicitRules = &v
	}
}

// WithMolecularSequenceLanguage sets the Language field.
func WithMolecularSequenceLanguage(v string) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.Language = &v
	}
}

// WithMolecularSequenceText sets the Text field.
func WithMolecularSequenceText(v Narrative) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.Text = &v
	}
}

// WithMolecularSequenceContained adds a Contained to the MolecularSequence.
func WithMolecularSequenceContained(v Resource) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.Contained = append(r.Contained, v)
	}
}

// WithMolecularSequenceExtension adds a Extension to the MolecularSequence.
func WithMolecularSequenceExtension(v Extension) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.Extension = append(r.Extension, v)
	}
}

// WithMolecularSequenceModifierExtension adds a ModifierExtension to the MolecularSequence.
func WithMolecularSequenceModifierExtension(v Extension) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.ModifierExtension = append(r.ModifierExtension, v)
	}
}

// WithMolecularSequenceIdentifier adds a Identifier to the MolecularSequence.
func WithMolecularSequenceIdentifier(v Identifier) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.Identifier = append(r.Identifier, v)
	}
}

// WithMolecularSequenceType sets the Type field.
func WithMolecularSequenceType(v SequenceType) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.Type = &v
	}
}

// WithMolecularSequenceCoordinateSystem sets the CoordinateSystem field.
func WithMolecularSequenceCoordinateSystem(v int) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.CoordinateSystem = &v
	}
}

// WithMolecularSequencePatient sets the Patient field.
func WithMolecularSequencePatient(v Reference) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.Patient = &v
	}
}

// WithMolecularSequenceSpecimen sets the Specimen field.
func WithMolecularSequenceSpecimen(v Reference) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.Specimen = &v
	}
}

// WithMolecularSequenceDevice sets the Device field.
func WithMolecularSequenceDevice(v Reference) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.Device = &v
	}
}

// WithMolecularSequencePerformer sets the Performer field.
func WithMolecularSequencePerformer(v Reference) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.Performer = &v
	}
}

// WithMolecularSequenceQuantity sets the Quantity field.
func WithMolecularSequenceQuantity(v Quantity) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.Quantity = &v
	}
}

// WithMolecularSequenceReferenceSeq sets the ReferenceSeq field.
func WithMolecularSequenceReferenceSeq(v MolecularSequenceReferenceSeq) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.ReferenceSeq = &v
	}
}

// WithMolecularSequenceVariant adds a Variant to the MolecularSequence.
func WithMolecularSequenceVariant(v MolecularSequenceVariant) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.Variant = append(r.Variant, v)
	}
}

// WithMolecularSequenceObservedSeq sets the ObservedSeq field.
func WithMolecularSequenceObservedSeq(v string) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.ObservedSeq = &v
	}
}

// WithMolecularSequenceQuality adds a Quality to the MolecularSequence.
func WithMolecularSequenceQuality(v MolecularSequenceQuality) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.Quality = append(r.Quality, v)
	}
}

// WithMolecularSequenceReadCoverage sets the ReadCoverage field.
func WithMolecularSequenceReadCoverage(v int) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.ReadCoverage = &v
	}
}

// WithMolecularSequenceRepository adds a Repository to the MolecularSequence.
func WithMolecularSequenceRepository(v MolecularSequenceRepository) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.Repository = append(r.Repository, v)
	}
}

// WithMolecularSequencePointer adds a Pointer to the MolecularSequence.
func WithMolecularSequencePointer(v Reference) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.Pointer = append(r.Pointer, v)
	}
}

// WithMolecularSequenceStructureVariant adds a StructureVariant to the MolecularSequence.
func WithMolecularSequenceStructureVariant(v MolecularSequenceStructureVariant) MolecularSequenceOption {
	return func(r *MolecularSequence) {
		r.StructureVariant = append(r.StructureVariant, v)
	}
}
